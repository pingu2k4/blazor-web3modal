var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x8) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x8, {
  get: (a9, b10) => (typeof require !== "undefined" ? require : a9)[b10]
}) : x8)(function(x8) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x8 + '" is not supported');
});
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to2, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to2;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn3, context, once) {
      this.fn = fn3;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn3, context, once) {
      if (typeof fn3 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn3, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter7() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter7.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2))
          names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter7.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i10 = 0, l9 = handlers.length, ee3 = new Array(l9); i10 < l9; i10++) {
        ee3[i10] = handlers[i10].fn;
      }
      return ee3;
    };
    EventEmitter7.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter7.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i10;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
        }
        for (i10 = 1, args = new Array(len - 1); i10 < len; i10++) {
          args[i10 - 1] = arguments[i10];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j8;
        for (i10 = 0; i10 < length2; i10++) {
          if (listeners[i10].once)
            this.removeListener(event, listeners[i10].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i10].fn.call(listeners[i10].context);
              break;
            case 2:
              listeners[i10].fn.call(listeners[i10].context, a1);
              break;
            case 3:
              listeners[i10].fn.call(listeners[i10].context, a1, a22);
              break;
            case 4:
              listeners[i10].fn.call(listeners[i10].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j8 = 1, args = new Array(len - 1); j8 < len; j8++) {
                  args[j8 - 1] = arguments[j8];
                }
              listeners[i10].fn.apply(listeners[i10].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter7.prototype.on = function on2(event, fn3, context) {
      return addListener(this, event, fn3, context, false);
    };
    EventEmitter7.prototype.once = function once(event, fn3, context) {
      return addListener(this, event, fn3, context, true);
    };
    EventEmitter7.prototype.removeListener = function removeListener(event, fn3, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn3) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn3 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i10 = 0, events = [], length2 = listeners.length; i10 < length2; i10++) {
          if (listeners[i10].fn !== fn3 || once && !listeners[i10].once || context && listeners[i10].context !== context) {
            events.push(listeners[i10]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter7.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter7.prototype.off = EventEmitter7.prototype.removeListener;
    EventEmitter7.prototype.addListener = EventEmitter7.prototype.on;
    EventEmitter7.prefixed = prefix;
    EventEmitter7.EventEmitter = EventEmitter7;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter7;
    }
  }
});

// (disabled):node_modules/buffer/index.js
var require_buffer = __commonJS({
  "(disabled):node_modules/buffer/index.js"() {
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base3, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e11) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert3(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN.prototype._initArray = function _initArray(number, base3, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          this.words[i10] = 0;
        }
        var j8, w11;
        var off = 0;
        if (endian === "be") {
          for (i10 = number.length - 1, j8 = 0; i10 >= 0; i10 -= 3) {
            w11 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
            this.words[j8] |= w11 << off & 67108863;
            this.words[j8 + 1] = w11 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i10 = 0, j8 = 0; i10 < number.length; i10 += 3) {
            w11 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
            this.words[j8] |= w11 << off & 67108863;
            this.words[j8 + 1] = w11 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c8 = string2.charCodeAt(index);
        if (c8 >= 48 && c8 <= 57) {
          return c8 - 48;
        } else if (c8 >= 65 && c8 <= 70) {
          return c8 - 55;
        } else if (c8 >= 97 && c8 <= 102) {
          return c8 - 87;
        } else {
          assert3(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r7 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r7 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r7;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          this.words[i10] = 0;
        }
        var off = 0;
        var j8 = 0;
        var w11;
        if (endian === "be") {
          for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
            w11 = parseHexByte(number, start, i10) << off;
            this.words[j8] |= w11 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w11 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
            w11 = parseHexByte(number, start, i10) << off;
            this.words[j8] |= w11 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w11 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r7 = 0;
        var b10 = 0;
        var len = Math.min(str.length, end);
        for (var i10 = start; i10 < len; i10++) {
          var c8 = str.charCodeAt(i10) - 48;
          r7 *= mul;
          if (c8 >= 49) {
            b10 = c8 - 49 + 10;
          } else if (c8 >= 17) {
            b10 = c8 - 17 + 10;
          } else {
            b10 = c8;
          }
          assert3(c8 >= 0 && b10 < mul, "Invalid character");
          r7 += b10;
        }
        return r7;
      }
      BN.prototype._parseBase = function _parseBase(number, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i10 = start; i10 < end; i10 += limbLen) {
          word = parseBase(number, i10, i10 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i10, number.length, base3);
          for (i10 = 0; i10 < mod; i10++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          dest.words[i10] = this.words[i10];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r7 = new BN(null);
        this.copy(r7);
        return r7;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e11) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base3, padding) {
        base3 = base3 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w11 = this.words[i10];
            var word = ((w11 << off | carry) & 16777215).toString(16);
            carry = w11 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i10--;
            }
            if (carry !== 0 || i10 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c8 = this.clone();
          c8.negative = 0;
          while (!c8.isZero()) {
            var r7 = c8.modrn(groupBase).toString(base3);
            c8 = c8.idivn(groupBase);
            if (!c8.isZero()) {
              out = zeros[groupSize - r7.length] + r7 + out;
            } else {
              out = r7 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer2, endian, length2);
        };
      }
      BN.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i10 = 0, shift = 0; i10 < this.length; i10++) {
          var word = this.words[i10] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i10 = 0, shift = 0; i10 < this.length; i10++) {
          var word = this.words[i10] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w11) {
          return 32 - Math.clz32(w11);
        };
      } else {
        BN.prototype._countBits = function _countBits(w11) {
          var t8 = w11;
          var r7 = 0;
          if (t8 >= 4096) {
            r7 += 13;
            t8 >>>= 13;
          }
          if (t8 >= 64) {
            r7 += 7;
            t8 >>>= 7;
          }
          if (t8 >= 8) {
            r7 += 4;
            t8 >>>= 4;
          }
          if (t8 >= 2) {
            r7 += 2;
            t8 >>>= 2;
          }
          return r7 + t8;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w11) {
        if (w11 === 0)
          return 26;
        var t8 = w11;
        var r7 = 0;
        if ((t8 & 8191) === 0) {
          r7 += 13;
          t8 >>>= 13;
        }
        if ((t8 & 127) === 0) {
          r7 += 7;
          t8 >>>= 7;
        }
        if ((t8 & 15) === 0) {
          r7 += 4;
          t8 >>>= 4;
        }
        if ((t8 & 3) === 0) {
          r7 += 2;
          t8 >>>= 2;
        }
        if ((t8 & 1) === 0) {
          r7++;
        }
        return r7;
      };
      BN.prototype.bitLength = function bitLength() {
        var w11 = this.words[this.length - 1];
        var hi = this._countBits(w11);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w11 = new Array(num.bitLength());
        for (var bit = 0; bit < w11.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w11[bit] = num.words[off] >>> wbit & 1;
        }
        return w11;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r7 = 0;
        for (var i10 = 0; i10 < this.length; i10++) {
          var b10 = this._zeroBits(this.words[i10]);
          r7 += b10;
          if (b10 !== 26)
            break;
        }
        return r7;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i10 = 0; i10 < num.length; i10++) {
          this.words[i10] = this.words[i10] | num.words[i10];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or4(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b10;
        if (this.length > num.length) {
          b10 = num;
        } else {
          b10 = this;
        }
        for (var i10 = 0; i10 < b10.length; i10++) {
          this.words[i10] = this.words[i10] & num.words[i10];
        }
        this.length = b10.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a9;
        var b10;
        if (this.length > num.length) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        for (var i10 = 0; i10 < b10.length; i10++) {
          this.words[i10] = a9.words[i10] ^ b10.words[i10];
        }
        if (this !== a9) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        this.length = a9.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i10 = 0; i10 < bytesNeeded; i10++) {
          this.words[i10] = ~this.words[i10] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r7;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r7 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r7 = this.isub(num);
          num.negative = 1;
          return r7._normSign();
        }
        var a9, b10;
        if (this.length > num.length) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        var carry = 0;
        for (var i10 = 0; i10 < b10.length; i10++) {
          r7 = (a9.words[i10] | 0) + (b10.words[i10] | 0) + carry;
          this.words[i10] = r7 & 67108863;
          carry = r7 >>> 26;
        }
        for (; carry !== 0 && i10 < a9.length; i10++) {
          r7 = (a9.words[i10] | 0) + carry;
          this.words[i10] = r7 & 67108863;
          carry = r7 >>> 26;
        }
        this.length = a9.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a9 !== this) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r7 = this.iadd(num);
          num.negative = 1;
          return r7._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a9, b10;
        if (cmp > 0) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        var carry = 0;
        for (var i10 = 0; i10 < b10.length; i10++) {
          r7 = (a9.words[i10] | 0) - (b10.words[i10] | 0) + carry;
          carry = r7 >> 26;
          this.words[i10] = r7 & 67108863;
        }
        for (; carry !== 0 && i10 < a9.length; i10++) {
          r7 = (a9.words[i10] | 0) + carry;
          carry = r7 >> 26;
          this.words[i10] = r7 & 67108863;
        }
        if (carry === 0 && i10 < a9.length && a9 !== this) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        this.length = Math.max(this.length, i10);
        if (a9 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a9 = self2.words[0] | 0;
        var b10 = num.words[0] | 0;
        var r7 = a9 * b10;
        var lo2 = r7 & 67108863;
        var carry = r7 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i10 = k8 - j8 | 0;
            a9 = self2.words[i10] | 0;
            b10 = num.words[j8] | 0;
            r7 = a9 * b10 + rword;
            ncarry += r7 / 67108864 | 0;
            rword = r7 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a9 = self2.words;
        var b10 = num.words;
        var o11 = out.words;
        var c8 = 0;
        var lo2;
        var mid;
        var hi;
        var a0 = a9[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a9[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a9[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a9[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a9[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a9[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a62 = a9[6] | 0;
        var al6 = a62 & 8191;
        var ah6 = a62 >>> 13;
        var a72 = a9[7] | 0;
        var al7 = a72 & 8191;
        var ah7 = a72 >>> 13;
        var a82 = a9[8] | 0;
        var al8 = a82 & 8191;
        var ah8 = a82 >>> 13;
        var a92 = a9[9] | 0;
        var al9 = a92 & 8191;
        var ah9 = a92 >>> 13;
        var b0 = b10[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b10[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b10[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b10[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b10[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b10[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b10[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b10[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b82 = b10[8] | 0;
        var bl8 = b82 & 8191;
        var bh8 = b82 >>> 13;
        var b92 = b10[9] | 0;
        var bl9 = b92 & 8191;
        var bh9 = b92 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w62 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w72 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w82 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
        w82 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w92 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
        w92 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w102 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w102 >>> 26) | 0;
        w102 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o11[0] = w0;
        o11[1] = w1;
        o11[2] = w22;
        o11[3] = w32;
        o11[4] = w42;
        o11[5] = w52;
        o11[6] = w62;
        o11[7] = w72;
        o11[8] = w82;
        o11[9] = w92;
        o11[10] = w102;
        o11[11] = w11;
        o11[12] = w12;
        o11[13] = w13;
        o11[14] = w14;
        o11[15] = w15;
        o11[16] = w16;
        o11[17] = w17;
        o11[18] = w18;
        if (c8 !== 0) {
          o11[19] = c8;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i10 = k8 - j8;
            var a9 = self2.words[i10] | 0;
            var b10 = num.words[j8] | 0;
            var r7 = a9 * b10;
            var lo2 = r7 & 67108863;
            ncarry = ncarry + (r7 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x8, y10) {
        this.x = x8;
        this.y = y10;
      }
      FFTM.prototype.makeRBT = function makeRBT(N16) {
        var t8 = new Array(N16);
        var l9 = BN.prototype._countBits(N16) - 1;
        for (var i10 = 0; i10 < N16; i10++) {
          t8[i10] = this.revBin(i10, l9, N16);
        }
        return t8;
      };
      FFTM.prototype.revBin = function revBin(x8, l9, N16) {
        if (x8 === 0 || x8 === N16 - 1)
          return x8;
        var rb = 0;
        for (var i10 = 0; i10 < l9; i10++) {
          rb |= (x8 & 1) << l9 - i10 - 1;
          x8 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N16) {
        for (var i10 = 0; i10 < N16; i10++) {
          rtws[i10] = rws[rbt[i10]];
          itws[i10] = iws[rbt[i10]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N16, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N16);
        for (var s11 = 1; s11 < N16; s11 <<= 1) {
          var l9 = s11 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l9);
          var itwdf = Math.sin(2 * Math.PI / l9);
          for (var p10 = 0; p10 < N16; p10 += l9) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s11; j8++) {
              var re6 = rtws[p10 + j8];
              var ie5 = itws[p10 + j8];
              var ro2 = rtws[p10 + j8 + s11];
              var io2 = itws[p10 + j8 + s11];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p10 + j8] = re6 + ro2;
              itws[p10 + j8] = ie5 + io2;
              rtws[p10 + j8 + s11] = re6 - ro2;
              itws[p10 + j8 + s11] = ie5 - io2;
              if (j8 !== l9) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n8, m11) {
        var N16 = Math.max(m11, n8) | 1;
        var odd = N16 & 1;
        var i10 = 0;
        for (N16 = N16 / 2 | 0; N16; N16 = N16 >>> 1) {
          i10++;
        }
        return 1 << i10 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N16) {
        if (N16 <= 1)
          return;
        for (var i10 = 0; i10 < N16 / 2; i10++) {
          var t8 = rws[i10];
          rws[i10] = rws[N16 - i10 - 1];
          rws[N16 - i10 - 1] = t8;
          t8 = iws[i10];
          iws[i10] = -iws[N16 - i10 - 1];
          iws[N16 - i10 - 1] = -t8;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N16) {
        var carry = 0;
        for (var i10 = 0; i10 < N16 / 2; i10++) {
          var w11 = Math.round(ws2[2 * i10 + 1] / N16) * 8192 + Math.round(ws2[2 * i10] / N16) + carry;
          ws2[i10] = w11 & 67108863;
          if (w11 < 67108864) {
            carry = 0;
          } else {
            carry = w11 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N16) {
        var carry = 0;
        for (var i10 = 0; i10 < len; i10++) {
          carry = carry + (ws2[i10] | 0);
          rws[2 * i10] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i10 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i10 = 2 * len; i10 < N16; ++i10) {
          rws[i10] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N16) {
        var ph = new Array(N16);
        for (var i10 = 0; i10 < N16; i10++) {
          ph[i10] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x8, y10, out) {
        var N16 = 2 * this.guessLen13b(x8.length, y10.length);
        var rbt = this.makeRBT(N16);
        var _8 = this.stub(N16);
        var rws = new Array(N16);
        var rwst = new Array(N16);
        var iwst = new Array(N16);
        var nrws = new Array(N16);
        var nrwst = new Array(N16);
        var niwst = new Array(N16);
        var rmws = out.words;
        rmws.length = N16;
        this.convert13b(x8.words, x8.length, rws, N16);
        this.convert13b(y10.words, y10.length, nrws, N16);
        this.transform(rws, _8, rwst, iwst, N16, rbt);
        this.transform(nrws, _8, nrwst, niwst, N16, rbt);
        for (var i10 = 0; i10 < N16; i10++) {
          var rx = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
          iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
          rwst[i10] = rx;
        }
        this.conjugate(rwst, iwst, N16);
        this.transform(rwst, iwst, rmws, _8, N16, rbt);
        this.conjugate(rmws, _8, N16);
        this.normalize13b(rmws, N16);
        out.negative = x8.negative ^ y10.negative;
        out.length = x8.length + y10.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i10 = 0; i10 < this.length; i10++) {
          var w11 = (this.words[i10] | 0) * num;
          var lo2 = (w11 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w11 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i10] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i10] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w11 = toBitArray(num);
        if (w11.length === 0)
          return new BN(1);
        var res = this;
        for (var i10 = 0; i10 < w11.length; i10++, res = res.sqr()) {
          if (w11[i10] !== 0)
            break;
        }
        if (++i10 < w11.length) {
          for (var q8 = res.sqr(); i10 < w11.length; i10++, q8 = q8.sqr()) {
            if (w11[i10] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r7 = bits % 26;
        var s11 = (bits - r7) / 26;
        var carryMask = 67108863 >>> 26 - r7 << 26 - r7;
        var i10;
        if (r7 !== 0) {
          var carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            var newCarry = this.words[i10] & carryMask;
            var c8 = (this.words[i10] | 0) - newCarry << r7;
            this.words[i10] = c8 | carry;
            carry = newCarry >>> 26 - r7;
          }
          if (carry) {
            this.words[i10] = carry;
            this.length++;
          }
        }
        if (s11 !== 0) {
          for (i10 = this.length - 1; i10 >= 0; i10--) {
            this.words[i10 + s11] = this.words[i10];
          }
          for (i10 = 0; i10 < s11; i10++) {
            this.words[i10] = 0;
          }
          this.length += s11;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h11;
        if (hint) {
          h11 = (hint - hint % 26) / 26;
        } else {
          h11 = 0;
        }
        var r7 = bits % 26;
        var s11 = Math.min((bits - r7) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r7 << r7;
        var maskedWords = extended;
        h11 -= s11;
        h11 = Math.max(0, h11);
        if (maskedWords) {
          for (var i10 = 0; i10 < s11; i10++) {
            maskedWords.words[i10] = this.words[i10];
          }
          maskedWords.length = s11;
        }
        if (s11 === 0) {
        } else if (this.length > s11) {
          this.length -= s11;
          for (i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = this.words[i10 + s11];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h11); i10--) {
          var word = this.words[i10] | 0;
          this.words[i10] = carry << 26 - r7 | word >>> r7;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r7 = bit % 26;
        var s11 = (bit - r7) / 26;
        var q8 = 1 << r7;
        if (this.length <= s11)
          return false;
        var w11 = this.words[s11];
        return !!(w11 & q8);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r7 = bits % 26;
        var s11 = (bits - r7) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s11) {
          return this;
        }
        if (r7 !== 0) {
          s11++;
        }
        this.length = Math.min(s11, this.length);
        if (r7 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r7 << r7;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
          this.words[i10] -= 67108864;
          if (i10 === this.length - 1) {
            this.words[i10 + 1] = 1;
          } else {
            this.words[i10 + 1]++;
          }
        }
        this.length = Math.max(this.length, i10 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
            this.words[i10] += 67108864;
            this.words[i10 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i10;
        this._expand(len);
        var w11;
        var carry = 0;
        for (i10 = 0; i10 < num.length; i10++) {
          w11 = (this.words[i10 + shift] | 0) + carry;
          var right = (num.words[i10] | 0) * mul;
          w11 -= right & 67108863;
          carry = (w11 >> 26) - (right / 67108864 | 0);
          this.words[i10 + shift] = w11 & 67108863;
        }
        for (; i10 < this.length - shift; i10++) {
          w11 = (this.words[i10 + shift] | 0) + carry;
          carry = w11 >> 26;
          this.words[i10 + shift] = w11 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i10 = 0; i10 < this.length; i10++) {
          w11 = -(this.words[i10] | 0) + carry;
          carry = w11 >> 26;
          this.words[i10] = w11 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a9 = this.clone();
        var b10 = num;
        var bhi = b10.words[b10.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b10 = b10.ushln(shift);
          a9.iushln(shift);
          bhi = b10.words[b10.length - 1] | 0;
        }
        var m11 = a9.length - b10.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN(null);
          q8.length = m11 + 1;
          q8.words = new Array(q8.length);
          for (var i10 = 0; i10 < q8.length; i10++) {
            q8.words[i10] = 0;
          }
        }
        var diff = a9.clone()._ishlnsubmul(b10, 1, m11);
        if (diff.negative === 0) {
          a9 = diff;
          if (q8) {
            q8.words[m11] = 1;
          }
        }
        for (var j8 = m11 - 1; j8 >= 0; j8--) {
          var qj = (a9.words[b10.length + j8] | 0) * 67108864 + (a9.words[b10.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a9._ishlnsubmul(b10, qj, j8);
          while (a9.negative !== 0) {
            qj--;
            a9.negative = 0;
            a9._ishlnsubmul(b10, 1, j8);
            if (!a9.isZero()) {
              a9.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8._strip();
        }
        a9._strip();
        if (mode !== "div" && shift !== 0) {
          a9.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a9
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p10 = (1 << 26) % num;
        var acc = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          acc = (p10 * acc + (this.words[i10] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          var w11 = (this.words[i10] | 0) + carry * 67108864;
          this.words[i10] = w11 / num | 0;
          carry = w11 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p10) {
        assert3(p10.negative === 0);
        assert3(!p10.isZero());
        var x8 = this;
        var y10 = p10.clone();
        if (x8.negative !== 0) {
          x8 = x8.umod(p10);
        } else {
          x8 = x8.clone();
        }
        var A10 = new BN(1);
        var B9 = new BN(0);
        var C10 = new BN(0);
        var D7 = new BN(1);
        var g9 = 0;
        while (x8.isEven() && y10.isEven()) {
          x8.iushrn(1);
          y10.iushrn(1);
          ++g9;
        }
        var yp = y10.clone();
        var xp = x8.clone();
        while (!x8.isZero()) {
          for (var i10 = 0, im = 1; (x8.words[0] & im) === 0 && i10 < 26; ++i10, im <<= 1)
            ;
          if (i10 > 0) {
            x8.iushrn(i10);
            while (i10-- > 0) {
              if (A10.isOdd() || B9.isOdd()) {
                A10.iadd(yp);
                B9.isub(xp);
              }
              A10.iushrn(1);
              B9.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y10.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y10.iushrn(j8);
            while (j8-- > 0) {
              if (C10.isOdd() || D7.isOdd()) {
                C10.iadd(yp);
                D7.isub(xp);
              }
              C10.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x8.cmp(y10) >= 0) {
            x8.isub(y10);
            A10.isub(C10);
            B9.isub(D7);
          } else {
            y10.isub(x8);
            C10.isub(A10);
            D7.isub(B9);
          }
        }
        return {
          a: C10,
          b: D7,
          gcd: y10.iushln(g9)
        };
      };
      BN.prototype._invmp = function _invmp(p10) {
        assert3(p10.negative === 0);
        assert3(!p10.isZero());
        var a9 = this;
        var b10 = p10.clone();
        if (a9.negative !== 0) {
          a9 = a9.umod(p10);
        } else {
          a9 = a9.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b10.clone();
        while (a9.cmpn(1) > 0 && b10.cmpn(1) > 0) {
          for (var i10 = 0, im = 1; (a9.words[0] & im) === 0 && i10 < 26; ++i10, im <<= 1)
            ;
          if (i10 > 0) {
            a9.iushrn(i10);
            while (i10-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b10.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b10.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a9.cmp(b10) >= 0) {
            a9.isub(b10);
            x1.isub(x22);
          } else {
            b10.isub(a9);
            x22.isub(x1);
          }
        }
        var res;
        if (a9.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p10);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a9 = this.clone();
        var b10 = num.clone();
        a9.negative = 0;
        b10.negative = 0;
        for (var shift = 0; a9.isEven() && b10.isEven(); shift++) {
          a9.iushrn(1);
          b10.iushrn(1);
        }
        do {
          while (a9.isEven()) {
            a9.iushrn(1);
          }
          while (b10.isEven()) {
            b10.iushrn(1);
          }
          var r7 = a9.cmp(b10);
          if (r7 < 0) {
            var t8 = a9;
            a9 = b10;
            b10 = t8;
          } else if (r7 === 0 || b10.cmpn(1) === 0) {
            break;
          }
          a9.isub(b10);
        } while (true);
        return b10.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r7 = bit % 26;
        var s11 = (bit - r7) / 26;
        var q8 = 1 << r7;
        if (this.length <= s11) {
          this._expand(s11 + 1);
          this.words[s11] |= q8;
          return this;
        }
        var carry = q8;
        for (var i10 = s11; carry !== 0 && i10 < this.length; i10++) {
          var w11 = this.words[i10] | 0;
          w11 += carry;
          carry = w11 >>> 26;
          w11 &= 67108863;
          this.words[i10] = w11;
        }
        if (carry !== 0) {
          this.words[i10] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w11 = this.words[0] | 0;
          res = w11 === num ? 0 : w11 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          var a9 = this.words[i10] | 0;
          var b10 = num.words[i10] | 0;
          if (a9 === b10)
            continue;
          if (a9 < b10) {
            res = -1;
          } else if (a9 > b10) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt4(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt4(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p10) {
        this.name = name2;
        this.p = new BN(p10, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r7 = num;
        var rlen;
        do {
          this.split(r7, this.tmp);
          r7 = this.imulK(r7);
          r7 = r7.iadd(this.tmp);
          rlen = r7.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r7.ucmp(this.p);
        if (cmp === 0) {
          r7.words[0] = 0;
          r7.length = 1;
        } else if (cmp > 0) {
          r7.isub(this.p);
        } else {
          if (r7.strip !== void 0) {
            r7.strip();
          } else {
            r7._strip();
          }
        }
        return r7;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i10 = 0; i10 < outLen; i10++) {
          output.words[i10] = input.words[i10];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i10 = 10; i10 < input.length; i10++) {
          var next = input.words[i10] | 0;
          input.words[i10 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i10 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i10 = 0; i10 < num.length; i10++) {
          var w11 = num.words[i10] | 0;
          lo2 += w11 * 977;
          num.words[i10] = lo2 & 67108863;
          lo2 = w11 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i10 = 0; i10 < num.length; i10++) {
          var hi = (num.words[i10] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i10] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m11) {
        if (typeof m11 === "string") {
          var prime = BN._prime(m11);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m11.gtn(1), "modulus must be greater than 1");
          this.m = m11;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a9) {
        assert3(a9.negative === 0, "red works only with positives");
        assert3(a9.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a9, b10) {
        assert3((a9.negative | b10.negative) === 0, "red works only with positives");
        assert3(
          a9.red && a9.red === b10.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a9) {
        if (this.prime)
          return this.prime.ireduce(a9)._forceRed(this);
        move(a9, a9.umod(this.m)._forceRed(this));
        return a9;
      };
      Red.prototype.neg = function neg(a9) {
        if (a9.isZero()) {
          return a9.clone();
        }
        return this.m.sub(a9)._forceRed(this);
      };
      Red.prototype.add = function add(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.add(b10);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.iadd(b10);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.sub(b10);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.isub(b10);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a9, num) {
        this._verify1(a9);
        return this.imod(a9.ushln(num));
      };
      Red.prototype.imul = function imul(a9, b10) {
        this._verify2(a9, b10);
        return this.imod(a9.imul(b10));
      };
      Red.prototype.mul = function mul(a9, b10) {
        this._verify2(a9, b10);
        return this.imod(a9.mul(b10));
      };
      Red.prototype.isqr = function isqr(a9) {
        return this.imul(a9, a9.clone());
      };
      Red.prototype.sqr = function sqr(a9) {
        return this.mul(a9, a9);
      };
      Red.prototype.sqrt = function sqrt(a9) {
        if (a9.isZero())
          return a9.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a9, pow);
        }
        var q8 = this.m.subn(1);
        var s11 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s11++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z8 = this.m.bitLength();
        z8 = new BN(2 * z8 * z8).toRed(this);
        while (this.pow(z8, lpow).cmp(nOne) !== 0) {
          z8.redIAdd(nOne);
        }
        var c8 = this.pow(z8, q8);
        var r7 = this.pow(a9, q8.addn(1).iushrn(1));
        var t8 = this.pow(a9, q8);
        var m11 = s11;
        while (t8.cmp(one) !== 0) {
          var tmp = t8;
          for (var i10 = 0; tmp.cmp(one) !== 0; i10++) {
            tmp = tmp.redSqr();
          }
          assert3(i10 < m11);
          var b10 = this.pow(c8, new BN(1).iushln(m11 - i10 - 1));
          r7 = r7.redMul(b10);
          c8 = b10.redSqr();
          t8 = t8.redMul(c8);
          m11 = i10;
        }
        return r7;
      };
      Red.prototype.invm = function invm(a9) {
        var inv = a9._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a9, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a9.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a9;
        for (var i10 = 2; i10 < wnd.length; i10++) {
          wnd[i10] = this.mul(wnd[i10 - 1], a9);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i10 = num.length - 1; i10 >= 0; i10--) {
          var word = num.words[i10];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i10 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r7 = num.umod(this.m);
        return r7 === num ? r7.clone() : r7;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m11) {
        Red.call(this, m11);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r7 = this.imod(num.mul(this.rinv));
        r7.red = null;
        return r7;
      };
      Mont.prototype.imul = function imul(a9, b10) {
        if (a9.isZero() || b10.isZero()) {
          a9.words[0] = 0;
          a9.length = 1;
          return a9;
        }
        var t8 = a9.imul(b10);
        var c8 = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u9 = t8.isub(c8).iushrn(this.shift);
        var res = u9;
        if (u9.cmp(this.m) >= 0) {
          res = u9.isub(this.m);
        } else if (u9.cmpn(0) < 0) {
          res = u9.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a9, b10) {
        if (a9.isZero() || b10.isZero())
          return new BN(0)._forceRed(this);
        var t8 = a9.mul(b10);
        var c8 = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u9 = t8.isub(c8).iushrn(this.shift);
        var res = u9;
        if (u9.cmp(this.m) >= 0) {
          res = u9.isub(this.m);
        } else if (u9.cmpn(0) < 0) {
          res = u9.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a9) {
        var res = this.imod(a9._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@ethersproject/logger/lib/_version.js
var require_version = __commonJS({
  "node_modules/@ethersproject/logger/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "logger/5.7.0";
  }
});

// node_modules/@ethersproject/logger/lib/index.js
var require_lib = __commonJS({
  "node_modules/@ethersproject/logger/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
    var _permanentCensorErrors = false;
    var _censorErrors = false;
    var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    var _logLevel = LogLevels["default"];
    var _version_1 = require_version();
    var _globalLogger = null;
    function _checkNormalize() {
      try {
        var missing_1 = [];
        ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
          try {
            if ("test".normalize(form) !== "test") {
              throw new Error("bad normalize");
            }
            ;
          } catch (error) {
            missing_1.push(form);
          }
        });
        if (missing_1.length) {
          throw new Error("missing " + missing_1.join(", "));
        }
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
          throw new Error("broken implementation");
        }
      } catch (error) {
        return error.message;
      }
      return null;
    }
    var _normalizeError = _checkNormalize();
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
    var HEX = "0123456789abcdef";
    var Logger21 = (
      /** @class */
      function() {
        function Logger22(version6) {
          Object.defineProperty(this, "version", {
            enumerable: true,
            value: version6,
            writable: false
          });
        }
        Logger22.prototype._log = function(logLevel, args) {
          var level = logLevel.toLowerCase();
          if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
          }
          if (_logLevel > LogLevels[level]) {
            return;
          }
          console.log.apply(console, args);
        };
        Logger22.prototype.debug = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          this._log(Logger22.levels.DEBUG, args);
        };
        Logger22.prototype.info = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          this._log(Logger22.levels.INFO, args);
        };
        Logger22.prototype.warn = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          this._log(Logger22.levels.WARNING, args);
        };
        Logger22.prototype.makeError = function(message, code2, params) {
          if (_censorErrors) {
            return this.makeError("censored error", code2, {});
          }
          if (!code2) {
            code2 = Logger22.errors.UNKNOWN_ERROR;
          }
          if (!params) {
            params = {};
          }
          var messageDetails = [];
          Object.keys(params).forEach(function(key) {
            var value = params[key];
            try {
              if (value instanceof Uint8Array) {
                var hex = "";
                for (var i10 = 0; i10 < value.length; i10++) {
                  hex += HEX[value[i10] >> 4];
                  hex += HEX[value[i10] & 15];
                }
                messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
              } else {
                messageDetails.push(key + "=" + JSON.stringify(value));
              }
            } catch (error2) {
              messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
          });
          messageDetails.push("code=" + code2);
          messageDetails.push("version=" + this.version);
          var reason = message;
          var url = "";
          switch (code2) {
            case ErrorCode.NUMERIC_FAULT: {
              url = "NUMERIC_FAULT";
              var fault = message;
              switch (fault) {
                case "overflow":
                case "underflow":
                case "division-by-zero":
                  url += "-" + fault;
                  break;
                case "negative-power":
                case "negative-width":
                  url += "-unsupported";
                  break;
                case "unbound-bitwise-result":
                  url += "-unbound-result";
                  break;
              }
              break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
              url = code2;
              break;
          }
          if (url) {
            message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
          }
          if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
          }
          var error = new Error(message);
          error.reason = reason;
          error.code = code2;
          Object.keys(params).forEach(function(key) {
            error[key] = params[key];
          });
          return error;
        };
        Logger22.prototype.throwError = function(message, code2, params) {
          throw this.makeError(message, code2, params);
        };
        Logger22.prototype.throwArgumentError = function(message, name2, value) {
          return this.throwError(message, Logger22.errors.INVALID_ARGUMENT, {
            argument: name2,
            value
          });
        };
        Logger22.prototype.assert = function(condition, message, code2, params) {
          if (!!condition) {
            return;
          }
          this.throwError(message, code2, params);
        };
        Logger22.prototype.assertArgument = function(condition, message, name2, value) {
          if (!!condition) {
            return;
          }
          this.throwArgumentError(message, name2, value);
        };
        Logger22.prototype.checkNormalize = function(message) {
          if (message == null) {
            message = "platform missing String.prototype.normalize";
          }
          if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger22.errors.UNSUPPORTED_OPERATION, {
              operation: "String.prototype.normalize",
              form: _normalizeError
            });
          }
        };
        Logger22.prototype.checkSafeUint53 = function(value, message) {
          if (typeof value !== "number") {
            return;
          }
          if (message == null) {
            message = "value not safe";
          }
          if (value < 0 || value >= 9007199254740991) {
            this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
              operation: "checkSafeInteger",
              fault: "out-of-safe-range",
              value
            });
          }
          if (value % 1) {
            this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
              operation: "checkSafeInteger",
              fault: "non-integer",
              value
            });
          }
        };
        Logger22.prototype.checkArgumentCount = function(count, expectedCount, message) {
          if (message) {
            message = ": " + message;
          } else {
            message = "";
          }
          if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger22.errors.MISSING_ARGUMENT, {
              count,
              expectedCount
            });
          }
          if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger22.errors.UNEXPECTED_ARGUMENT, {
              count,
              expectedCount
            });
          }
        };
        Logger22.prototype.checkNew = function(target, kind) {
          if (target === Object || target == null) {
            this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
          }
        };
        Logger22.prototype.checkAbstract = function(target, kind) {
          if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger22.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
          } else if (target === Object || target == null) {
            this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
          }
        };
        Logger22.globalLogger = function() {
          if (!_globalLogger) {
            _globalLogger = new Logger22(_version_1.version);
          }
          return _globalLogger;
        };
        Logger22.setCensorship = function(censorship, permanent) {
          if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger22.errors.UNSUPPORTED_OPERATION, {
              operation: "setCensorship"
            });
          }
          if (_permanentCensorErrors) {
            if (!censorship) {
              return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger22.errors.UNSUPPORTED_OPERATION, {
              operation: "setCensorship"
            });
          }
          _censorErrors = !!censorship;
          _permanentCensorErrors = !!permanent;
        };
        Logger22.setLogLevel = function(logLevel) {
          var level = LogLevels[logLevel.toLowerCase()];
          if (level == null) {
            Logger22.globalLogger().warn("invalid log level - " + logLevel);
            return;
          }
          _logLevel = level;
        };
        Logger22.from = function(version6) {
          return new Logger22(version6);
        };
        Logger22.errors = ErrorCode;
        Logger22.levels = LogLevel;
        return Logger22;
      }()
    );
    exports.Logger = Logger21;
  }
});

// node_modules/@ethersproject/bytes/lib/_version.js
var require_version2 = __commonJS({
  "node_modules/@ethersproject/bytes/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bytes/5.7.0";
  }
});

// node_modules/@ethersproject/bytes/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@ethersproject/bytes/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version2();
    var logger19 = new logger_1.Logger(_version_1.version);
    function isHexable(value) {
      return !!value.toHexString;
    }
    function addSlice(array) {
      if (array.slice) {
        return array;
      }
      array.slice = function() {
        var args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
    function isBytesLike2(value) {
      return isHexString10(value) && !(value.length % 2) || isBytes3(value);
    }
    exports.isBytesLike = isBytesLike2;
    function isInteger(value) {
      return typeof value === "number" && value == value && value % 1 === 0;
    }
    function isBytes3(value) {
      if (value == null) {
        return false;
      }
      if (value.constructor === Uint8Array) {
        return true;
      }
      if (typeof value === "string") {
        return false;
      }
      if (!isInteger(value.length) || value.length < 0) {
        return false;
      }
      for (var i10 = 0; i10 < value.length; i10++) {
        var v7 = value[i10];
        if (!isInteger(v7) || v7 < 0 || v7 >= 256) {
          return false;
        }
      }
      return true;
    }
    exports.isBytes = isBytes3;
    function arrayify4(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger19.checkSafeUint53(value, "invalid arrayify value");
        var result = [];
        while (value) {
          result.unshift(value & 255);
          value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
          result.push(0);
        }
        return addSlice(new Uint8Array(result));
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        value = value.toHexString();
      }
      if (isHexString10(value)) {
        var hex = value.substring(2);
        if (hex.length % 2) {
          if (options.hexPad === "left") {
            hex = "0" + hex;
          } else if (options.hexPad === "right") {
            hex += "0";
          } else {
            logger19.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        var result = [];
        for (var i10 = 0; i10 < hex.length; i10 += 2) {
          result.push(parseInt(hex.substring(i10, i10 + 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isBytes3(value)) {
        return addSlice(new Uint8Array(value));
      }
      return logger19.throwArgumentError("invalid arrayify value", "value", value);
    }
    exports.arrayify = arrayify4;
    function concat5(items) {
      var objects = items.map(function(item) {
        return arrayify4(item);
      });
      var length2 = objects.reduce(function(accum, item) {
        return accum + item.length;
      }, 0);
      var result = new Uint8Array(length2);
      objects.reduce(function(offset, object) {
        result.set(object, offset);
        return offset + object.length;
      }, 0);
      return addSlice(result);
    }
    exports.concat = concat5;
    function stripZeros2(value) {
      var result = arrayify4(value);
      if (result.length === 0) {
        return result;
      }
      var start = 0;
      while (start < result.length && result[start] === 0) {
        start++;
      }
      if (start) {
        result = result.slice(start);
      }
      return result;
    }
    exports.stripZeros = stripZeros2;
    function zeroPad2(value, length2) {
      value = arrayify4(value);
      if (value.length > length2) {
        logger19.throwArgumentError("value out of range", "value", arguments[0]);
      }
      var result = new Uint8Array(length2);
      result.set(value, length2 - value.length);
      return addSlice(result);
    }
    exports.zeroPad = zeroPad2;
    function isHexString10(value, length2) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length2 && value.length !== 2 + 2 * length2) {
        return false;
      }
      return true;
    }
    exports.isHexString = isHexString10;
    var HexCharacters = "0123456789abcdef";
    function hexlify6(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger19.checkSafeUint53(value, "invalid hexlify value");
        var hex = "";
        while (value) {
          hex = HexCharacters[value & 15] + hex;
          value = Math.floor(value / 16);
        }
        if (hex.length) {
          if (hex.length % 2) {
            hex = "0" + hex;
          }
          return "0x" + hex;
        }
        return "0x00";
      }
      if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
          return "0x0" + value;
        }
        return "0x" + value;
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        return value.toHexString();
      }
      if (isHexString10(value)) {
        if (value.length % 2) {
          if (options.hexPad === "left") {
            value = "0x0" + value.substring(2);
          } else if (options.hexPad === "right") {
            value += "0";
          } else {
            logger19.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        return value.toLowerCase();
      }
      if (isBytes3(value)) {
        var result = "0x";
        for (var i10 = 0; i10 < value.length; i10++) {
          var v7 = value[i10];
          result += HexCharacters[(v7 & 240) >> 4] + HexCharacters[v7 & 15];
        }
        return result;
      }
      return logger19.throwArgumentError("invalid hexlify value", "value", value);
    }
    exports.hexlify = hexlify6;
    function hexDataLength4(data2) {
      if (typeof data2 !== "string") {
        data2 = hexlify6(data2);
      } else if (!isHexString10(data2) || data2.length % 2) {
        return null;
      }
      return (data2.length - 2) / 2;
    }
    exports.hexDataLength = hexDataLength4;
    function hexDataSlice4(data2, offset, endOffset) {
      if (typeof data2 !== "string") {
        data2 = hexlify6(data2);
      } else if (!isHexString10(data2) || data2.length % 2) {
        logger19.throwArgumentError("invalid hexData", "value", data2);
      }
      offset = 2 + 2 * offset;
      if (endOffset != null) {
        return "0x" + data2.substring(offset, 2 + 2 * endOffset);
      }
      return "0x" + data2.substring(offset);
    }
    exports.hexDataSlice = hexDataSlice4;
    function hexConcat3(items) {
      var result = "0x";
      items.forEach(function(item) {
        result += hexlify6(item).substring(2);
      });
      return result;
    }
    exports.hexConcat = hexConcat3;
    function hexValue9(value) {
      var trimmed = hexStripZeros2(hexlify6(value, { hexPad: "left" }));
      if (trimmed === "0x") {
        return "0x0";
      }
      return trimmed;
    }
    exports.hexValue = hexValue9;
    function hexStripZeros2(value) {
      if (typeof value !== "string") {
        value = hexlify6(value);
      }
      if (!isHexString10(value)) {
        logger19.throwArgumentError("invalid hex string", "value", value);
      }
      value = value.substring(2);
      var offset = 0;
      while (offset < value.length && value[offset] === "0") {
        offset++;
      }
      return "0x" + value.substring(offset);
    }
    exports.hexStripZeros = hexStripZeros2;
    function hexZeroPad5(value, length2) {
      if (typeof value !== "string") {
        value = hexlify6(value);
      } else if (!isHexString10(value)) {
        logger19.throwArgumentError("invalid hex string", "value", value);
      }
      if (value.length > 2 * length2 + 2) {
        logger19.throwArgumentError("value out of range", "value", arguments[1]);
      }
      while (value.length < 2 * length2 + 2) {
        value = "0x0" + value.substring(2);
      }
      return value;
    }
    exports.hexZeroPad = hexZeroPad5;
    function splitSignature2(signature) {
      var result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
      };
      if (isBytesLike2(signature)) {
        var bytes = arrayify4(signature);
        if (bytes.length === 64) {
          result.v = 27 + (bytes[32] >> 7);
          bytes[32] &= 127;
          result.r = hexlify6(bytes.slice(0, 32));
          result.s = hexlify6(bytes.slice(32, 64));
        } else if (bytes.length === 65) {
          result.r = hexlify6(bytes.slice(0, 32));
          result.s = hexlify6(bytes.slice(32, 64));
          result.v = bytes[64];
        } else {
          logger19.throwArgumentError("invalid signature string", "signature", signature);
        }
        if (result.v < 27) {
          if (result.v === 0 || result.v === 1) {
            result.v += 27;
          } else {
            logger19.throwArgumentError("signature invalid v byte", "signature", signature);
          }
        }
        result.recoveryParam = 1 - result.v % 2;
        if (result.recoveryParam) {
          bytes[32] |= 128;
        }
        result._vs = hexlify6(bytes.slice(32, 64));
      } else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        if (result._vs != null) {
          var vs_1 = zeroPad2(arrayify4(result._vs), 32);
          result._vs = hexlify6(vs_1);
          var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
          if (result.recoveryParam == null) {
            result.recoveryParam = recoveryParam;
          } else if (result.recoveryParam !== recoveryParam) {
            logger19.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
          }
          vs_1[0] &= 127;
          var s11 = hexlify6(vs_1);
          if (result.s == null) {
            result.s = s11;
          } else if (result.s !== s11) {
            logger19.throwArgumentError("signature v mismatch _vs", "signature", signature);
          }
        }
        if (result.recoveryParam == null) {
          if (result.v == null) {
            logger19.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
          } else if (result.v === 0 || result.v === 1) {
            result.recoveryParam = result.v;
          } else {
            result.recoveryParam = 1 - result.v % 2;
          }
        } else {
          if (result.v == null) {
            result.v = 27 + result.recoveryParam;
          } else {
            var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
            if (result.recoveryParam !== recId) {
              logger19.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
            }
          }
        }
        if (result.r == null || !isHexString10(result.r)) {
          logger19.throwArgumentError("signature missing or invalid r", "signature", signature);
        } else {
          result.r = hexZeroPad5(result.r, 32);
        }
        if (result.s == null || !isHexString10(result.s)) {
          logger19.throwArgumentError("signature missing or invalid s", "signature", signature);
        } else {
          result.s = hexZeroPad5(result.s, 32);
        }
        var vs2 = arrayify4(result.s);
        if (vs2[0] >= 128) {
          logger19.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
          vs2[0] |= 128;
        }
        var _vs = hexlify6(vs2);
        if (result._vs) {
          if (!isHexString10(result._vs)) {
            logger19.throwArgumentError("signature invalid _vs", "signature", signature);
          }
          result._vs = hexZeroPad5(result._vs, 32);
        }
        if (result._vs == null) {
          result._vs = _vs;
        } else if (result._vs !== _vs) {
          logger19.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
      }
      result.yParityAndS = result._vs;
      result.compact = result.r + result.yParityAndS.substring(2);
      return result;
    }
    exports.splitSignature = splitSignature2;
    function joinSignature2(signature) {
      signature = splitSignature2(signature);
      return hexlify6(concat5([
        signature.r,
        signature.s,
        signature.recoveryParam ? "0x1c" : "0x1b"
      ]));
    }
    exports.joinSignature = joinSignature2;
  }
});

// node_modules/@ethersproject/bignumber/lib/_version.js
var require_version3 = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bignumber/5.7.0";
  }
});

// node_modules/@ethersproject/bignumber/lib/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/bignumber.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;
    var bn_js_1 = __importDefault2(require_bn());
    var BN = bn_js_1.default.BN;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger19 = new logger_1.Logger(_version_1.version);
    var _constructorGuard2 = {};
    var MAX_SAFE = 9007199254740991;
    function isBigNumberish(value) {
      return value != null && (BigNumber9.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
    }
    exports.isBigNumberish = isBigNumberish;
    var _warnedToStringRadix = false;
    var BigNumber9 = (
      /** @class */
      function() {
        function BigNumber10(constructorGuard, hex) {
          if (constructorGuard !== _constructorGuard2) {
            logger19.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new (BigNumber)"
            });
          }
          this._hex = hex;
          this._isBigNumber = true;
          Object.freeze(this);
        }
        BigNumber10.prototype.fromTwos = function(value) {
          return toBigNumber(toBN(this).fromTwos(value));
        };
        BigNumber10.prototype.toTwos = function(value) {
          return toBigNumber(toBN(this).toTwos(value));
        };
        BigNumber10.prototype.abs = function() {
          if (this._hex[0] === "-") {
            return BigNumber10.from(this._hex.substring(1));
          }
          return this;
        };
        BigNumber10.prototype.add = function(other) {
          return toBigNumber(toBN(this).add(toBN(other)));
        };
        BigNumber10.prototype.sub = function(other) {
          return toBigNumber(toBN(this).sub(toBN(other)));
        };
        BigNumber10.prototype.div = function(other) {
          var o11 = BigNumber10.from(other);
          if (o11.isZero()) {
            throwFault("division-by-zero", "div");
          }
          return toBigNumber(toBN(this).div(toBN(other)));
        };
        BigNumber10.prototype.mul = function(other) {
          return toBigNumber(toBN(this).mul(toBN(other)));
        };
        BigNumber10.prototype.mod = function(other) {
          var value = toBN(other);
          if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
          }
          return toBigNumber(toBN(this).umod(value));
        };
        BigNumber10.prototype.pow = function(other) {
          var value = toBN(other);
          if (value.isNeg()) {
            throwFault("negative-power", "pow");
          }
          return toBigNumber(toBN(this).pow(value));
        };
        BigNumber10.prototype.and = function(other) {
          var value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
          }
          return toBigNumber(toBN(this).and(value));
        };
        BigNumber10.prototype.or = function(other) {
          var value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
          }
          return toBigNumber(toBN(this).or(value));
        };
        BigNumber10.prototype.xor = function(other) {
          var value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
          }
          return toBigNumber(toBN(this).xor(value));
        };
        BigNumber10.prototype.mask = function(value) {
          if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
          }
          return toBigNumber(toBN(this).maskn(value));
        };
        BigNumber10.prototype.shl = function(value) {
          if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
          }
          return toBigNumber(toBN(this).shln(value));
        };
        BigNumber10.prototype.shr = function(value) {
          if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
          }
          return toBigNumber(toBN(this).shrn(value));
        };
        BigNumber10.prototype.eq = function(other) {
          return toBN(this).eq(toBN(other));
        };
        BigNumber10.prototype.lt = function(other) {
          return toBN(this).lt(toBN(other));
        };
        BigNumber10.prototype.lte = function(other) {
          return toBN(this).lte(toBN(other));
        };
        BigNumber10.prototype.gt = function(other) {
          return toBN(this).gt(toBN(other));
        };
        BigNumber10.prototype.gte = function(other) {
          return toBN(this).gte(toBN(other));
        };
        BigNumber10.prototype.isNegative = function() {
          return this._hex[0] === "-";
        };
        BigNumber10.prototype.isZero = function() {
          return toBN(this).isZero();
        };
        BigNumber10.prototype.toNumber = function() {
          try {
            return toBN(this).toNumber();
          } catch (error) {
            throwFault("overflow", "toNumber", this.toString());
          }
          return null;
        };
        BigNumber10.prototype.toBigInt = function() {
          try {
            return BigInt(this.toString());
          } catch (e11) {
          }
          return logger19.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
          });
        };
        BigNumber10.prototype.toString = function() {
          if (arguments.length > 0) {
            if (arguments[0] === 10) {
              if (!_warnedToStringRadix) {
                _warnedToStringRadix = true;
                logger19.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
              }
            } else if (arguments[0] === 16) {
              logger19.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
            } else {
              logger19.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
          }
          return toBN(this).toString(10);
        };
        BigNumber10.prototype.toHexString = function() {
          return this._hex;
        };
        BigNumber10.prototype.toJSON = function(key) {
          return { type: "BigNumber", hex: this.toHexString() };
        };
        BigNumber10.from = function(value) {
          if (value instanceof BigNumber10) {
            return value;
          }
          if (typeof value === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
              return new BigNumber10(_constructorGuard2, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
              return new BigNumber10(_constructorGuard2, toHex(new BN(value)));
            }
            return logger19.throwArgumentError("invalid BigNumber string", "value", value);
          }
          if (typeof value === "number") {
            if (value % 1) {
              throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
              throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber10.from(String(value));
          }
          var anyValue = value;
          if (typeof anyValue === "bigint") {
            return BigNumber10.from(anyValue.toString());
          }
          if ((0, bytes_1.isBytes)(anyValue)) {
            return BigNumber10.from((0, bytes_1.hexlify)(anyValue));
          }
          if (anyValue) {
            if (anyValue.toHexString) {
              var hex = anyValue.toHexString();
              if (typeof hex === "string") {
                return BigNumber10.from(hex);
              }
            } else {
              var hex = anyValue._hex;
              if (hex == null && anyValue.type === "BigNumber") {
                hex = anyValue.hex;
              }
              if (typeof hex === "string") {
                if ((0, bytes_1.isHexString)(hex) || hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1))) {
                  return BigNumber10.from(hex);
                }
              }
            }
          }
          return logger19.throwArgumentError("invalid BigNumber value", "value", value);
        };
        BigNumber10.isBigNumber = function(value) {
          return !!(value && value._isBigNumber);
        };
        return BigNumber10;
      }()
    );
    exports.BigNumber = BigNumber9;
    function toHex(value) {
      if (typeof value !== "string") {
        return toHex(value.toString(16));
      }
      if (value[0] === "-") {
        value = value.substring(1);
        if (value[0] === "-") {
          logger19.throwArgumentError("invalid hex", "value", value);
        }
        value = toHex(value);
        if (value === "0x00") {
          return value;
        }
        return "-" + value;
      }
      if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (value === "0x") {
        return "0x00";
      }
      if (value.length % 2) {
        value = "0x0" + value.substring(2);
      }
      while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
      }
      return value;
    }
    function toBigNumber(value) {
      return BigNumber9.from(toHex(value));
    }
    function toBN(value) {
      var hex = BigNumber9.from(value).toHexString();
      if (hex[0] === "-") {
        return new BN("-" + hex.substring(3), 16);
      }
      return new BN(hex.substring(2), 16);
    }
    function throwFault(fault, operation, value) {
      var params = { fault, operation };
      if (value != null) {
        params.value = value;
      }
      return logger19.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    function _base36To16(value) {
      return new BN(value, 36).toString(16);
    }
    exports._base36To16 = _base36To16;
    function _base16To36(value) {
      return new BN(value, 16).toString(36);
    }
    exports._base16To36 = _base16To36;
  }
});

// node_modules/@ethersproject/bignumber/lib/fixednumber.js
var require_fixednumber = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/fixednumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger19 = new logger_1.Logger(_version_1.version);
    var bignumber_1 = require_bignumber();
    var _constructorGuard2 = {};
    var Zero = bignumber_1.BigNumber.from(0);
    var NegativeOne = bignumber_1.BigNumber.from(-1);
    function throwFault(message, fault, operation, value) {
      var params = { fault, operation };
      if (value !== void 0) {
        params.value = value;
      }
      return logger19.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    var zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    function getMultiplier(decimals) {
      if (typeof decimals !== "number") {
        try {
          decimals = bignumber_1.BigNumber.from(decimals).toNumber();
        } catch (e11) {
        }
      }
      if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return "1" + zeros.substring(0, decimals);
      }
      return logger19.throwArgumentError("invalid decimal size", "decimals", decimals);
    }
    function formatFixed(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      value = bignumber_1.BigNumber.from(value);
      var negative = value.lt(Zero);
      if (negative) {
        value = value.mul(NegativeOne);
      }
      var fraction = value.mod(multiplier).toString();
      while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
      }
      fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      var whole = value.div(multiplier).toString();
      if (multiplier.length === 1) {
        value = whole;
      } else {
        value = whole + "." + fraction;
      }
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    exports.formatFixed = formatFixed;
    function parseFixed(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger19.throwArgumentError("invalid decimal value", "value", value);
      }
      var negative = value.substring(0, 1) === "-";
      if (negative) {
        value = value.substring(1);
      }
      if (value === ".") {
        logger19.throwArgumentError("missing value", "value", value);
      }
      var comps = value.split(".");
      if (comps.length > 2) {
        logger19.throwArgumentError("too many decimal points", "value", value);
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
      }
      if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
      }
      if (fraction === "") {
        fraction = "0";
      }
      while (fraction.length < multiplier.length - 1) {
        fraction += "0";
      }
      var wholeValue = bignumber_1.BigNumber.from(whole);
      var fractionValue = bignumber_1.BigNumber.from(fraction);
      var wei = wholeValue.mul(multiplier).add(fractionValue);
      if (negative) {
        wei = wei.mul(NegativeOne);
      }
      return wei;
    }
    exports.parseFixed = parseFixed;
    var FixedFormat = (
      /** @class */
      function() {
        function FixedFormat2(constructorGuard, signed, width, decimals) {
          if (constructorGuard !== _constructorGuard2) {
            logger19.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new FixedFormat"
            });
          }
          this.signed = signed;
          this.width = width;
          this.decimals = decimals;
          this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
          this._multiplier = getMultiplier(decimals);
          Object.freeze(this);
        }
        FixedFormat2.from = function(value) {
          if (value instanceof FixedFormat2) {
            return value;
          }
          if (typeof value === "number") {
            value = "fixed128x" + value;
          }
          var signed = true;
          var width = 128;
          var decimals = 18;
          if (typeof value === "string") {
            if (value === "fixed") {
            } else if (value === "ufixed") {
              signed = false;
            } else {
              var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              if (!match) {
                logger19.throwArgumentError("invalid fixed format", "format", value);
              }
              signed = match[1] !== "u";
              width = parseInt(match[2]);
              decimals = parseInt(match[3]);
            }
          } else if (value) {
            var check = function(key, type, defaultValue) {
              if (value[key] == null) {
                return defaultValue;
              }
              if (typeof value[key] !== type) {
                logger19.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
              }
              return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
          }
          if (width % 8) {
            logger19.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
          }
          if (decimals > 80) {
            logger19.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
          }
          return new FixedFormat2(_constructorGuard2, signed, width, decimals);
        };
        return FixedFormat2;
      }()
    );
    exports.FixedFormat = FixedFormat;
    var FixedNumber2 = (
      /** @class */
      function() {
        function FixedNumber3(constructorGuard, hex, value, format) {
          if (constructorGuard !== _constructorGuard2) {
            logger19.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new FixedFormat"
            });
          }
          this.format = format;
          this._hex = hex;
          this._value = value;
          this._isFixedNumber = true;
          Object.freeze(this);
        }
        FixedNumber3.prototype._checkFormat = function(other) {
          if (this.format.name !== other.format.name) {
            logger19.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
          }
        };
        FixedNumber3.prototype.addUnsafe = function(other) {
          this._checkFormat(other);
          var a9 = parseFixed(this._value, this.format.decimals);
          var b10 = parseFixed(other._value, other.format.decimals);
          return FixedNumber3.fromValue(a9.add(b10), this.format.decimals, this.format);
        };
        FixedNumber3.prototype.subUnsafe = function(other) {
          this._checkFormat(other);
          var a9 = parseFixed(this._value, this.format.decimals);
          var b10 = parseFixed(other._value, other.format.decimals);
          return FixedNumber3.fromValue(a9.sub(b10), this.format.decimals, this.format);
        };
        FixedNumber3.prototype.mulUnsafe = function(other) {
          this._checkFormat(other);
          var a9 = parseFixed(this._value, this.format.decimals);
          var b10 = parseFixed(other._value, other.format.decimals);
          return FixedNumber3.fromValue(a9.mul(b10).div(this.format._multiplier), this.format.decimals, this.format);
        };
        FixedNumber3.prototype.divUnsafe = function(other) {
          this._checkFormat(other);
          var a9 = parseFixed(this._value, this.format.decimals);
          var b10 = parseFixed(other._value, other.format.decimals);
          return FixedNumber3.fromValue(a9.mul(this.format._multiplier).div(b10), this.format.decimals, this.format);
        };
        FixedNumber3.prototype.floor = function() {
          var comps = this.toString().split(".");
          if (comps.length === 1) {
            comps.push("0");
          }
          var result = FixedNumber3.from(comps[0], this.format);
          var hasFraction = !comps[1].match(/^(0*)$/);
          if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
          }
          return result;
        };
        FixedNumber3.prototype.ceiling = function() {
          var comps = this.toString().split(".");
          if (comps.length === 1) {
            comps.push("0");
          }
          var result = FixedNumber3.from(comps[0], this.format);
          var hasFraction = !comps[1].match(/^(0*)$/);
          if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
          }
          return result;
        };
        FixedNumber3.prototype.round = function(decimals) {
          if (decimals == null) {
            decimals = 0;
          }
          var comps = this.toString().split(".");
          if (comps.length === 1) {
            comps.push("0");
          }
          if (decimals < 0 || decimals > 80 || decimals % 1) {
            logger19.throwArgumentError("invalid decimal count", "decimals", decimals);
          }
          if (comps[1].length <= decimals) {
            return this;
          }
          var factor = FixedNumber3.from("1" + zeros.substring(0, decimals), this.format);
          var bump = BUMP.toFormat(this.format);
          return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
        };
        FixedNumber3.prototype.isZero = function() {
          return this._value === "0.0" || this._value === "0";
        };
        FixedNumber3.prototype.isNegative = function() {
          return this._value[0] === "-";
        };
        FixedNumber3.prototype.toString = function() {
          return this._value;
        };
        FixedNumber3.prototype.toHexString = function(width) {
          if (width == null) {
            return this._hex;
          }
          if (width % 8) {
            logger19.throwArgumentError("invalid byte width", "width", width);
          }
          var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
          return (0, bytes_1.hexZeroPad)(hex, width / 8);
        };
        FixedNumber3.prototype.toUnsafeFloat = function() {
          return parseFloat(this.toString());
        };
        FixedNumber3.prototype.toFormat = function(format) {
          return FixedNumber3.fromString(this._value, format);
        };
        FixedNumber3.fromValue = function(value, decimals, format) {
          if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
            format = decimals;
            decimals = null;
          }
          if (decimals == null) {
            decimals = 0;
          }
          if (format == null) {
            format = "fixed";
          }
          return FixedNumber3.fromString(formatFixed(value, decimals), FixedFormat.from(format));
        };
        FixedNumber3.fromString = function(value, format) {
          if (format == null) {
            format = "fixed";
          }
          var fixedFormat = FixedFormat.from(format);
          var numeric = parseFixed(value, fixedFormat.decimals);
          if (!fixedFormat.signed && numeric.lt(Zero)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
          }
          var hex = null;
          if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
          } else {
            hex = numeric.toHexString();
            hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
          }
          var decimal = formatFixed(numeric, fixedFormat.decimals);
          return new FixedNumber3(_constructorGuard2, hex, decimal, fixedFormat);
        };
        FixedNumber3.fromBytes = function(value, format) {
          if (format == null) {
            format = "fixed";
          }
          var fixedFormat = FixedFormat.from(format);
          if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
          }
          var numeric = bignumber_1.BigNumber.from(value);
          if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
          }
          var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
          var decimal = formatFixed(numeric, fixedFormat.decimals);
          return new FixedNumber3(_constructorGuard2, hex, decimal, fixedFormat);
        };
        FixedNumber3.from = function(value, format) {
          if (typeof value === "string") {
            return FixedNumber3.fromString(value, format);
          }
          if ((0, bytes_1.isBytes)(value)) {
            return FixedNumber3.fromBytes(value, format);
          }
          try {
            return FixedNumber3.fromValue(value, 0, format);
          } catch (error) {
            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
              throw error;
            }
          }
          return logger19.throwArgumentError("invalid FixedNumber value", "value", value);
        };
        FixedNumber3.isFixedNumber = function(value) {
          return !!(value && value._isFixedNumber);
        };
        return FixedNumber3;
      }()
    );
    exports.FixedNumber = FixedNumber2;
    var ONE = FixedNumber2.from(1);
    var BUMP = FixedNumber2.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;
    var bignumber_1 = require_bignumber();
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return bignumber_1.BigNumber;
    } });
    var fixednumber_1 = require_fixednumber();
    Object.defineProperty(exports, "formatFixed", { enumerable: true, get: function() {
      return fixednumber_1.formatFixed;
    } });
    Object.defineProperty(exports, "FixedFormat", { enumerable: true, get: function() {
      return fixednumber_1.FixedFormat;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return fixednumber_1.FixedNumber;
    } });
    Object.defineProperty(exports, "parseFixed", { enumerable: true, get: function() {
      return fixednumber_1.parseFixed;
    } });
    var bignumber_2 = require_bignumber();
    Object.defineProperty(exports, "_base16To36", { enumerable: true, get: function() {
      return bignumber_2._base16To36;
    } });
    Object.defineProperty(exports, "_base36To16", { enumerable: true, get: function() {
      return bignumber_2._base36To16;
    } });
  }
});

// node_modules/@ethersproject/properties/lib/_version.js
var require_version4 = __commonJS({
  "node_modules/@ethersproject/properties/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "properties/5.7.0";
  }
});

// node_modules/@ethersproject/properties/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@ethersproject/properties/lib/index.js"(exports) {
    "use strict";
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version4();
    var logger19 = new logger_1.Logger(_version_1.version);
    function defineReadOnly12(object, name2, value) {
      Object.defineProperty(object, name2, {
        enumerable: true,
        value,
        writable: false
      });
    }
    exports.defineReadOnly = defineReadOnly12;
    function getStatic6(ctor, key) {
      for (var i10 = 0; i10 < 32; i10++) {
        if (ctor[key]) {
          return ctor[key];
        }
        if (!ctor.prototype || typeof ctor.prototype !== "object") {
          break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
      }
      return null;
    }
    exports.getStatic = getStatic6;
    function resolveProperties5(object) {
      return __awaiter10(this, void 0, void 0, function() {
        var promises, results2;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              promises = Object.keys(object).map(function(key) {
                var value = object[key];
                return Promise.resolve(value).then(function(v7) {
                  return { key, value: v7 };
                });
              });
              return [4, Promise.all(promises)];
            case 1:
              results2 = _a2.sent();
              return [2, results2.reduce(function(accum, result) {
                accum[result.key] = result.value;
                return accum;
              }, {})];
          }
        });
      });
    }
    exports.resolveProperties = resolveProperties5;
    function checkProperties3(object, properties) {
      if (!object || typeof object !== "object") {
        logger19.throwArgumentError("invalid object", "object", object);
      }
      Object.keys(object).forEach(function(key) {
        if (!properties[key]) {
          logger19.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
      });
    }
    exports.checkProperties = checkProperties3;
    function shallowCopy6(object) {
      var result = {};
      for (var key in object) {
        result[key] = object[key];
      }
      return result;
    }
    exports.shallowCopy = shallowCopy6;
    var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    function _isFrozen(object) {
      if (object === void 0 || object === null || opaque[typeof object]) {
        return true;
      }
      if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) {
          return false;
        }
        var keys = Object.keys(object);
        for (var i10 = 0; i10 < keys.length; i10++) {
          var value = null;
          try {
            value = object[keys[i10]];
          } catch (error) {
            continue;
          }
          if (!_isFrozen(value)) {
            return false;
          }
        }
        return true;
      }
      return logger19.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function _deepCopy(object) {
      if (_isFrozen(object)) {
        return object;
      }
      if (Array.isArray(object)) {
        return Object.freeze(object.map(function(item) {
          return deepCopy8(item);
        }));
      }
      if (typeof object === "object") {
        var result = {};
        for (var key in object) {
          var value = object[key];
          if (value === void 0) {
            continue;
          }
          defineReadOnly12(result, key, deepCopy8(value));
        }
        return result;
      }
      return logger19.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function deepCopy8(object) {
      return _deepCopy(object);
    }
    exports.deepCopy = deepCopy8;
    var Description = (
      /** @class */
      function() {
        function Description2(info) {
          for (var key in info) {
            this[key] = deepCopy8(info[key]);
          }
        }
        return Description2;
      }()
    );
    exports.Description = Description;
  }
});

// node_modules/@ethersproject/abi/lib/_version.js
var require_version5 = __commonJS({
  "node_modules/@ethersproject/abi/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abi/5.7.0";
  }
});

// node_modules/@ethersproject/abi/lib/fragments.js
var require_fragments = __commonJS({
  "node_modules/@ethersproject/abi/lib/fragments.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger19 = new logger_1.Logger(_version_1.version);
    var _constructorGuard2 = {};
    var ModifiersBytes = { calldata: true, memory: true, storage: true };
    var ModifiersNest = { calldata: true, memory: true };
    function checkModifier(type, name2) {
      if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name2]) {
          return true;
        }
      } else if (type === "address") {
        if (name2 === "payable") {
          return true;
        }
      } else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name2]) {
          return true;
        }
      }
      if (ModifiersBytes[name2] || name2 === "payable") {
        logger19.throwArgumentError("invalid modifier", "name", name2);
      }
      return false;
    }
    function parseParamType(param, allowIndexed) {
      var originalParam = param;
      function throwError(i11) {
        logger19.throwArgumentError("unexpected character at position " + i11, "param", param);
      }
      param = param.replace(/\s/g, " ");
      function newNode(parent2) {
        var node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
        if (allowIndexed) {
          node2.indexed = false;
        }
        return node2;
      }
      var parent = { type: "", name: "", state: { allowType: true } };
      var node = parent;
      for (var i10 = 0; i10 < param.length; i10++) {
        var c8 = param[i10];
        switch (c8) {
          case "(":
            if (node.state.allowType && node.type === "") {
              node.type = "tuple";
            } else if (!node.state.allowParams) {
              throwError(i10);
            }
            node.state.allowType = false;
            node.type = verifyType(node.type);
            node.components = [newNode(node)];
            node = node.components[0];
            break;
          case ")":
            delete node.state;
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i10);
              }
              node.indexed = true;
              node.name = "";
            }
            if (checkModifier(node.type, node.name)) {
              node.name = "";
            }
            node.type = verifyType(node.type);
            var child = node;
            node = node.parent;
            if (!node) {
              throwError(i10);
            }
            delete child.parent;
            node.state.allowParams = false;
            node.state.allowName = true;
            node.state.allowArray = true;
            break;
          case ",":
            delete node.state;
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i10);
              }
              node.indexed = true;
              node.name = "";
            }
            if (checkModifier(node.type, node.name)) {
              node.name = "";
            }
            node.type = verifyType(node.type);
            var sibling = newNode(node.parent);
            node.parent.components.push(sibling);
            delete node.parent;
            node = sibling;
            break;
          case " ":
            if (node.state.allowType) {
              if (node.type !== "") {
                node.type = verifyType(node.type);
                delete node.state.allowType;
                node.state.allowName = true;
                node.state.allowParams = true;
              }
            }
            if (node.state.allowName) {
              if (node.name !== "") {
                if (node.name === "indexed") {
                  if (!allowIndexed) {
                    throwError(i10);
                  }
                  if (node.indexed) {
                    throwError(i10);
                  }
                  node.indexed = true;
                  node.name = "";
                } else if (checkModifier(node.type, node.name)) {
                  node.name = "";
                } else {
                  node.state.allowName = false;
                }
              }
            }
            break;
          case "[":
            if (!node.state.allowArray) {
              throwError(i10);
            }
            node.type += c8;
            node.state.allowArray = false;
            node.state.allowName = false;
            node.state.readArray = true;
            break;
          case "]":
            if (!node.state.readArray) {
              throwError(i10);
            }
            node.type += c8;
            node.state.readArray = false;
            node.state.allowArray = true;
            node.state.allowName = true;
            break;
          default:
            if (node.state.allowType) {
              node.type += c8;
              node.state.allowParams = true;
              node.state.allowArray = true;
            } else if (node.state.allowName) {
              node.name += c8;
              delete node.state.allowArray;
            } else if (node.state.readArray) {
              node.type += c8;
            } else {
              throwError(i10);
            }
        }
      }
      if (node.parent) {
        logger19.throwArgumentError("unexpected eof", "param", param);
      }
      delete parent.state;
      if (node.name === "indexed") {
        if (!allowIndexed) {
          throwError(originalParam.length - 7);
        }
        if (node.indexed) {
          throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
      } else if (checkModifier(node.type, node.name)) {
        node.name = "";
      }
      parent.type = verifyType(parent.type);
      return parent;
    }
    function populate(object, params) {
      for (var key in params) {
        (0, properties_1.defineReadOnly)(object, key, params[key]);
      }
    }
    exports.FormatTypes = Object.freeze({
      // Bare formatting, as is needed for computing a sighash of an event or function
      sighash: "sighash",
      // Human-Readable with Minimal spacing and without names (compact human-readable)
      minimal: "minimal",
      // Human-Readable with nice spacing, including all names
      full: "full",
      // JSON-format a la Solidity
      json: "json"
    });
    var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    var ParamType2 = (
      /** @class */
      function() {
        function ParamType3(constructorGuard, params) {
          if (constructorGuard !== _constructorGuard2) {
            logger19.throwError("use fromString", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new ParamType()"
            });
          }
          populate(this, params);
          var match = this.type.match(paramTypeArray);
          if (match) {
            populate(this, {
              arrayLength: parseInt(match[2] || "-1"),
              arrayChildren: ParamType3.fromObject({
                type: match[1],
                components: this.components
              }),
              baseType: "array"
            });
          } else {
            populate(this, {
              arrayLength: null,
              arrayChildren: null,
              baseType: this.components != null ? "tuple" : this.type
            });
          }
          this._isParamType = true;
          Object.freeze(this);
        }
        ParamType3.prototype.format = function(format) {
          if (!format) {
            format = exports.FormatTypes.sighash;
          }
          if (!exports.FormatTypes[format]) {
            logger19.throwArgumentError("invalid format type", "format", format);
          }
          if (format === exports.FormatTypes.json) {
            var result_1 = {
              type: this.baseType === "tuple" ? "tuple" : this.type,
              name: this.name || void 0
            };
            if (typeof this.indexed === "boolean") {
              result_1.indexed = this.indexed;
            }
            if (this.components) {
              result_1.components = this.components.map(function(comp) {
                return JSON.parse(comp.format(format));
              });
            }
            return JSON.stringify(result_1);
          }
          var result = "";
          if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
          } else {
            if (this.baseType === "tuple") {
              if (format !== exports.FormatTypes.sighash) {
                result += this.type;
              }
              result += "(" + this.components.map(function(comp) {
                return comp.format(format);
              }).join(format === exports.FormatTypes.full ? ", " : ",") + ")";
            } else {
              result += this.type;
            }
          }
          if (format !== exports.FormatTypes.sighash) {
            if (this.indexed === true) {
              result += " indexed";
            }
            if (format === exports.FormatTypes.full && this.name) {
              result += " " + this.name;
            }
          }
          return result;
        };
        ParamType3.from = function(value, allowIndexed) {
          if (typeof value === "string") {
            return ParamType3.fromString(value, allowIndexed);
          }
          return ParamType3.fromObject(value);
        };
        ParamType3.fromObject = function(value) {
          if (ParamType3.isParamType(value)) {
            return value;
          }
          return new ParamType3(_constructorGuard2, {
            name: value.name || null,
            type: verifyType(value.type),
            indexed: value.indexed == null ? null : !!value.indexed,
            components: value.components ? value.components.map(ParamType3.fromObject) : null
          });
        };
        ParamType3.fromString = function(value, allowIndexed) {
          function ParamTypify(node) {
            return ParamType3.fromObject({
              name: node.name,
              type: node.type,
              indexed: node.indexed,
              components: node.components
            });
          }
          return ParamTypify(parseParamType(value, !!allowIndexed));
        };
        ParamType3.isParamType = function(value) {
          return !!(value != null && value._isParamType);
        };
        return ParamType3;
      }()
    );
    exports.ParamType = ParamType2;
    function parseParams(value, allowIndex) {
      return splitNesting(value).map(function(param) {
        return ParamType2.fromString(param, allowIndex);
      });
    }
    var Fragment2 = (
      /** @class */
      function() {
        function Fragment3(constructorGuard, params) {
          if (constructorGuard !== _constructorGuard2) {
            logger19.throwError("use a static from method", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Fragment()"
            });
          }
          populate(this, params);
          this._isFragment = true;
          Object.freeze(this);
        }
        Fragment3.from = function(value) {
          if (Fragment3.isFragment(value)) {
            return value;
          }
          if (typeof value === "string") {
            return Fragment3.fromString(value);
          }
          return Fragment3.fromObject(value);
        };
        Fragment3.fromObject = function(value) {
          if (Fragment3.isFragment(value)) {
            return value;
          }
          switch (value.type) {
            case "function":
              return FunctionFragment3.fromObject(value);
            case "event":
              return EventFragment2.fromObject(value);
            case "constructor":
              return ConstructorFragment2.fromObject(value);
            case "error":
              return ErrorFragment2.fromObject(value);
            case "fallback":
            case "receive":
              return null;
          }
          return logger19.throwArgumentError("invalid fragment object", "value", value);
        };
        Fragment3.fromString = function(value) {
          value = value.replace(/\s/g, " ");
          value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
          value = value.trim();
          if (value.split(" ")[0] === "event") {
            return EventFragment2.fromString(value.substring(5).trim());
          } else if (value.split(" ")[0] === "function") {
            return FunctionFragment3.fromString(value.substring(8).trim());
          } else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment2.fromString(value.trim());
          } else if (value.split(" ")[0] === "error") {
            return ErrorFragment2.fromString(value.substring(5).trim());
          }
          return logger19.throwArgumentError("unsupported fragment", "value", value);
        };
        Fragment3.isFragment = function(value) {
          return !!(value && value._isFragment);
        };
        return Fragment3;
      }()
    );
    exports.Fragment = Fragment2;
    var EventFragment2 = (
      /** @class */
      function(_super) {
        __extends2(EventFragment3, _super);
        function EventFragment3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EventFragment3.prototype.format = function(format) {
          if (!format) {
            format = exports.FormatTypes.sighash;
          }
          if (!exports.FormatTypes[format]) {
            logger19.throwArgumentError("invalid format type", "format", format);
          }
          if (format === exports.FormatTypes.json) {
            return JSON.stringify({
              type: "event",
              anonymous: this.anonymous,
              name: this.name,
              inputs: this.inputs.map(function(input) {
                return JSON.parse(input.format(format));
              })
            });
          }
          var result = "";
          if (format !== exports.FormatTypes.sighash) {
            result += "event ";
          }
          result += this.name + "(" + this.inputs.map(function(input) {
            return input.format(format);
          }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
          if (format !== exports.FormatTypes.sighash) {
            if (this.anonymous) {
              result += "anonymous ";
            }
          }
          return result.trim();
        };
        EventFragment3.from = function(value) {
          if (typeof value === "string") {
            return EventFragment3.fromString(value);
          }
          return EventFragment3.fromObject(value);
        };
        EventFragment3.fromObject = function(value) {
          if (EventFragment3.isEventFragment(value)) {
            return value;
          }
          if (value.type !== "event") {
            logger19.throwArgumentError("invalid event object", "value", value);
          }
          var params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
            type: "event"
          };
          return new EventFragment3(_constructorGuard2, params);
        };
        EventFragment3.fromString = function(value) {
          var match = value.match(regexParen);
          if (!match) {
            logger19.throwArgumentError("invalid event string", "value", value);
          }
          var anonymous = false;
          match[3].split(" ").forEach(function(modifier) {
            switch (modifier.trim()) {
              case "anonymous":
                anonymous = true;
                break;
              case "":
                break;
              default:
                logger19.warn("unknown modifier: " + modifier);
            }
          });
          return EventFragment3.fromObject({
            name: match[1].trim(),
            anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
          });
        };
        EventFragment3.isEventFragment = function(value) {
          return value && value._isFragment && value.type === "event";
        };
        return EventFragment3;
      }(Fragment2)
    );
    exports.EventFragment = EventFragment2;
    function parseGas(value, params) {
      params.gas = null;
      var comps = value.split("@");
      if (comps.length !== 1) {
        if (comps.length > 2) {
          logger19.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
          logger19.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = bignumber_1.BigNumber.from(comps[1]);
        return comps[0];
      }
      return value;
    }
    function parseModifiers(value, params) {
      params.constant = false;
      params.payable = false;
      params.stateMutability = "nonpayable";
      value.split(" ").forEach(function(modifier) {
        switch (modifier.trim()) {
          case "constant":
            params.constant = true;
            break;
          case "payable":
            params.payable = true;
            params.stateMutability = "payable";
            break;
          case "nonpayable":
            params.payable = false;
            params.stateMutability = "nonpayable";
            break;
          case "pure":
            params.constant = true;
            params.stateMutability = "pure";
            break;
          case "view":
            params.constant = true;
            params.stateMutability = "view";
            break;
          case "external":
          case "public":
          case "":
            break;
          default:
            console.log("unknown modifier: " + modifier);
        }
      });
    }
    function verifyState(value) {
      var result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
      };
      if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
        if (value.constant != null) {
          if (!!value.constant !== result.constant) {
            logger19.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
          }
        }
        result.payable = result.stateMutability === "payable";
        if (value.payable != null) {
          if (!!value.payable !== result.payable) {
            logger19.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
          }
        }
      } else if (value.payable != null) {
        result.payable = !!value.payable;
        if (value.constant == null && !result.payable && value.type !== "constructor") {
          logger19.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
          result.stateMutability = "view";
        } else {
          result.stateMutability = result.payable ? "payable" : "nonpayable";
        }
        if (result.payable && result.constant) {
          logger19.throwArgumentError("cannot have constant payable function", "value", value);
        }
      } else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = result.constant ? "view" : "payable";
      } else if (value.type !== "constructor") {
        logger19.throwArgumentError("unable to determine stateMutability", "value", value);
      }
      return result;
    }
    var ConstructorFragment2 = (
      /** @class */
      function(_super) {
        __extends2(ConstructorFragment3, _super);
        function ConstructorFragment3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ConstructorFragment3.prototype.format = function(format) {
          if (!format) {
            format = exports.FormatTypes.sighash;
          }
          if (!exports.FormatTypes[format]) {
            logger19.throwArgumentError("invalid format type", "format", format);
          }
          if (format === exports.FormatTypes.json) {
            return JSON.stringify({
              type: "constructor",
              stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
              payable: this.payable,
              gas: this.gas ? this.gas.toNumber() : void 0,
              inputs: this.inputs.map(function(input) {
                return JSON.parse(input.format(format));
              })
            });
          }
          if (format === exports.FormatTypes.sighash) {
            logger19.throwError("cannot format a constructor for sighash", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "format(sighash)"
            });
          }
          var result = "constructor(" + this.inputs.map(function(input) {
            return input.format(format);
          }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
          if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
          }
          return result.trim();
        };
        ConstructorFragment3.from = function(value) {
          if (typeof value === "string") {
            return ConstructorFragment3.fromString(value);
          }
          return ConstructorFragment3.fromObject(value);
        };
        ConstructorFragment3.fromObject = function(value) {
          if (ConstructorFragment3.isConstructorFragment(value)) {
            return value;
          }
          if (value.type !== "constructor") {
            logger19.throwArgumentError("invalid constructor object", "value", value);
          }
          var state = verifyState(value);
          if (state.constant) {
            logger19.throwArgumentError("constructor cannot be constant", "value", value);
          }
          var params = {
            name: null,
            type: value.type,
            inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
          };
          return new ConstructorFragment3(_constructorGuard2, params);
        };
        ConstructorFragment3.fromString = function(value) {
          var params = { type: "constructor" };
          value = parseGas(value, params);
          var parens = value.match(regexParen);
          if (!parens || parens[1].trim() !== "constructor") {
            logger19.throwArgumentError("invalid constructor string", "value", value);
          }
          params.inputs = parseParams(parens[2].trim(), false);
          parseModifiers(parens[3].trim(), params);
          return ConstructorFragment3.fromObject(params);
        };
        ConstructorFragment3.isConstructorFragment = function(value) {
          return value && value._isFragment && value.type === "constructor";
        };
        return ConstructorFragment3;
      }(Fragment2)
    );
    exports.ConstructorFragment = ConstructorFragment2;
    var FunctionFragment3 = (
      /** @class */
      function(_super) {
        __extends2(FunctionFragment4, _super);
        function FunctionFragment4() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        FunctionFragment4.prototype.format = function(format) {
          if (!format) {
            format = exports.FormatTypes.sighash;
          }
          if (!exports.FormatTypes[format]) {
            logger19.throwArgumentError("invalid format type", "format", format);
          }
          if (format === exports.FormatTypes.json) {
            return JSON.stringify({
              type: "function",
              name: this.name,
              constant: this.constant,
              stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
              payable: this.payable,
              gas: this.gas ? this.gas.toNumber() : void 0,
              inputs: this.inputs.map(function(input) {
                return JSON.parse(input.format(format));
              }),
              outputs: this.outputs.map(function(output) {
                return JSON.parse(output.format(format));
              })
            });
          }
          var result = "";
          if (format !== exports.FormatTypes.sighash) {
            result += "function ";
          }
          result += this.name + "(" + this.inputs.map(function(input) {
            return input.format(format);
          }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
          if (format !== exports.FormatTypes.sighash) {
            if (this.stateMutability) {
              if (this.stateMutability !== "nonpayable") {
                result += this.stateMutability + " ";
              }
            } else if (this.constant) {
              result += "view ";
            }
            if (this.outputs && this.outputs.length) {
              result += "returns (" + this.outputs.map(function(output) {
                return output.format(format);
              }).join(", ") + ") ";
            }
            if (this.gas != null) {
              result += "@" + this.gas.toString() + " ";
            }
          }
          return result.trim();
        };
        FunctionFragment4.from = function(value) {
          if (typeof value === "string") {
            return FunctionFragment4.fromString(value);
          }
          return FunctionFragment4.fromObject(value);
        };
        FunctionFragment4.fromObject = function(value) {
          if (FunctionFragment4.isFunctionFragment(value)) {
            return value;
          }
          if (value.type !== "function") {
            logger19.throwArgumentError("invalid function object", "value", value);
          }
          var state = verifyState(value);
          var params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
            outputs: value.outputs ? value.outputs.map(ParamType2.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
          };
          return new FunctionFragment4(_constructorGuard2, params);
        };
        FunctionFragment4.fromString = function(value) {
          var params = { type: "function" };
          value = parseGas(value, params);
          var comps = value.split(" returns ");
          if (comps.length > 2) {
            logger19.throwArgumentError("invalid function string", "value", value);
          }
          var parens = comps[0].match(regexParen);
          if (!parens) {
            logger19.throwArgumentError("invalid function signature", "value", value);
          }
          params.name = parens[1].trim();
          if (params.name) {
            verifyIdentifier(params.name);
          }
          params.inputs = parseParams(parens[2], false);
          parseModifiers(parens[3].trim(), params);
          if (comps.length > 1) {
            var returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
              logger19.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
          } else {
            params.outputs = [];
          }
          return FunctionFragment4.fromObject(params);
        };
        FunctionFragment4.isFunctionFragment = function(value) {
          return value && value._isFragment && value.type === "function";
        };
        return FunctionFragment4;
      }(ConstructorFragment2)
    );
    exports.FunctionFragment = FunctionFragment3;
    function checkForbidden(fragment) {
      var sig = fragment.format();
      if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger19.throwArgumentError("cannot specify user defined " + sig + " error", "fragment", fragment);
      }
      return fragment;
    }
    var ErrorFragment2 = (
      /** @class */
      function(_super) {
        __extends2(ErrorFragment3, _super);
        function ErrorFragment3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ErrorFragment3.prototype.format = function(format) {
          if (!format) {
            format = exports.FormatTypes.sighash;
          }
          if (!exports.FormatTypes[format]) {
            logger19.throwArgumentError("invalid format type", "format", format);
          }
          if (format === exports.FormatTypes.json) {
            return JSON.stringify({
              type: "error",
              name: this.name,
              inputs: this.inputs.map(function(input) {
                return JSON.parse(input.format(format));
              })
            });
          }
          var result = "";
          if (format !== exports.FormatTypes.sighash) {
            result += "error ";
          }
          result += this.name + "(" + this.inputs.map(function(input) {
            return input.format(format);
          }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
          return result.trim();
        };
        ErrorFragment3.from = function(value) {
          if (typeof value === "string") {
            return ErrorFragment3.fromString(value);
          }
          return ErrorFragment3.fromObject(value);
        };
        ErrorFragment3.fromObject = function(value) {
          if (ErrorFragment3.isErrorFragment(value)) {
            return value;
          }
          if (value.type !== "error") {
            logger19.throwArgumentError("invalid error object", "value", value);
          }
          var params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : []
          };
          return checkForbidden(new ErrorFragment3(_constructorGuard2, params));
        };
        ErrorFragment3.fromString = function(value) {
          var params = { type: "error" };
          var parens = value.match(regexParen);
          if (!parens) {
            logger19.throwArgumentError("invalid error signature", "value", value);
          }
          params.name = parens[1].trim();
          if (params.name) {
            verifyIdentifier(params.name);
          }
          params.inputs = parseParams(parens[2], false);
          return checkForbidden(ErrorFragment3.fromObject(params));
        };
        ErrorFragment3.isErrorFragment = function(value) {
          return value && value._isFragment && value.type === "error";
        };
        return ErrorFragment3;
      }(Fragment2)
    );
    exports.ErrorFragment = ErrorFragment2;
    function verifyType(type) {
      if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
      } else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
      }
      return type;
    }
    var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    function verifyIdentifier(value) {
      if (!value || !value.match(regexIdentifier)) {
        logger19.throwArgumentError('invalid identifier "' + value + '"', "value", value);
      }
      return value;
    }
    var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
    function splitNesting(value) {
      value = value.trim();
      var result = [];
      var accum = "";
      var depth = 0;
      for (var offset = 0; offset < value.length; offset++) {
        var c8 = value[offset];
        if (c8 === "," && depth === 0) {
          result.push(accum);
          accum = "";
        } else {
          accum += c8;
          if (c8 === "(") {
            depth++;
          } else if (c8 === ")") {
            depth--;
            if (depth === -1) {
              logger19.throwArgumentError("unbalanced parenthesis", "value", value);
            }
          }
        }
      }
      if (accum) {
        result.push(accum);
      }
      return result;
    }
  }
});

// node_modules/@ethersproject/abi/lib/coders/abstract-coder.js
var require_abstract_coder = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/abstract-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = void 0;
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger19 = new logger_1.Logger(_version_1.version);
    function checkResultErrors3(result) {
      var errors2 = [];
      var checkErrors = function(path, object) {
        if (!Array.isArray(object)) {
          return;
        }
        for (var key in object) {
          var childPath = path.slice();
          childPath.push(key);
          try {
            checkErrors(childPath, object[key]);
          } catch (error) {
            errors2.push({ path: childPath, error });
          }
        }
      };
      checkErrors([], result);
      return errors2;
    }
    exports.checkResultErrors = checkResultErrors3;
    var Coder = (
      /** @class */
      function() {
        function Coder2(name2, type, localName, dynamic) {
          this.name = name2;
          this.type = type;
          this.localName = localName;
          this.dynamic = dynamic;
        }
        Coder2.prototype._throwError = function(message, value) {
          logger19.throwArgumentError(message, this.localName, value);
        };
        return Coder2;
      }()
    );
    exports.Coder = Coder;
    var Writer = (
      /** @class */
      function() {
        function Writer2(wordSize) {
          (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
          this._data = [];
          this._dataLength = 0;
          this._padding = new Uint8Array(wordSize);
        }
        Object.defineProperty(Writer2.prototype, "data", {
          get: function() {
            return (0, bytes_1.hexConcat)(this._data);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Writer2.prototype, "length", {
          get: function() {
            return this._dataLength;
          },
          enumerable: false,
          configurable: true
        });
        Writer2.prototype._writeData = function(data2) {
          this._data.push(data2);
          this._dataLength += data2.length;
          return data2.length;
        };
        Writer2.prototype.appendWriter = function(writer) {
          return this._writeData((0, bytes_1.concat)(writer._data));
        };
        Writer2.prototype.writeBytes = function(value) {
          var bytes = (0, bytes_1.arrayify)(value);
          var paddingOffset = bytes.length % this.wordSize;
          if (paddingOffset) {
            bytes = (0, bytes_1.concat)([bytes, this._padding.slice(paddingOffset)]);
          }
          return this._writeData(bytes);
        };
        Writer2.prototype._getValue = function(value) {
          var bytes = (0, bytes_1.arrayify)(bignumber_1.BigNumber.from(value));
          if (bytes.length > this.wordSize) {
            logger19.throwError("value out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
              length: this.wordSize,
              offset: bytes.length
            });
          }
          if (bytes.length % this.wordSize) {
            bytes = (0, bytes_1.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
          }
          return bytes;
        };
        Writer2.prototype.writeValue = function(value) {
          return this._writeData(this._getValue(value));
        };
        Writer2.prototype.writeUpdatableValue = function() {
          var _this = this;
          var offset = this._data.length;
          this._data.push(this._padding);
          this._dataLength += this.wordSize;
          return function(value) {
            _this._data[offset] = _this._getValue(value);
          };
        };
        return Writer2;
      }()
    );
    exports.Writer = Writer;
    var Reader = (
      /** @class */
      function() {
        function Reader2(data2, wordSize, coerceFunc, allowLoose) {
          (0, properties_1.defineReadOnly)(this, "_data", (0, bytes_1.arrayify)(data2));
          (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
          (0, properties_1.defineReadOnly)(this, "_coerceFunc", coerceFunc);
          (0, properties_1.defineReadOnly)(this, "allowLoose", allowLoose);
          this._offset = 0;
        }
        Object.defineProperty(Reader2.prototype, "data", {
          get: function() {
            return (0, bytes_1.hexlify)(this._data);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Reader2.prototype, "consumed", {
          get: function() {
            return this._offset;
          },
          enumerable: false,
          configurable: true
        });
        Reader2.coerce = function(name2, value) {
          var match = name2.match("^u?int([0-9]+)$");
          if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
          }
          return value;
        };
        Reader2.prototype.coerce = function(name2, value) {
          if (this._coerceFunc) {
            return this._coerceFunc(name2, value);
          }
          return Reader2.coerce(name2, value);
        };
        Reader2.prototype._peekBytes = function(offset, length2, loose) {
          var alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
          if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
              alignedLength = length2;
            } else {
              logger19.throwError("data out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
                length: this._data.length,
                offset: this._offset + alignedLength
              });
            }
          }
          return this._data.slice(this._offset, this._offset + alignedLength);
        };
        Reader2.prototype.subReader = function(offset) {
          return new Reader2(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
        };
        Reader2.prototype.readBytes = function(length2, loose) {
          var bytes = this._peekBytes(0, length2, !!loose);
          this._offset += bytes.length;
          return bytes.slice(0, length2);
        };
        Reader2.prototype.readValue = function() {
          return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));
        };
        return Reader2;
      }()
    );
    exports.Reader = Reader;
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n8, s11) {
          return methods["cshake" + bits2].update(message, outputBits, n8, s11)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s11) {
          return methods["kmac" + bits2].update(key, message, outputBits, s11)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i11 = 0; i11 < OUTPUT_TYPES.length; ++i11) {
          var type = OUTPUT_TYPES[i11];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w11 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n8, s11) {
          if (!n8 && !s11) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n8, s11], w11);
          }
        };
        method.update = function(message, outputBits, n8, s11) {
          return method.create(outputBits, n8, s11).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w11 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s11) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s11], w11).bytepad([key], w11);
        };
        method.update = function(key, message, outputBits, s11) {
          return method.create(key, outputBits, s11).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i10 = 0; i10 < algorithms.length; ++i10) {
        var algorithm = algorithms[i10];
        var bits = algorithm.bits;
        for (var j8 = 0; j8 < bits.length; ++j8) {
          var methodName = algorithm.name + "_" + bits[j8];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j8], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j8];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i11 = 0; i11 < 50; ++i11) {
          this.s[i11] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s11 = this.s, i11, code2;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i11 = 1; i11 < blockCount + 1; ++i11) {
              blocks[i11] = 0;
            }
          }
          if (notString) {
            for (i11 = this.start; index < length2 && i11 < byteCount; ++index) {
              blocks[i11 >> 2] |= message[index] << SHIFT[i11++ & 3];
            }
          } else {
            for (i11 = this.start; index < length2 && i11 < byteCount; ++index) {
              code2 = message.charCodeAt(index);
              if (code2 < 128) {
                blocks[i11 >> 2] |= code2 << SHIFT[i11++ & 3];
              } else if (code2 < 2048) {
                blocks[i11 >> 2] |= (192 | code2 >> 6) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 & 63) << SHIFT[i11++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i11 >> 2] |= (224 | code2 >> 12) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 & 63) << SHIFT[i11++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i11 >> 2] |= (240 | code2 >> 18) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i11++ & 3];
                blocks[i11 >> 2] |= (128 | code2 & 63) << SHIFT[i11++ & 3];
              }
            }
          }
          this.lastByteIndex = i11;
          if (i11 >= byteCount) {
            this.start = i11 - byteCount;
            this.block = blocks[blockCount];
            for (i11 = 0; i11 < blockCount; ++i11) {
              s11[i11] ^= blocks[i11];
            }
            f7(s11);
            this.reset = true;
          } else {
            this.start = i11;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x8, right) {
        var o11 = x8 & 255, n8 = 1;
        var bytes = [o11];
        x8 = x8 >> 8;
        o11 = x8 & 255;
        while (o11 > 0) {
          bytes.unshift(o11);
          x8 = x8 >> 8;
          o11 = x8 & 255;
          ++n8;
        }
        if (right) {
          bytes.push(n8);
        } else {
          bytes.unshift(n8);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i11 = 0; i11 < str.length; ++i11) {
            var code2 = str.charCodeAt(i11);
            if (code2 < 128) {
              bytes += 1;
            } else if (code2 < 2048) {
              bytes += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i11) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w11) {
        var bytes = this.encode(w11);
        for (var i11 = 0; i11 < strs.length; ++i11) {
          bytes += this.encodeString(strs[i11]);
        }
        var paddingBytes = w11 - bytes % w11;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i11 = this.lastByteIndex, blockCount = this.blockCount, s11 = this.s;
        blocks[i11 >> 2] |= this.padding[i11 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i11 = 1; i11 < blockCount + 1; ++i11) {
            blocks[i11] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i11 = 0; i11 < blockCount; ++i11) {
          s11[i11] ^= blocks[i11];
        }
        f7(s11);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s11 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i11 = 0, j9 = 0;
        var hex = "", block;
        while (j9 < outputBlocks) {
          for (i11 = 0; i11 < blockCount && j9 < outputBlocks; ++i11, ++j9) {
            block = s11[i11];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j9 % blockCount === 0) {
            f7(s11);
            i11 = 0;
          }
        }
        if (extraBytes) {
          block = s11[i11];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s11 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i11 = 0, j9 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j9 < outputBlocks) {
          for (i11 = 0; i11 < blockCount && j9 < outputBlocks; ++i11, ++j9) {
            array[j9] = s11[i11];
          }
          if (j9 % blockCount === 0) {
            f7(s11);
          }
        }
        if (extraBytes) {
          array[i11] = s11[i11];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s11 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i11 = 0, j9 = 0;
        var array = [], offset, block;
        while (j9 < outputBlocks) {
          for (i11 = 0; i11 < blockCount && j9 < outputBlocks; ++i11, ++j9) {
            offset = j9 << 2;
            block = s11[i11];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j9 % blockCount === 0) {
            f7(s11);
          }
        }
        if (extraBytes) {
          offset = j9 << 2;
          block = s11[i11];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f7 = function(s11) {
        var h11, l9, n8, c0, c1, c22, c32, c42, c52, c62, c72, c8, c9, b0, b1, b22, b32, b42, b52, b62, b72, b82, b92, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
        for (n8 = 0; n8 < 48; n8 += 2) {
          c0 = s11[0] ^ s11[10] ^ s11[20] ^ s11[30] ^ s11[40];
          c1 = s11[1] ^ s11[11] ^ s11[21] ^ s11[31] ^ s11[41];
          c22 = s11[2] ^ s11[12] ^ s11[22] ^ s11[32] ^ s11[42];
          c32 = s11[3] ^ s11[13] ^ s11[23] ^ s11[33] ^ s11[43];
          c42 = s11[4] ^ s11[14] ^ s11[24] ^ s11[34] ^ s11[44];
          c52 = s11[5] ^ s11[15] ^ s11[25] ^ s11[35] ^ s11[45];
          c62 = s11[6] ^ s11[16] ^ s11[26] ^ s11[36] ^ s11[46];
          c72 = s11[7] ^ s11[17] ^ s11[27] ^ s11[37] ^ s11[47];
          c8 = s11[8] ^ s11[18] ^ s11[28] ^ s11[38] ^ s11[48];
          c9 = s11[9] ^ s11[19] ^ s11[29] ^ s11[39] ^ s11[49];
          h11 = c8 ^ (c22 << 1 | c32 >>> 31);
          l9 = c9 ^ (c32 << 1 | c22 >>> 31);
          s11[0] ^= h11;
          s11[1] ^= l9;
          s11[10] ^= h11;
          s11[11] ^= l9;
          s11[20] ^= h11;
          s11[21] ^= l9;
          s11[30] ^= h11;
          s11[31] ^= l9;
          s11[40] ^= h11;
          s11[41] ^= l9;
          h11 = c0 ^ (c42 << 1 | c52 >>> 31);
          l9 = c1 ^ (c52 << 1 | c42 >>> 31);
          s11[2] ^= h11;
          s11[3] ^= l9;
          s11[12] ^= h11;
          s11[13] ^= l9;
          s11[22] ^= h11;
          s11[23] ^= l9;
          s11[32] ^= h11;
          s11[33] ^= l9;
          s11[42] ^= h11;
          s11[43] ^= l9;
          h11 = c22 ^ (c62 << 1 | c72 >>> 31);
          l9 = c32 ^ (c72 << 1 | c62 >>> 31);
          s11[4] ^= h11;
          s11[5] ^= l9;
          s11[14] ^= h11;
          s11[15] ^= l9;
          s11[24] ^= h11;
          s11[25] ^= l9;
          s11[34] ^= h11;
          s11[35] ^= l9;
          s11[44] ^= h11;
          s11[45] ^= l9;
          h11 = c42 ^ (c8 << 1 | c9 >>> 31);
          l9 = c52 ^ (c9 << 1 | c8 >>> 31);
          s11[6] ^= h11;
          s11[7] ^= l9;
          s11[16] ^= h11;
          s11[17] ^= l9;
          s11[26] ^= h11;
          s11[27] ^= l9;
          s11[36] ^= h11;
          s11[37] ^= l9;
          s11[46] ^= h11;
          s11[47] ^= l9;
          h11 = c62 ^ (c0 << 1 | c1 >>> 31);
          l9 = c72 ^ (c1 << 1 | c0 >>> 31);
          s11[8] ^= h11;
          s11[9] ^= l9;
          s11[18] ^= h11;
          s11[19] ^= l9;
          s11[28] ^= h11;
          s11[29] ^= l9;
          s11[38] ^= h11;
          s11[39] ^= l9;
          s11[48] ^= h11;
          s11[49] ^= l9;
          b0 = s11[0];
          b1 = s11[1];
          b322 = s11[11] << 4 | s11[10] >>> 28;
          b33 = s11[10] << 4 | s11[11] >>> 28;
          b14 = s11[20] << 3 | s11[21] >>> 29;
          b15 = s11[21] << 3 | s11[20] >>> 29;
          b46 = s11[31] << 9 | s11[30] >>> 23;
          b47 = s11[30] << 9 | s11[31] >>> 23;
          b28 = s11[40] << 18 | s11[41] >>> 14;
          b29 = s11[41] << 18 | s11[40] >>> 14;
          b20 = s11[2] << 1 | s11[3] >>> 31;
          b21 = s11[3] << 1 | s11[2] >>> 31;
          b22 = s11[13] << 12 | s11[12] >>> 20;
          b32 = s11[12] << 12 | s11[13] >>> 20;
          b34 = s11[22] << 10 | s11[23] >>> 22;
          b35 = s11[23] << 10 | s11[22] >>> 22;
          b16 = s11[33] << 13 | s11[32] >>> 19;
          b17 = s11[32] << 13 | s11[33] >>> 19;
          b48 = s11[42] << 2 | s11[43] >>> 30;
          b49 = s11[43] << 2 | s11[42] >>> 30;
          b40 = s11[5] << 30 | s11[4] >>> 2;
          b41 = s11[4] << 30 | s11[5] >>> 2;
          b222 = s11[14] << 6 | s11[15] >>> 26;
          b23 = s11[15] << 6 | s11[14] >>> 26;
          b42 = s11[25] << 11 | s11[24] >>> 21;
          b52 = s11[24] << 11 | s11[25] >>> 21;
          b36 = s11[34] << 15 | s11[35] >>> 17;
          b37 = s11[35] << 15 | s11[34] >>> 17;
          b18 = s11[45] << 29 | s11[44] >>> 3;
          b19 = s11[44] << 29 | s11[45] >>> 3;
          b10 = s11[6] << 28 | s11[7] >>> 4;
          b11 = s11[7] << 28 | s11[6] >>> 4;
          b422 = s11[17] << 23 | s11[16] >>> 9;
          b43 = s11[16] << 23 | s11[17] >>> 9;
          b24 = s11[26] << 25 | s11[27] >>> 7;
          b25 = s11[27] << 25 | s11[26] >>> 7;
          b62 = s11[36] << 21 | s11[37] >>> 11;
          b72 = s11[37] << 21 | s11[36] >>> 11;
          b38 = s11[47] << 24 | s11[46] >>> 8;
          b39 = s11[46] << 24 | s11[47] >>> 8;
          b30 = s11[8] << 27 | s11[9] >>> 5;
          b31 = s11[9] << 27 | s11[8] >>> 5;
          b12 = s11[18] << 20 | s11[19] >>> 12;
          b13 = s11[19] << 20 | s11[18] >>> 12;
          b44 = s11[29] << 7 | s11[28] >>> 25;
          b45 = s11[28] << 7 | s11[29] >>> 25;
          b26 = s11[38] << 8 | s11[39] >>> 24;
          b27 = s11[39] << 8 | s11[38] >>> 24;
          b82 = s11[48] << 14 | s11[49] >>> 18;
          b92 = s11[49] << 14 | s11[48] >>> 18;
          s11[0] = b0 ^ ~b22 & b42;
          s11[1] = b1 ^ ~b32 & b52;
          s11[10] = b10 ^ ~b12 & b14;
          s11[11] = b11 ^ ~b13 & b15;
          s11[20] = b20 ^ ~b222 & b24;
          s11[21] = b21 ^ ~b23 & b25;
          s11[30] = b30 ^ ~b322 & b34;
          s11[31] = b31 ^ ~b33 & b35;
          s11[40] = b40 ^ ~b422 & b44;
          s11[41] = b41 ^ ~b43 & b45;
          s11[2] = b22 ^ ~b42 & b62;
          s11[3] = b32 ^ ~b52 & b72;
          s11[12] = b12 ^ ~b14 & b16;
          s11[13] = b13 ^ ~b15 & b17;
          s11[22] = b222 ^ ~b24 & b26;
          s11[23] = b23 ^ ~b25 & b27;
          s11[32] = b322 ^ ~b34 & b36;
          s11[33] = b33 ^ ~b35 & b37;
          s11[42] = b422 ^ ~b44 & b46;
          s11[43] = b43 ^ ~b45 & b47;
          s11[4] = b42 ^ ~b62 & b82;
          s11[5] = b52 ^ ~b72 & b92;
          s11[14] = b14 ^ ~b16 & b18;
          s11[15] = b15 ^ ~b17 & b19;
          s11[24] = b24 ^ ~b26 & b28;
          s11[25] = b25 ^ ~b27 & b29;
          s11[34] = b34 ^ ~b36 & b38;
          s11[35] = b35 ^ ~b37 & b39;
          s11[44] = b44 ^ ~b46 & b48;
          s11[45] = b45 ^ ~b47 & b49;
          s11[6] = b62 ^ ~b82 & b0;
          s11[7] = b72 ^ ~b92 & b1;
          s11[16] = b16 ^ ~b18 & b10;
          s11[17] = b17 ^ ~b19 & b11;
          s11[26] = b26 ^ ~b28 & b20;
          s11[27] = b27 ^ ~b29 & b21;
          s11[36] = b36 ^ ~b38 & b30;
          s11[37] = b37 ^ ~b39 & b31;
          s11[46] = b46 ^ ~b48 & b40;
          s11[47] = b47 ^ ~b49 & b41;
          s11[8] = b82 ^ ~b0 & b22;
          s11[9] = b92 ^ ~b1 & b32;
          s11[18] = b18 ^ ~b10 & b12;
          s11[19] = b19 ^ ~b11 & b13;
          s11[28] = b28 ^ ~b20 & b222;
          s11[29] = b29 ^ ~b21 & b23;
          s11[38] = b38 ^ ~b30 & b322;
          s11[39] = b39 ^ ~b31 & b33;
          s11[48] = b48 ^ ~b40 & b422;
          s11[49] = b49 ^ ~b41 & b43;
          s11[0] ^= RC[n8];
          s11[1] ^= RC[n8 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i10 = 0; i10 < methodNames.length; ++i10) {
          root[methodNames[i10]] = methods[methodNames[i10]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@ethersproject/keccak256/lib/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var js_sha3_1 = __importDefault2(require_sha3());
    var bytes_1 = require_lib2();
    function keccak2562(data2) {
      return "0x" + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data2));
    }
    exports.keccak256 = keccak2562;
  }
});

// node_modules/@ethersproject/rlp/lib/_version.js
var require_version6 = __commonJS({
  "node_modules/@ethersproject/rlp/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "rlp/5.7.0";
  }
});

// node_modules/@ethersproject/rlp/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@ethersproject/rlp/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version6();
    var logger19 = new logger_1.Logger(_version_1.version);
    function arrayifyInteger(value) {
      var result = [];
      while (value) {
        result.unshift(value & 255);
        value >>= 8;
      }
      return result;
    }
    function unarrayifyInteger(data2, offset, length2) {
      var result = 0;
      for (var i10 = 0; i10 < length2; i10++) {
        result = result * 256 + data2[offset + i10];
      }
      return result;
    }
    function _encode(object) {
      if (Array.isArray(object)) {
        var payload_1 = [];
        object.forEach(function(child) {
          payload_1 = payload_1.concat(_encode(child));
        });
        if (payload_1.length <= 55) {
          payload_1.unshift(192 + payload_1.length);
          return payload_1;
        }
        var length_1 = arrayifyInteger(payload_1.length);
        length_1.unshift(247 + length_1.length);
        return length_1.concat(payload_1);
      }
      if (!(0, bytes_1.isBytesLike)(object)) {
        logger19.throwArgumentError("RLP object must be BytesLike", "object", object);
      }
      var data2 = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
      if (data2.length === 1 && data2[0] <= 127) {
        return data2;
      } else if (data2.length <= 55) {
        data2.unshift(128 + data2.length);
        return data2;
      }
      var length2 = arrayifyInteger(data2.length);
      length2.unshift(183 + length2.length);
      return length2.concat(data2);
    }
    function encode5(object) {
      return (0, bytes_1.hexlify)(_encode(object));
    }
    exports.encode = encode5;
    function _decodeChildren(data2, offset, childOffset, length2) {
      var result = [];
      while (childOffset < offset + 1 + length2) {
        var decoded = _decode(data2, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length2) {
          logger19.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
      }
      return { consumed: 1 + length2, result };
    }
    function _decode(data2, offset) {
      if (data2.length === 0) {
        logger19.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      if (data2[offset] >= 248) {
        var lengthLength = data2[offset] - 247;
        if (offset + 1 + lengthLength > data2.length) {
          logger19.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_2 = unarrayifyInteger(data2, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_2 > data2.length) {
          logger19.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length_2);
      } else if (data2[offset] >= 192) {
        var length_3 = data2[offset] - 192;
        if (offset + 1 + length_3 > data2.length) {
          logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data2, offset, offset + 1, length_3);
      } else if (data2[offset] >= 184) {
        var lengthLength = data2[offset] - 183;
        if (offset + 1 + lengthLength > data2.length) {
          logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_4 = unarrayifyInteger(data2, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_4 > data2.length) {
          logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
        return { consumed: 1 + lengthLength + length_4, result };
      } else if (data2[offset] >= 128) {
        var length_5 = data2[offset] - 128;
        if (offset + 1 + length_5 > data2.length) {
          logger19.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data2.slice(offset + 1, offset + 1 + length_5));
        return { consumed: 1 + length_5, result };
      }
      return { consumed: 1, result: (0, bytes_1.hexlify)(data2[offset]) };
    }
    function decode6(data2) {
      var bytes = (0, bytes_1.arrayify)(data2);
      var decoded = _decode(bytes, 0);
      if (decoded.consumed !== bytes.length) {
        logger19.throwArgumentError("invalid rlp data", "data", data2);
      }
      return decoded.result;
    }
    exports.decode = decode6;
  }
});

// node_modules/@ethersproject/address/lib/_version.js
var require_version7 = __commonJS({
  "node_modules/@ethersproject/address/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "address/5.7.0";
  }
});

// node_modules/@ethersproject/address/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@ethersproject/address/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var keccak256_1 = require_lib5();
    var rlp_1 = require_lib6();
    var logger_1 = require_lib();
    var _version_1 = require_version7();
    var logger19 = new logger_1.Logger(_version_1.version);
    function getChecksumAddress(address) {
      if (!(0, bytes_1.isHexString)(address, 20)) {
        logger19.throwArgumentError("invalid address", "address", address);
      }
      address = address.toLowerCase();
      var chars = address.substring(2).split("");
      var expanded = new Uint8Array(40);
      for (var i11 = 0; i11 < 40; i11++) {
        expanded[i11] = chars[i11].charCodeAt(0);
      }
      var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
      for (var i11 = 0; i11 < 40; i11 += 2) {
        if (hashed[i11 >> 1] >> 4 >= 8) {
          chars[i11] = chars[i11].toUpperCase();
        }
        if ((hashed[i11 >> 1] & 15) >= 8) {
          chars[i11 + 1] = chars[i11 + 1].toUpperCase();
        }
      }
      return "0x" + chars.join("");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function log10(x8) {
      if (Math.log10) {
        return Math.log10(x8);
      }
      return Math.log(x8) / Math.LN10;
    }
    var ibanLookup = {};
    for (i10 = 0; i10 < 10; i10++) {
      ibanLookup[String(i10)] = String(i10);
    }
    var i10;
    for (i10 = 0; i10 < 26; i10++) {
      ibanLookup[String.fromCharCode(65 + i10)] = String(10 + i10);
    }
    var i10;
    var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
    function ibanChecksum(address) {
      address = address.toUpperCase();
      address = address.substring(4) + address.substring(0, 2) + "00";
      var expanded = address.split("").map(function(c8) {
        return ibanLookup[c8];
      }).join("");
      while (expanded.length >= safeDigits) {
        var block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
      }
      var checksum = String(98 - parseInt(expanded, 10) % 97);
      while (checksum.length < 2) {
        checksum = "0" + checksum;
      }
      return checksum;
    }
    function getAddress8(address) {
      var result = null;
      if (typeof address !== "string") {
        logger19.throwArgumentError("invalid address", "address", address);
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        if (address.substring(0, 2) !== "0x") {
          address = "0x" + address;
        }
        result = getChecksumAddress(address);
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
          logger19.throwArgumentError("bad address checksum", "address", address);
        }
      } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        if (address.substring(2, 4) !== ibanChecksum(address)) {
          logger19.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0, bignumber_1._base36To16)(address.substring(4));
        while (result.length < 40) {
          result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
      } else {
        logger19.throwArgumentError("invalid address", "address", address);
      }
      return result;
    }
    exports.getAddress = getAddress8;
    function isAddress3(address) {
      try {
        getAddress8(address);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isAddress = isAddress3;
    function getIcapAddress2(address) {
      var base362 = (0, bignumber_1._base16To36)(getAddress8(address).substring(2)).toUpperCase();
      while (base362.length < 30) {
        base362 = "0" + base362;
      }
      return "XE" + ibanChecksum("XE00" + base362) + base362;
    }
    exports.getIcapAddress = getIcapAddress2;
    function getContractAddress4(transaction) {
      var from3 = null;
      try {
        from3 = getAddress8(transaction.from);
      } catch (error) {
        logger19.throwArgumentError("missing from address", "transaction", transaction);
      }
      var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
      return getAddress8((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from3, nonce])), 12));
    }
    exports.getContractAddress = getContractAddress4;
    function getCreate2Address2(from3, salt, initCodeHash) {
      if ((0, bytes_1.hexDataLength)(salt) !== 32) {
        logger19.throwArgumentError("salt must be 32 bytes", "salt", salt);
      }
      if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
        logger19.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
      }
      return getAddress8((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress8(from3), salt, initCodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address2;
  }
});

// node_modules/@ethersproject/abi/lib/coders/address.js
var require_address = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/address.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressCoder = void 0;
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var AddressCoder = (
      /** @class */
      function(_super) {
        __extends2(AddressCoder2, _super);
        function AddressCoder2(localName) {
          return _super.call(this, "address", "address", localName, false) || this;
        }
        AddressCoder2.prototype.defaultValue = function() {
          return "0x0000000000000000000000000000000000000000";
        };
        AddressCoder2.prototype.encode = function(writer, value) {
          try {
            value = (0, address_1.getAddress)(value);
          } catch (error) {
            this._throwError(error.message, value);
          }
          return writer.writeValue(value);
        };
        AddressCoder2.prototype.decode = function(reader) {
          return (0, address_1.getAddress)((0, bytes_1.hexZeroPad)(reader.readValue().toHexString(), 20));
        };
        return AddressCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.AddressCoder = AddressCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/anonymous.js
var require_anonymous = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/anonymous.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var AnonymousCoder = (
      /** @class */
      function(_super) {
        __extends2(AnonymousCoder2, _super);
        function AnonymousCoder2(coder) {
          var _this = _super.call(this, coder.name, coder.type, void 0, coder.dynamic) || this;
          _this.coder = coder;
          return _this;
        }
        AnonymousCoder2.prototype.defaultValue = function() {
          return this.coder.defaultValue();
        };
        AnonymousCoder2.prototype.encode = function(writer, value) {
          return this.coder.encode(writer, value);
        };
        AnonymousCoder2.prototype.decode = function(reader) {
          return this.coder.decode(reader);
        };
        return AnonymousCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.AnonymousCoder = AnonymousCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/array.js
var require_array = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/array.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCoder = exports.unpack = exports.pack = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger19 = new logger_1.Logger(_version_1.version);
    var abstract_coder_1 = require_abstract_coder();
    var anonymous_1 = require_anonymous();
    function pack(writer, coders, values) {
      var arrayValues = null;
      if (Array.isArray(values)) {
        arrayValues = values;
      } else if (values && typeof values === "object") {
        var unique_1 = {};
        arrayValues = coders.map(function(coder) {
          var name2 = coder.localName;
          if (!name2) {
            logger19.throwError("cannot encode object for signature with missing names", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder,
              value: values
            });
          }
          if (unique_1[name2]) {
            logger19.throwError("cannot encode object for signature with duplicate names", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder,
              value: values
            });
          }
          unique_1[name2] = true;
          return values[name2];
        });
      } else {
        logger19.throwArgumentError("invalid tuple value", "tuple", values);
      }
      if (coders.length !== arrayValues.length) {
        logger19.throwArgumentError("types/value length mismatch", "tuple", values);
      }
      var staticWriter = new abstract_coder_1.Writer(writer.wordSize);
      var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);
      var updateFuncs = [];
      coders.forEach(function(coder, index) {
        var value = arrayValues[index];
        if (coder.dynamic) {
          var dynamicOffset_1 = dynamicWriter.length;
          coder.encode(dynamicWriter, value);
          var updateFunc_1 = staticWriter.writeUpdatableValue();
          updateFuncs.push(function(baseOffset) {
            updateFunc_1(baseOffset + dynamicOffset_1);
          });
        } else {
          coder.encode(staticWriter, value);
        }
      });
      updateFuncs.forEach(function(func) {
        func(staticWriter.length);
      });
      var length2 = writer.appendWriter(staticWriter);
      length2 += writer.appendWriter(dynamicWriter);
      return length2;
    }
    exports.pack = pack;
    function unpack(reader, coders) {
      var values = [];
      var baseReader = reader.subReader(0);
      coders.forEach(function(coder) {
        var value = null;
        if (coder.dynamic) {
          var offset = reader.readValue();
          var offsetReader = baseReader.subReader(offset.toNumber());
          try {
            value = coder.decode(offsetReader);
          } catch (error) {
            if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        } else {
          try {
            value = coder.decode(reader);
          } catch (error) {
            if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        }
        if (value != void 0) {
          values.push(value);
        }
      });
      var uniqueNames = coders.reduce(function(accum, coder) {
        var name2 = coder.localName;
        if (name2) {
          if (!accum[name2]) {
            accum[name2] = 0;
          }
          accum[name2]++;
        }
        return accum;
      }, {});
      coders.forEach(function(coder, index) {
        var name2 = coder.localName;
        if (!name2 || uniqueNames[name2] !== 1) {
          return;
        }
        if (name2 === "length") {
          name2 = "_length";
        }
        if (values[name2] != null) {
          return;
        }
        var value = values[index];
        if (value instanceof Error) {
          Object.defineProperty(values, name2, {
            enumerable: true,
            get: function() {
              throw value;
            }
          });
        } else {
          values[name2] = value;
        }
      });
      var _loop_1 = function(i11) {
        var value = values[i11];
        if (value instanceof Error) {
          Object.defineProperty(values, i11, {
            enumerable: true,
            get: function() {
              throw value;
            }
          });
        }
      };
      for (var i10 = 0; i10 < values.length; i10++) {
        _loop_1(i10);
      }
      return Object.freeze(values);
    }
    exports.unpack = unpack;
    var ArrayCoder = (
      /** @class */
      function(_super) {
        __extends2(ArrayCoder2, _super);
        function ArrayCoder2(coder, length2, localName) {
          var _this = this;
          var type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
          var dynamic = length2 === -1 || coder.dynamic;
          _this = _super.call(this, "array", type, localName, dynamic) || this;
          _this.coder = coder;
          _this.length = length2;
          return _this;
        }
        ArrayCoder2.prototype.defaultValue = function() {
          var defaultChild = this.coder.defaultValue();
          var result = [];
          for (var i10 = 0; i10 < this.length; i10++) {
            result.push(defaultChild);
          }
          return result;
        };
        ArrayCoder2.prototype.encode = function(writer, value) {
          if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
          }
          var count = this.length;
          if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
          }
          logger19.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
          var coders = [];
          for (var i10 = 0; i10 < value.length; i10++) {
            coders.push(this.coder);
          }
          return pack(writer, coders, value);
        };
        ArrayCoder2.prototype.decode = function(reader) {
          var count = this.length;
          if (count === -1) {
            count = reader.readValue().toNumber();
            if (count * 32 > reader._data.length) {
              logger19.throwError("insufficient data length", logger_1.Logger.errors.BUFFER_OVERRUN, {
                length: reader._data.length,
                count
              });
            }
          }
          var coders = [];
          for (var i10 = 0; i10 < count; i10++) {
            coders.push(new anonymous_1.AnonymousCoder(this.coder));
          }
          return reader.coerce(this.name, unpack(reader, coders));
        };
        return ArrayCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.ArrayCoder = ArrayCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/boolean.js
var require_boolean = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/boolean.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var BooleanCoder = (
      /** @class */
      function(_super) {
        __extends2(BooleanCoder2, _super);
        function BooleanCoder2(localName) {
          return _super.call(this, "bool", "bool", localName, false) || this;
        }
        BooleanCoder2.prototype.defaultValue = function() {
          return false;
        };
        BooleanCoder2.prototype.encode = function(writer, value) {
          return writer.writeValue(value ? 1 : 0);
        };
        BooleanCoder2.prototype.decode = function(reader) {
          return reader.coerce(this.type, !reader.readValue().isZero());
        };
        return BooleanCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.BooleanCoder = BooleanCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/bytes.js
var require_bytes = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/bytes.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesCoder = exports.DynamicBytesCoder = void 0;
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var DynamicBytesCoder = (
      /** @class */
      function(_super) {
        __extends2(DynamicBytesCoder2, _super);
        function DynamicBytesCoder2(type, localName) {
          return _super.call(this, type, type, localName, true) || this;
        }
        DynamicBytesCoder2.prototype.defaultValue = function() {
          return "0x";
        };
        DynamicBytesCoder2.prototype.encode = function(writer, value) {
          value = (0, bytes_1.arrayify)(value);
          var length2 = writer.writeValue(value.length);
          length2 += writer.writeBytes(value);
          return length2;
        };
        DynamicBytesCoder2.prototype.decode = function(reader) {
          return reader.readBytes(reader.readValue().toNumber(), true);
        };
        return DynamicBytesCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.DynamicBytesCoder = DynamicBytesCoder;
    var BytesCoder = (
      /** @class */
      function(_super) {
        __extends2(BytesCoder2, _super);
        function BytesCoder2(localName) {
          return _super.call(this, "bytes", localName) || this;
        }
        BytesCoder2.prototype.decode = function(reader) {
          return reader.coerce(this.name, (0, bytes_1.hexlify)(_super.prototype.decode.call(this, reader)));
        };
        return BytesCoder2;
      }(DynamicBytesCoder)
    );
    exports.BytesCoder = BytesCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js
var require_fixed_bytes = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedBytesCoder = void 0;
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var FixedBytesCoder = (
      /** @class */
      function(_super) {
        __extends2(FixedBytesCoder2, _super);
        function FixedBytesCoder2(size, localName) {
          var _this = this;
          var name2 = "bytes" + String(size);
          _this = _super.call(this, name2, name2, localName, false) || this;
          _this.size = size;
          return _this;
        }
        FixedBytesCoder2.prototype.defaultValue = function() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
        };
        FixedBytesCoder2.prototype.encode = function(writer, value) {
          var data2 = (0, bytes_1.arrayify)(value);
          if (data2.length !== this.size) {
            this._throwError("incorrect data length", value);
          }
          return writer.writeBytes(data2);
        };
        FixedBytesCoder2.prototype.decode = function(reader) {
          return reader.coerce(this.name, (0, bytes_1.hexlify)(reader.readBytes(this.size)));
        };
        return FixedBytesCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.FixedBytesCoder = FixedBytesCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/null.js
var require_null = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/null.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var NullCoder = (
      /** @class */
      function(_super) {
        __extends2(NullCoder2, _super);
        function NullCoder2(localName) {
          return _super.call(this, "null", "", localName, false) || this;
        }
        NullCoder2.prototype.defaultValue = function() {
          return null;
        };
        NullCoder2.prototype.encode = function(writer, value) {
          if (value != null) {
            this._throwError("not null", value);
          }
          return writer.writeBytes([]);
        };
        NullCoder2.prototype.decode = function(reader) {
          reader.readBytes(0);
          return reader.coerce(this.name, null);
        };
        return NullCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.NullCoder = NullCoder;
  }
});

// node_modules/@ethersproject/constants/lib/addresses.js
var require_addresses = __commonJS({
  "node_modules/@ethersproject/constants/lib/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressZero = void 0;
    exports.AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib/bignumbers.js
var require_bignumbers = __commonJS({
  "node_modules/@ethersproject/constants/lib/bignumbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
    var bignumber_1 = require_lib3();
    var NegativeOne = /* @__PURE__ */ bignumber_1.BigNumber.from(-1);
    exports.NegativeOne = NegativeOne;
    var Zero = /* @__PURE__ */ bignumber_1.BigNumber.from(0);
    exports.Zero = Zero;
    var One = /* @__PURE__ */ bignumber_1.BigNumber.from(1);
    exports.One = One;
    var Two = /* @__PURE__ */ bignumber_1.BigNumber.from(2);
    exports.Two = Two;
    var WeiPerEther = /* @__PURE__ */ bignumber_1.BigNumber.from("1000000000000000000");
    exports.WeiPerEther = WeiPerEther;
    var MaxUint256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxUint256 = MaxUint256;
    var MinInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    exports.MinInt256 = MinInt256;
    var MaxInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxInt256 = MaxInt256;
  }
});

// node_modules/@ethersproject/constants/lib/hashes.js
var require_hashes = __commonJS({
  "node_modules/@ethersproject/constants/lib/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashZero = void 0;
    exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib/strings.js
var require_strings = __commonJS({
  "node_modules/@ethersproject/constants/lib/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = void 0;
    exports.EtherSymbol = "\u039E";
  }
});

// node_modules/@ethersproject/constants/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@ethersproject/constants/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "AddressZero", { enumerable: true, get: function() {
      return addresses_1.AddressZero;
    } });
    var bignumbers_1 = require_bignumbers();
    Object.defineProperty(exports, "NegativeOne", { enumerable: true, get: function() {
      return bignumbers_1.NegativeOne;
    } });
    Object.defineProperty(exports, "Zero", { enumerable: true, get: function() {
      return bignumbers_1.Zero;
    } });
    Object.defineProperty(exports, "One", { enumerable: true, get: function() {
      return bignumbers_1.One;
    } });
    Object.defineProperty(exports, "Two", { enumerable: true, get: function() {
      return bignumbers_1.Two;
    } });
    Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
      return bignumbers_1.WeiPerEther;
    } });
    Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
      return bignumbers_1.MaxUint256;
    } });
    Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
      return bignumbers_1.MinInt256;
    } });
    Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
      return bignumbers_1.MaxInt256;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "HashZero", { enumerable: true, get: function() {
      return hashes_1.HashZero;
    } });
    var strings_1 = require_strings();
    Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
      return strings_1.EtherSymbol;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/coders/number.js
var require_number = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/number.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumberCoder = void 0;
    var bignumber_1 = require_lib3();
    var constants_1 = require_lib8();
    var abstract_coder_1 = require_abstract_coder();
    var NumberCoder = (
      /** @class */
      function(_super) {
        __extends2(NumberCoder2, _super);
        function NumberCoder2(size, signed, localName) {
          var _this = this;
          var name2 = (signed ? "int" : "uint") + size * 8;
          _this = _super.call(this, name2, name2, localName, false) || this;
          _this.size = size;
          _this.signed = signed;
          return _this;
        }
        NumberCoder2.prototype.defaultValue = function() {
          return 0;
        };
        NumberCoder2.prototype.encode = function(writer, value) {
          var v7 = bignumber_1.BigNumber.from(value);
          var maxUintValue = constants_1.MaxUint256.mask(writer.wordSize * 8);
          if (this.signed) {
            var bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v7.gt(bounds) || v7.lt(bounds.add(constants_1.One).mul(constants_1.NegativeOne))) {
              this._throwError("value out-of-bounds", value);
            }
          } else if (v7.lt(constants_1.Zero) || v7.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
          }
          v7 = v7.toTwos(this.size * 8).mask(this.size * 8);
          if (this.signed) {
            v7 = v7.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
          }
          return writer.writeValue(v7);
        };
        NumberCoder2.prototype.decode = function(reader) {
          var value = reader.readValue().mask(this.size * 8);
          if (this.signed) {
            value = value.fromTwos(this.size * 8);
          }
          return reader.coerce(this.name, value);
        };
        return NumberCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.NumberCoder = NumberCoder;
  }
});

// node_modules/@ethersproject/strings/lib/_version.js
var require_version8 = __commonJS({
  "node_modules/@ethersproject/strings/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "strings/5.7.0";
  }
});

// node_modules/@ethersproject/strings/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@ethersproject/strings/lib/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version8();
    var logger19 = new logger_1.Logger(_version_1.version);
    var UnicodeNormalizationForm2;
    (function(UnicodeNormalizationForm3) {
      UnicodeNormalizationForm3["current"] = "";
      UnicodeNormalizationForm3["NFC"] = "NFC";
      UnicodeNormalizationForm3["NFD"] = "NFD";
      UnicodeNormalizationForm3["NFKC"] = "NFKC";
      UnicodeNormalizationForm3["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm2 = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
    var Utf8ErrorReason2;
    (function(Utf8ErrorReason3) {
      Utf8ErrorReason3["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason3["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason3["OVERRUN"] = "string overrun";
      Utf8ErrorReason3["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason3["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason3["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason3["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason2 = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
    function errorFunc(reason, offset, bytes, output, badCodepoint) {
      return logger19.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);
    }
    function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
        var i10 = 0;
        for (var o11 = offset + 1; o11 < bytes.length; o11++) {
          if (bytes[o11] >> 6 !== 2) {
            break;
          }
          i10++;
        }
        return i10;
      }
      if (reason === Utf8ErrorReason2.OVERRUN) {
        return bytes.length - offset - 1;
      }
      return 0;
    }
    function replaceFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === Utf8ErrorReason2.OVERLONG) {
        output.push(badCodepoint);
        return 0;
      }
      output.push(65533);
      return ignoreFunc(reason, offset, bytes, output, badCodepoint);
    }
    exports.Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
    function getUtf8CodePoints(bytes, onError) {
      if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
      }
      bytes = (0, bytes_1.arrayify)(bytes);
      var result = [];
      var i10 = 0;
      while (i10 < bytes.length) {
        var c8 = bytes[i10++];
        if (c8 >> 7 === 0) {
          result.push(c8);
          continue;
        }
        var extraLength = null;
        var overlongMask = null;
        if ((c8 & 224) === 192) {
          extraLength = 1;
          overlongMask = 127;
        } else if ((c8 & 240) === 224) {
          extraLength = 2;
          overlongMask = 2047;
        } else if ((c8 & 248) === 240) {
          extraLength = 3;
          overlongMask = 65535;
        } else {
          if ((c8 & 192) === 128) {
            i10 += onError(Utf8ErrorReason2.UNEXPECTED_CONTINUE, i10 - 1, bytes, result);
          } else {
            i10 += onError(Utf8ErrorReason2.BAD_PREFIX, i10 - 1, bytes, result);
          }
          continue;
        }
        if (i10 - 1 + extraLength >= bytes.length) {
          i10 += onError(Utf8ErrorReason2.OVERRUN, i10 - 1, bytes, result);
          continue;
        }
        var res = c8 & (1 << 8 - extraLength - 1) - 1;
        for (var j8 = 0; j8 < extraLength; j8++) {
          var nextChar = bytes[i10];
          if ((nextChar & 192) != 128) {
            i10 += onError(Utf8ErrorReason2.MISSING_CONTINUE, i10, bytes, result);
            res = null;
            break;
          }
          ;
          res = res << 6 | nextChar & 63;
          i10++;
        }
        if (res === null) {
          continue;
        }
        if (res > 1114111) {
          i10 += onError(Utf8ErrorReason2.OUT_OF_RANGE, i10 - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res >= 55296 && res <= 57343) {
          i10 += onError(Utf8ErrorReason2.UTF16_SURROGATE, i10 - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res <= overlongMask) {
          i10 += onError(Utf8ErrorReason2.OVERLONG, i10 - 1 - extraLength, bytes, result, res);
          continue;
        }
        result.push(res);
      }
      return result;
    }
    function toUtf8Bytes4(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm2.current;
      }
      if (form != UnicodeNormalizationForm2.current) {
        logger19.checkNormalize();
        str = str.normalize(form);
      }
      var result = [];
      for (var i10 = 0; i10 < str.length; i10++) {
        var c8 = str.charCodeAt(i10);
        if (c8 < 128) {
          result.push(c8);
        } else if (c8 < 2048) {
          result.push(c8 >> 6 | 192);
          result.push(c8 & 63 | 128);
        } else if ((c8 & 64512) == 55296) {
          i10++;
          var c22 = str.charCodeAt(i10);
          if (i10 >= str.length || (c22 & 64512) !== 56320) {
            throw new Error("invalid utf-8 string");
          }
          var pair = 65536 + ((c8 & 1023) << 10) + (c22 & 1023);
          result.push(pair >> 18 | 240);
          result.push(pair >> 12 & 63 | 128);
          result.push(pair >> 6 & 63 | 128);
          result.push(pair & 63 | 128);
        } else {
          result.push(c8 >> 12 | 224);
          result.push(c8 >> 6 & 63 | 128);
          result.push(c8 & 63 | 128);
        }
      }
      return (0, bytes_1.arrayify)(result);
    }
    exports.toUtf8Bytes = toUtf8Bytes4;
    function escapeChar(value) {
      var hex = "0000" + value.toString(16);
      return "\\u" + hex.substring(hex.length - 4);
    }
    function _toEscapedUtf8String2(bytes, onError) {
      return '"' + getUtf8CodePoints(bytes, onError).map(function(codePoint) {
        if (codePoint < 256) {
          switch (codePoint) {
            case 8:
              return "\\b";
            case 9:
              return "\\t";
            case 10:
              return "\\n";
            case 13:
              return "\\r";
            case 34:
              return '\\"';
            case 92:
              return "\\\\";
          }
          if (codePoint >= 32 && codePoint < 127) {
            return String.fromCharCode(codePoint);
          }
        }
        if (codePoint <= 65535) {
          return escapeChar(codePoint);
        }
        codePoint -= 65536;
        return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
      }).join("") + '"';
    }
    exports._toEscapedUtf8String = _toEscapedUtf8String2;
    function _toUtf8String(codePoints) {
      return codePoints.map(function(codePoint) {
        if (codePoint <= 65535) {
          return String.fromCharCode(codePoint);
        }
        codePoint -= 65536;
        return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
      }).join("");
    }
    exports._toUtf8String = _toUtf8String;
    function toUtf8String3(bytes, onError) {
      return _toUtf8String(getUtf8CodePoints(bytes, onError));
    }
    exports.toUtf8String = toUtf8String3;
    function toUtf8CodePoints2(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm2.current;
      }
      return getUtf8CodePoints(toUtf8Bytes4(str, form));
    }
    exports.toUtf8CodePoints = toUtf8CodePoints2;
  }
});

// node_modules/@ethersproject/strings/lib/bytes32.js
var require_bytes32 = __commonJS({
  "node_modules/@ethersproject/strings/lib/bytes32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBytes32String = exports.formatBytes32String = void 0;
    var constants_1 = require_lib8();
    var bytes_1 = require_lib2();
    var utf8_1 = require_utf8();
    function formatBytes32String2(text) {
      var bytes = (0, utf8_1.toUtf8Bytes)(text);
      if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
      }
      return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));
    }
    exports.formatBytes32String = formatBytes32String2;
    function parseBytes32String4(bytes) {
      var data2 = (0, bytes_1.arrayify)(bytes);
      if (data2.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
      }
      if (data2[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
      }
      var length2 = 31;
      while (data2[length2 - 1] === 0) {
        length2--;
      }
      return (0, utf8_1.toUtf8String)(data2.slice(0, length2));
    }
    exports.parseBytes32String = parseBytes32String4;
  }
});

// node_modules/@ethersproject/strings/lib/idna.js
var require_idna = __commonJS({
  "node_modules/@ethersproject/strings/lib/idna.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;
    var utf8_1 = require_utf8();
    function bytes2(data2) {
      if (data2.length % 4 !== 0) {
        throw new Error("bad data");
      }
      var result = [];
      for (var i10 = 0; i10 < data2.length; i10 += 4) {
        result.push(parseInt(data2.substring(i10, i10 + 4), 16));
      }
      return result;
    }
    function createTable(data2, func) {
      if (!func) {
        func = function(value) {
          return [parseInt(value, 16)];
        };
      }
      var lo2 = 0;
      var result = {};
      data2.split(",").forEach(function(pair) {
        var comps = pair.split(":");
        lo2 += parseInt(comps[0], 16);
        result[lo2] = func(comps[1]);
      });
      return result;
    }
    function createRangeTable(data2) {
      var hi = 0;
      return data2.split(",").map(function(v7) {
        var comps = v7.split("-");
        if (comps.length === 1) {
          comps[1] = "0";
        } else if (comps[1] === "") {
          comps[1] = "1";
        }
        var lo2 = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo2, h: hi };
      });
    }
    function matchMap(value, ranges) {
      var lo2 = 0;
      for (var i10 = 0; i10 < ranges.length; i10++) {
        var range = ranges[i10];
        lo2 += range.l;
        if (value >= lo2 && value <= lo2 + range.h && (value - lo2) % (range.d || 1) === 0) {
          if (range.e && range.e.indexOf(value - lo2) !== -1) {
            continue;
          }
          return range;
        }
      }
      return null;
    }
    var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function(v7) {
      return parseInt(v7, 16);
    });
    var Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
    function flatten(values) {
      return values.reduce(function(accum, value) {
        value.forEach(function(value2) {
          accum.push(value2);
        });
        return accum;
      }, []);
    }
    function _nameprepTableA1(codepoint) {
      return !!matchMap(codepoint, Table_A_1_ranges);
    }
    exports._nameprepTableA1 = _nameprepTableA1;
    function _nameprepTableB2(codepoint) {
      var range = matchMap(codepoint, Table_B_2_ranges);
      if (range) {
        return [codepoint + range.s];
      }
      var codes = Table_B_2_lut_abs[codepoint];
      if (codes) {
        return codes;
      }
      var shift = Table_B_2_lut_rel[codepoint];
      if (shift) {
        return [codepoint + shift[0]];
      }
      var complex = Table_B_2_complex[codepoint];
      if (complex) {
        return complex;
      }
      return null;
    }
    exports._nameprepTableB2 = _nameprepTableB2;
    function _nameprepTableC(codepoint) {
      return !!matchMap(codepoint, Table_C_ranges);
    }
    exports._nameprepTableC = _nameprepTableC;
    function nameprep2(value) {
      if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
      }
      var codes = (0, utf8_1.toUtf8CodePoints)(value);
      codes = flatten(codes.map(function(code2) {
        if (Table_B_1_flags.indexOf(code2) >= 0) {
          return [];
        }
        if (code2 >= 65024 && code2 <= 65039) {
          return [];
        }
        var codesTableB2 = _nameprepTableB2(code2);
        if (codesTableB2) {
          return codesTableB2;
        }
        return [code2];
      }));
      codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
      codes.forEach(function(code2) {
        if (_nameprepTableC(code2)) {
          throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
      });
      codes.forEach(function(code2) {
        if (_nameprepTableA1(code2)) {
          throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
      });
      var name2 = (0, utf8_1._toUtf8String)(codes);
      if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
        throw new Error("invalid hyphen");
      }
      return name2;
    }
    exports.nameprep = nameprep2;
  }
});

// node_modules/@ethersproject/strings/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@ethersproject/strings/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;
    var bytes32_1 = require_bytes32();
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return bytes32_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return bytes32_1.parseBytes32String;
    } });
    var idna_1 = require_idna();
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return idna_1.nameprep;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return utf8_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return utf8_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return utf8_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return utf8_1.toUtf8String;
    } });
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return utf8_1.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorFuncs;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorReason;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/coders/string.js
var require_string = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/string.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringCoder = void 0;
    var strings_1 = require_lib9();
    var bytes_1 = require_bytes();
    var StringCoder = (
      /** @class */
      function(_super) {
        __extends2(StringCoder2, _super);
        function StringCoder2(localName) {
          return _super.call(this, "string", localName) || this;
        }
        StringCoder2.prototype.defaultValue = function() {
          return "";
        };
        StringCoder2.prototype.encode = function(writer, value) {
          return _super.prototype.encode.call(this, writer, (0, strings_1.toUtf8Bytes)(value));
        };
        StringCoder2.prototype.decode = function(reader) {
          return (0, strings_1.toUtf8String)(_super.prototype.decode.call(this, reader));
        };
        return StringCoder2;
      }(bytes_1.DynamicBytesCoder)
    );
    exports.StringCoder = StringCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/tuple.js
var require_tuple = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/tuple.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var array_1 = require_array();
    var TupleCoder = (
      /** @class */
      function(_super) {
        __extends2(TupleCoder2, _super);
        function TupleCoder2(coders, localName) {
          var _this = this;
          var dynamic = false;
          var types = [];
          coders.forEach(function(coder) {
            if (coder.dynamic) {
              dynamic = true;
            }
            types.push(coder.type);
          });
          var type = "tuple(" + types.join(",") + ")";
          _this = _super.call(this, "tuple", type, localName, dynamic) || this;
          _this.coders = coders;
          return _this;
        }
        TupleCoder2.prototype.defaultValue = function() {
          var values = [];
          this.coders.forEach(function(coder) {
            values.push(coder.defaultValue());
          });
          var uniqueNames = this.coders.reduce(function(accum, coder) {
            var name2 = coder.localName;
            if (name2) {
              if (!accum[name2]) {
                accum[name2] = 0;
              }
              accum[name2]++;
            }
            return accum;
          }, {});
          this.coders.forEach(function(coder, index) {
            var name2 = coder.localName;
            if (!name2 || uniqueNames[name2] !== 1) {
              return;
            }
            if (name2 === "length") {
              name2 = "_length";
            }
            if (values[name2] != null) {
              return;
            }
            values[name2] = values[index];
          });
          return Object.freeze(values);
        };
        TupleCoder2.prototype.encode = function(writer, value) {
          return (0, array_1.pack)(writer, this.coders, value);
        };
        TupleCoder2.prototype.decode = function(reader) {
          return reader.coerce(this.name, (0, array_1.unpack)(reader, this.coders));
        };
        return TupleCoder2;
      }(abstract_coder_1.Coder)
    );
    exports.TupleCoder = TupleCoder;
  }
});

// node_modules/@ethersproject/abi/lib/abi-coder.js
var require_abi_coder = __commonJS({
  "node_modules/@ethersproject/abi/lib/abi-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultAbiCoder = exports.AbiCoder = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger19 = new logger_1.Logger(_version_1.version);
    var abstract_coder_1 = require_abstract_coder();
    var address_1 = require_address();
    var array_1 = require_array();
    var boolean_1 = require_boolean();
    var bytes_2 = require_bytes();
    var fixed_bytes_1 = require_fixed_bytes();
    var null_1 = require_null();
    var number_1 = require_number();
    var string_1 = require_string();
    var tuple_1 = require_tuple();
    var fragments_1 = require_fragments();
    var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    var AbiCoder2 = (
      /** @class */
      function() {
        function AbiCoder3(coerceFunc) {
          (0, properties_1.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
        }
        AbiCoder3.prototype._getCoder = function(param) {
          var _this = this;
          switch (param.baseType) {
            case "address":
              return new address_1.AddressCoder(param.name);
            case "bool":
              return new boolean_1.BooleanCoder(param.name);
            case "string":
              return new string_1.StringCoder(param.name);
            case "bytes":
              return new bytes_2.BytesCoder(param.name);
            case "array":
              return new array_1.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
              return new tuple_1.TupleCoder((param.components || []).map(function(component) {
                return _this._getCoder(component);
              }), param.name);
            case "":
              return new null_1.NullCoder(param.name);
          }
          var match = param.type.match(paramTypeNumber);
          if (match) {
            var size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || size % 8 !== 0) {
              logger19.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new number_1.NumberCoder(size / 8, match[1] === "int", param.name);
          }
          match = param.type.match(paramTypeBytes);
          if (match) {
            var size = parseInt(match[1]);
            if (size === 0 || size > 32) {
              logger19.throwArgumentError("invalid bytes length", "param", param);
            }
            return new fixed_bytes_1.FixedBytesCoder(size, param.name);
          }
          return logger19.throwArgumentError("invalid type", "type", param.type);
        };
        AbiCoder3.prototype._getWordSize = function() {
          return 32;
        };
        AbiCoder3.prototype._getReader = function(data2, allowLoose) {
          return new abstract_coder_1.Reader(data2, this._getWordSize(), this.coerceFunc, allowLoose);
        };
        AbiCoder3.prototype._getWriter = function() {
          return new abstract_coder_1.Writer(this._getWordSize());
        };
        AbiCoder3.prototype.getDefaultValue = function(types) {
          var _this = this;
          var coders = types.map(function(type) {
            return _this._getCoder(fragments_1.ParamType.from(type));
          });
          var coder = new tuple_1.TupleCoder(coders, "_");
          return coder.defaultValue();
        };
        AbiCoder3.prototype.encode = function(types, values) {
          var _this = this;
          if (types.length !== values.length) {
            logger19.throwError("types/values length mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
              count: { types: types.length, values: values.length },
              value: { types, values }
            });
          }
          var coders = types.map(function(type) {
            return _this._getCoder(fragments_1.ParamType.from(type));
          });
          var coder = new tuple_1.TupleCoder(coders, "_");
          var writer = this._getWriter();
          coder.encode(writer, values);
          return writer.data;
        };
        AbiCoder3.prototype.decode = function(types, data2, loose) {
          var _this = this;
          var coders = types.map(function(type) {
            return _this._getCoder(fragments_1.ParamType.from(type));
          });
          var coder = new tuple_1.TupleCoder(coders, "_");
          return coder.decode(this._getReader((0, bytes_1.arrayify)(data2), loose));
        };
        return AbiCoder3;
      }()
    );
    exports.AbiCoder = AbiCoder2;
    exports.defaultAbiCoder = new AbiCoder2();
  }
});

// node_modules/@ethersproject/hash/lib/id.js
var require_id = __commonJS({
  "node_modules/@ethersproject/hash/lib/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var keccak256_1 = require_lib5();
    var strings_1 = require_lib9();
    function id2(text) {
      return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
    }
    exports.id = id2;
  }
});

// node_modules/@ethersproject/hash/lib/_version.js
var require_version9 = __commonJS({
  "node_modules/@ethersproject/hash/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "hash/5.7.0";
  }
});

// node_modules/@ethersproject/base64/lib/browser-base64.js
var require_browser_base64 = __commonJS({
  "node_modules/@ethersproject/base64/lib/browser-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var bytes_1 = require_lib2();
    function decode6(textData) {
      textData = atob(textData);
      var data2 = [];
      for (var i10 = 0; i10 < textData.length; i10++) {
        data2.push(textData.charCodeAt(i10));
      }
      return (0, bytes_1.arrayify)(data2);
    }
    exports.decode = decode6;
    function encode5(data2) {
      data2 = (0, bytes_1.arrayify)(data2);
      var textData = "";
      for (var i10 = 0; i10 < data2.length; i10++) {
        textData += String.fromCharCode(data2[i10]);
      }
      return btoa(textData);
    }
    exports.encode = encode5;
  }
});

// node_modules/@ethersproject/base64/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@ethersproject/base64/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var base64_1 = require_browser_base64();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return base64_1.decode;
    } });
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return base64_1.encode;
    } });
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js
var require_decoder = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = void 0;
    function flat(array, depth) {
      if (depth == null) {
        depth = 1;
      }
      var result = [];
      var forEach = result.forEach;
      var flatDeep = function(arr, depth2) {
        forEach.call(arr, function(val) {
          if (depth2 > 0 && Array.isArray(val)) {
            flatDeep(val, depth2 - 1);
          } else {
            result.push(val);
          }
        });
      };
      flatDeep(array, depth);
      return result;
    }
    function fromEntries(array) {
      var result = {};
      for (var i10 = 0; i10 < array.length; i10++) {
        var value = array[i10];
        result[value[0]] = value[1];
      }
      return result;
    }
    function decode_arithmetic(bytes) {
      var pos = 0;
      function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
      }
      var symbol_count = u16();
      var total = 1;
      var acc = [0, 1];
      for (var i10 = 1; i10 < symbol_count; i10++) {
        acc.push(total += u16());
      }
      var skip = u16();
      var pos_payload = pos;
      pos += skip;
      var read_width = 0;
      var read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      var N16 = 31;
      var FULL = Math.pow(2, N16);
      var HALF = FULL >>> 1;
      var QRTR = HALF >> 1;
      var MASK = FULL - 1;
      var register = 0;
      for (var i10 = 0; i10 < N16; i10++)
        register = register << 1 | read_bit();
      var symbols = [];
      var low = 0;
      var range = FULL;
      while (true) {
        var value = Math.floor(((register - low + 1) * total - 1) / range);
        var start = 0;
        var end = symbol_count;
        while (end - start > 1) {
          var mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0)
          break;
        symbols.push(start);
        var a9 = low + Math.floor(range * acc[start] / total);
        var b10 = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a9 ^ b10) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a9 = a9 << 1 & MASK;
          b10 = b10 << 1 & MASK | 1;
        }
        while (a9 & ~b10 & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a9 = a9 << 1 ^ HALF;
          b10 = (b10 ^ HALF) << 1 | HALF | 1;
        }
        low = a9;
        range = 1 + b10 - a9;
      }
      var offset = symbol_count - 4;
      return symbols.map(function(x8) {
        switch (x8 - offset) {
          case 3:
            return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 2:
            return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 1:
            return offset + bytes[pos_payload++];
          default:
            return x8 - 1;
        }
      });
    }
    exports.decode_arithmetic = decode_arithmetic;
    function read_payload(v7) {
      var pos = 0;
      return function() {
        return v7[pos++];
      };
    }
    exports.read_payload = read_payload;
    function read_compressed_payload(bytes) {
      return read_payload(decode_arithmetic(bytes));
    }
    exports.read_compressed_payload = read_compressed_payload;
    function signed(i10) {
      return i10 & 1 ? ~i10 >> 1 : i10 >> 1;
    }
    exports.signed = signed;
    function read_counts(n8, next) {
      var v7 = Array(n8);
      for (var i10 = 0; i10 < n8; i10++)
        v7[i10] = 1 + next();
      return v7;
    }
    function read_ascending(n8, next) {
      var v7 = Array(n8);
      for (var i10 = 0, x8 = -1; i10 < n8; i10++)
        v7[i10] = x8 += 1 + next();
      return v7;
    }
    function read_deltas(n8, next) {
      var v7 = Array(n8);
      for (var i10 = 0, x8 = 0; i10 < n8; i10++)
        v7[i10] = x8 += signed(next());
      return v7;
    }
    function read_member_array(next, lookup) {
      var v7 = read_ascending(next(), next);
      var n8 = next();
      var vX = read_ascending(n8, next);
      var vN = read_counts(n8, next);
      for (var i10 = 0; i10 < n8; i10++) {
        for (var j8 = 0; j8 < vN[i10]; j8++) {
          v7.push(vX[i10] + j8);
        }
      }
      return lookup ? v7.map(function(x8) {
        return lookup[x8];
      }) : v7;
    }
    exports.read_member_array = read_member_array;
    function read_mapped_map(next) {
      var ret = [];
      while (true) {
        var w11 = next();
        if (w11 == 0)
          break;
        ret.push(read_linear_table(w11, next));
      }
      while (true) {
        var w11 = next() - 1;
        if (w11 < 0)
          break;
        ret.push(read_replacement_table(w11, next));
      }
      return fromEntries(flat(ret));
    }
    exports.read_mapped_map = read_mapped_map;
    function read_zero_terminated_array(next) {
      var v7 = [];
      while (true) {
        var i10 = next();
        if (i10 == 0)
          break;
        v7.push(i10);
      }
      return v7;
    }
    exports.read_zero_terminated_array = read_zero_terminated_array;
    function read_transposed(n8, w11, next) {
      var m11 = Array(n8).fill(void 0).map(function() {
        return [];
      });
      for (var i10 = 0; i10 < w11; i10++) {
        read_deltas(n8, next).forEach(function(x8, j8) {
          return m11[j8].push(x8);
        });
      }
      return m11;
    }
    function read_linear_table(w11, next) {
      var dx = 1 + next();
      var dy = next();
      var vN = read_zero_terminated_array(next);
      var m11 = read_transposed(vN.length, 1 + w11, next);
      return flat(m11.map(function(v7, i10) {
        var x8 = v7[0], ys2 = v7.slice(1);
        return Array(vN[i10]).fill(void 0).map(function(_8, j8) {
          var j_dy = j8 * dy;
          return [x8 + j8 * dx, ys2.map(function(y10) {
            return y10 + j_dy;
          })];
        });
      }));
    }
    function read_replacement_table(w11, next) {
      var n8 = 1 + next();
      var m11 = read_transposed(n8, 1 + w11, next);
      return m11.map(function(v7) {
        return [v7[0], v7.slice(1)];
      });
    }
    function read_emoji_trie(next) {
      var sorted = read_member_array(next).sort(function(a9, b10) {
        return a9 - b10;
      });
      return read2();
      function read2() {
        var branches = [];
        while (true) {
          var keys = read_member_array(next, sorted);
          if (keys.length == 0)
            break;
          branches.push({ set: new Set(keys), node: read2() });
        }
        branches.sort(function(a9, b10) {
          return b10.set.size - a9.set.size;
        });
        var temp = next();
        var valid = temp % 3;
        temp = temp / 3 | 0;
        var fe0f = !!(temp & 1);
        temp >>= 1;
        var save = temp == 1;
        var check = temp == 2;
        return { branches, valid, fe0f, save, check };
      }
    }
    exports.read_emoji_trie = read_emoji_trie;
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/include.js
var require_include = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/include.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = void 0;
    var base64_1 = require_lib10();
    var decoder_js_1 = require_decoder();
    function getData() {
      return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
    }
    exports.getData = getData;
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/lib.js
var require_lib11 = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ens_normalize = exports.ens_normalize_post_check = void 0;
    var strings_1 = require_lib9();
    var include_js_1 = require_include();
    var r7 = (0, include_js_1.getData)();
    var decoder_js_1 = require_decoder();
    var VALID = new Set((0, decoder_js_1.read_member_array)(r7));
    var IGNORED = new Set((0, decoder_js_1.read_member_array)(r7));
    var MAPPED = (0, decoder_js_1.read_mapped_map)(r7);
    var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r7);
    var HYPHEN = 45;
    var UNDERSCORE = 95;
    function explode_cp(name2) {
      return (0, strings_1.toUtf8CodePoints)(name2);
    }
    function filter_fe0f(cps) {
      return cps.filter(function(cp) {
        return cp != 65039;
      });
    }
    function ens_normalize_post_check(name2) {
      for (var _i2 = 0, _a2 = name2.split("."); _i2 < _a2.length; _i2++) {
        var label = _a2[_i2];
        var cps = explode_cp(label);
        try {
          for (var i10 = cps.lastIndexOf(UNDERSCORE) - 1; i10 >= 0; i10--) {
            if (cps[i10] !== UNDERSCORE) {
              throw new Error("underscore only allowed at start");
            }
          }
          if (cps.length >= 4 && cps.every(function(cp) {
            return cp < 128;
          }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
            throw new Error("invalid label extension");
          }
        } catch (err) {
          throw new Error('Invalid label "' + label + '": ' + err.message);
        }
      }
      return name2;
    }
    exports.ens_normalize_post_check = ens_normalize_post_check;
    function ens_normalize(name2) {
      return ens_normalize_post_check(normalize(name2, filter_fe0f));
    }
    exports.ens_normalize = ens_normalize;
    function normalize(name2, emoji_filter) {
      var input = explode_cp(name2).reverse();
      var output = [];
      while (input.length) {
        var emoji = consume_emoji_reversed(input);
        if (emoji) {
          output.push.apply(output, emoji_filter(emoji));
          continue;
        }
        var cp = input.pop();
        if (VALID.has(cp)) {
          output.push(cp);
          continue;
        }
        if (IGNORED.has(cp)) {
          continue;
        }
        var cps = MAPPED[cp];
        if (cps) {
          output.push.apply(output, cps);
          continue;
        }
        throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
      }
      return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output)));
    }
    function nfc(s11) {
      return s11.normalize("NFC");
    }
    function consume_emoji_reversed(cps, eaten) {
      var _a2;
      var node = EMOJI_ROOT;
      var emoji;
      var saved;
      var stack = [];
      var pos = cps.length;
      if (eaten)
        eaten.length = 0;
      var _loop_1 = function() {
        var cp = cps[--pos];
        node = (_a2 = node.branches.find(function(x8) {
          return x8.set.has(cp);
        })) === null || _a2 === void 0 ? void 0 : _a2.node;
        if (!node)
          return "break";
        if (node.save) {
          saved = cp;
        } else if (node.check) {
          if (cp === saved)
            return "break";
        }
        stack.push(cp);
        if (node.fe0f) {
          stack.push(65039);
          if (pos > 0 && cps[pos - 1] == 65039)
            pos--;
        }
        if (node.valid) {
          emoji = stack.slice();
          if (node.valid == 2)
            emoji.splice(1, 1);
          if (eaten)
            eaten.push.apply(eaten, cps.slice(pos).reverse());
          cps.length = pos;
        }
      };
      while (pos) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
      return emoji;
    }
  }
});

// node_modules/@ethersproject/hash/lib/namehash.js
var require_namehash = __commonJS({
  "node_modules/@ethersproject/hash/lib/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    var keccak256_1 = require_lib5();
    var logger_1 = require_lib();
    var _version_1 = require_version9();
    var logger19 = new logger_1.Logger(_version_1.version);
    var lib_1 = require_lib11();
    var Zeros = new Uint8Array(32);
    Zeros.fill(0);
    function checkComponent(comp) {
      if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
      }
      return comp;
    }
    function ensNameSplit(name2) {
      var bytes = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name2));
      var comps = [];
      if (name2.length === 0) {
        return comps;
      }
      var last = 0;
      for (var i10 = 0; i10 < bytes.length; i10++) {
        var d9 = bytes[i10];
        if (d9 === 46) {
          comps.push(checkComponent(bytes.slice(last, i10)));
          last = i10 + 1;
        }
      }
      if (last >= bytes.length) {
        throw new Error("invalid ENS name; empty component");
      }
      comps.push(checkComponent(bytes.slice(last)));
      return comps;
    }
    function ensNormalize(name2) {
      return ensNameSplit(name2).map(function(comp) {
        return (0, strings_1.toUtf8String)(comp);
      }).join(".");
    }
    exports.ensNormalize = ensNormalize;
    function isValidName2(name2) {
      try {
        return ensNameSplit(name2).length !== 0;
      } catch (error) {
      }
      return false;
    }
    exports.isValidName = isValidName2;
    function namehash3(name2) {
      if (typeof name2 !== "string") {
        logger19.throwArgumentError("invalid ENS name; not a string", "name", name2);
      }
      var result = Zeros;
      var comps = ensNameSplit(name2);
      while (comps.length) {
        result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
      }
      return (0, bytes_1.hexlify)(result);
    }
    exports.namehash = namehash3;
    function dnsEncode3(name2) {
      return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name2).map(function(comp) {
        if (comp.length > 63) {
          throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        var bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
      }))) + "00";
    }
    exports.dnsEncode = dnsEncode3;
  }
});

// node_modules/@ethersproject/hash/lib/message.js
var require_message = __commonJS({
  "node_modules/@ethersproject/hash/lib/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = exports.messagePrefix = void 0;
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var strings_1 = require_lib9();
    exports.messagePrefix = "Ethereum Signed Message:\n";
    function hashMessage2(message) {
      if (typeof message === "string") {
        message = (0, strings_1.toUtf8Bytes)(message);
      }
      return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
        (0, strings_1.toUtf8Bytes)(exports.messagePrefix),
        (0, strings_1.toUtf8Bytes)(String(message.length)),
        message
      ]));
    }
    exports.hashMessage = hashMessage2;
  }
});

// node_modules/@ethersproject/hash/lib/typed-data.js
var require_typed_data = __commonJS({
  "node_modules/@ethersproject/hash/lib/typed-data.js"(exports) {
    "use strict";
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypedDataEncoder = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version9();
    var logger19 = new logger_1.Logger(_version_1.version);
    var id_1 = require_id();
    var padding = new Uint8Array(32);
    padding.fill(0);
    var NegativeOne = bignumber_1.BigNumber.from(-1);
    var Zero = bignumber_1.BigNumber.from(0);
    var One = bignumber_1.BigNumber.from(1);
    var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function hexPadRight(value) {
      var bytes = (0, bytes_1.arrayify)(value);
      var padOffset = bytes.length % 32;
      if (padOffset) {
        return (0, bytes_1.hexConcat)([bytes, padding.slice(padOffset)]);
      }
      return (0, bytes_1.hexlify)(bytes);
    }
    var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
    var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
    var domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    var domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    function checkString(key) {
      return function(value) {
        if (typeof value !== "string") {
          logger19.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
        }
        return value;
      };
    }
    var domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return bignumber_1.BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger19.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return (0, address_1.getAddress)(value).toLowerCase();
        } catch (error) {
        }
        return logger19.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          var bytes = (0, bytes_1.arrayify)(value);
          if (bytes.length !== 32) {
            throw new Error("bad length");
          }
          return (0, bytes_1.hexlify)(bytes);
        } catch (error) {
        }
        return logger19.throwArgumentError('invalid domain value "salt"', "domain.salt", value);
      }
    };
    function getBaseEncoder(type) {
      {
        var match = type.match(/^(u?)int(\d*)$/);
        if (match) {
          var signed = match[1] === "";
          var width = parseInt(match[2] || "256");
          if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
            logger19.throwArgumentError("invalid numeric width", "type", type);
          }
          var boundsUpper_1 = MaxUint256.mask(signed ? width - 1 : width);
          var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
          return function(value) {
            var v7 = bignumber_1.BigNumber.from(value);
            if (v7.lt(boundsLower_1) || v7.gt(boundsUpper_1)) {
              logger19.throwArgumentError("value out-of-bounds for " + type, "value", value);
            }
            return (0, bytes_1.hexZeroPad)(v7.toTwos(256).toHexString(), 32);
          };
        }
      }
      {
        var match = type.match(/^bytes(\d+)$/);
        if (match) {
          var width_1 = parseInt(match[1]);
          if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
            logger19.throwArgumentError("invalid bytes width", "type", type);
          }
          return function(value) {
            var bytes = (0, bytes_1.arrayify)(value);
            if (bytes.length !== width_1) {
              logger19.throwArgumentError("invalid length for " + type, "value", value);
            }
            return hexPadRight(value);
          };
        }
      }
      switch (type) {
        case "address":
          return function(value) {
            return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
          };
        case "bool":
          return function(value) {
            return !value ? hexFalse : hexTrue;
          };
        case "bytes":
          return function(value) {
            return (0, keccak256_1.keccak256)(value);
          };
        case "string":
          return function(value) {
            return (0, id_1.id)(value);
          };
      }
      return null;
    }
    function encodeType(name2, fields) {
      return name2 + "(" + fields.map(function(_a2) {
        var name3 = _a2.name, type = _a2.type;
        return type + " " + name3;
      }).join(",") + ")";
    }
    var TypedDataEncoder = (
      /** @class */
      function() {
        function TypedDataEncoder2(types) {
          (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
          (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
          (0, properties_1.defineReadOnly)(this, "_types", {});
          var links = {};
          var parents = {};
          var subtypes = {};
          Object.keys(types).forEach(function(type) {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
          });
          var _loop_1 = function(name_12) {
            var uniqueNames = {};
            types[name_12].forEach(function(field) {
              if (uniqueNames[field.name]) {
                logger19.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_12), "types", types);
              }
              uniqueNames[field.name] = true;
              var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
              if (baseType === name_12) {
                logger19.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
              }
              var encoder = getBaseEncoder(baseType);
              if (encoder) {
                return;
              }
              if (!parents[baseType]) {
                logger19.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
              }
              parents[baseType].push(name_12);
              links[name_12][baseType] = true;
            });
          };
          for (var name_1 in types) {
            _loop_1(name_1);
          }
          var primaryTypes = Object.keys(parents).filter(function(n8) {
            return parents[n8].length === 0;
          });
          if (primaryTypes.length === 0) {
            logger19.throwArgumentError("missing primary type", "types", types);
          } else if (primaryTypes.length > 1) {
            logger19.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function(t8) {
              return JSON.stringify(t8);
            }).join(", "), "types", types);
          }
          (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
          function checkCircular(type, found) {
            if (found[type]) {
              logger19.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach(function(child) {
              if (!parents[child]) {
                return;
              }
              checkCircular(child, found);
              Object.keys(found).forEach(function(subtype) {
                subtypes[subtype][child] = true;
              });
            });
            delete found[type];
          }
          checkCircular(this.primaryType, {});
          for (var name_2 in subtypes) {
            var st4 = Object.keys(subtypes[name_2]);
            st4.sort();
            this._types[name_2] = encodeType(name_2, types[name_2]) + st4.map(function(t8) {
              return encodeType(t8, types[t8]);
            }).join("");
          }
        }
        TypedDataEncoder2.prototype.getEncoder = function(type) {
          var encoder = this._encoderCache[type];
          if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
          }
          return encoder;
        };
        TypedDataEncoder2.prototype._getEncoder = function(type) {
          var _this = this;
          {
            var encoder = getBaseEncoder(type);
            if (encoder) {
              return encoder;
            }
          }
          var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
          if (match) {
            var subtype_1 = match[1];
            var subEncoder_1 = this.getEncoder(subtype_1);
            var length_1 = parseInt(match[3]);
            return function(value) {
              if (length_1 >= 0 && value.length !== length_1) {
                logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
              }
              var result = value.map(subEncoder_1);
              if (_this._types[subtype_1]) {
                result = result.map(keccak256_1.keccak256);
              }
              return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
            };
          }
          var fields = this.types[type];
          if (fields) {
            var encodedType_1 = (0, id_1.id)(this._types[type]);
            return function(value) {
              var values = fields.map(function(_a2) {
                var name2 = _a2.name, type2 = _a2.type;
                var result = _this.getEncoder(type2)(value[name2]);
                if (_this._types[type2]) {
                  return (0, keccak256_1.keccak256)(result);
                }
                return result;
              });
              values.unshift(encodedType_1);
              return (0, bytes_1.hexConcat)(values);
            };
          }
          return logger19.throwArgumentError("unknown type: " + type, "type", type);
        };
        TypedDataEncoder2.prototype.encodeType = function(name2) {
          var result = this._types[name2];
          if (!result) {
            logger19.throwArgumentError("unknown type: " + JSON.stringify(name2), "name", name2);
          }
          return result;
        };
        TypedDataEncoder2.prototype.encodeData = function(type, value) {
          return this.getEncoder(type)(value);
        };
        TypedDataEncoder2.prototype.hashStruct = function(name2, value) {
          return (0, keccak256_1.keccak256)(this.encodeData(name2, value));
        };
        TypedDataEncoder2.prototype.encode = function(value) {
          return this.encodeData(this.primaryType, value);
        };
        TypedDataEncoder2.prototype.hash = function(value) {
          return this.hashStruct(this.primaryType, value);
        };
        TypedDataEncoder2.prototype._visit = function(type, value, callback) {
          var _this = this;
          {
            var encoder = getBaseEncoder(type);
            if (encoder) {
              return callback(type, value);
            }
          }
          var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
          if (match) {
            var subtype_2 = match[1];
            var length_2 = parseInt(match[3]);
            if (length_2 >= 0 && value.length !== length_2) {
              logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map(function(v7) {
              return _this._visit(subtype_2, v7, callback);
            });
          }
          var fields = this.types[type];
          if (fields) {
            return fields.reduce(function(accum, _a2) {
              var name2 = _a2.name, type2 = _a2.type;
              accum[name2] = _this._visit(type2, value[name2], callback);
              return accum;
            }, {});
          }
          return logger19.throwArgumentError("unknown type: " + type, "type", type);
        };
        TypedDataEncoder2.prototype.visit = function(value, callback) {
          return this._visit(this.primaryType, value, callback);
        };
        TypedDataEncoder2.from = function(types) {
          return new TypedDataEncoder2(types);
        };
        TypedDataEncoder2.getPrimaryType = function(types) {
          return TypedDataEncoder2.from(types).primaryType;
        };
        TypedDataEncoder2.hashStruct = function(name2, types, value) {
          return TypedDataEncoder2.from(types).hashStruct(name2, value);
        };
        TypedDataEncoder2.hashDomain = function(domain2) {
          var domainFields = [];
          for (var name_3 in domain2) {
            var type = domainFieldTypes[name_3];
            if (!type) {
              logger19.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain2);
            }
            domainFields.push({ name: name_3, type });
          }
          domainFields.sort(function(a9, b10) {
            return domainFieldNames.indexOf(a9.name) - domainFieldNames.indexOf(b10.name);
          });
          return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
        };
        TypedDataEncoder2.encode = function(domain2, types, value) {
          return (0, bytes_1.hexConcat)([
            "0x1901",
            TypedDataEncoder2.hashDomain(domain2),
            TypedDataEncoder2.from(types).hash(value)
          ]);
        };
        TypedDataEncoder2.hash = function(domain2, types, value) {
          return (0, keccak256_1.keccak256)(TypedDataEncoder2.encode(domain2, types, value));
        };
        TypedDataEncoder2.resolveNames = function(domain2, types, value, resolveName2) {
          return __awaiter10(this, void 0, void 0, function() {
            var ensCache, encoder, _a2, _b, _i2, name_4, _c, _d;
            return __generator2(this, function(_e3) {
              switch (_e3.label) {
                case 0:
                  domain2 = (0, properties_1.shallowCopy)(domain2);
                  ensCache = {};
                  if (domain2.verifyingContract && !(0, bytes_1.isHexString)(domain2.verifyingContract, 20)) {
                    ensCache[domain2.verifyingContract] = "0x";
                  }
                  encoder = TypedDataEncoder2.from(types);
                  encoder.visit(value, function(type, value2) {
                    if (type === "address" && !(0, bytes_1.isHexString)(value2, 20)) {
                      ensCache[value2] = "0x";
                    }
                    return value2;
                  });
                  _a2 = [];
                  for (_b in ensCache)
                    _a2.push(_b);
                  _i2 = 0;
                  _e3.label = 1;
                case 1:
                  if (!(_i2 < _a2.length))
                    return [3, 4];
                  name_4 = _a2[_i2];
                  _c = ensCache;
                  _d = name_4;
                  return [4, resolveName2(name_4)];
                case 2:
                  _c[_d] = _e3.sent();
                  _e3.label = 3;
                case 3:
                  _i2++;
                  return [3, 1];
                case 4:
                  if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
                    domain2.verifyingContract = ensCache[domain2.verifyingContract];
                  }
                  value = encoder.visit(value, function(type, value2) {
                    if (type === "address" && ensCache[value2]) {
                      return ensCache[value2];
                    }
                    return value2;
                  });
                  return [2, { domain: domain2, value }];
              }
            });
          });
        };
        TypedDataEncoder2.getPayload = function(domain2, types, value) {
          TypedDataEncoder2.hashDomain(domain2);
          var domainValues = {};
          var domainTypes = [];
          domainFieldNames.forEach(function(name2) {
            var value2 = domain2[name2];
            if (value2 == null) {
              return;
            }
            domainValues[name2] = domainChecks[name2](value2);
            domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
          });
          var encoder = TypedDataEncoder2.from(types);
          var typesWithDomain = (0, properties_1.shallowCopy)(types);
          if (typesWithDomain.EIP712Domain) {
            logger19.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
          } else {
            typesWithDomain.EIP712Domain = domainTypes;
          }
          encoder.encode(value);
          return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, function(type, value2) {
              if (type.match(/^bytes(\d*)/)) {
                return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value2));
              }
              if (type.match(/^u?int/)) {
                return bignumber_1.BigNumber.from(value2).toString();
              }
              switch (type) {
                case "address":
                  return value2.toLowerCase();
                case "bool":
                  return !!value2;
                case "string":
                  if (typeof value2 !== "string") {
                    logger19.throwArgumentError("invalid string", "value", value2);
                  }
                  return value2;
              }
              return logger19.throwArgumentError("unsupported type", "type", type);
            })
          };
        };
        return TypedDataEncoder2;
      }()
    );
    exports.TypedDataEncoder = TypedDataEncoder;
  }
});

// node_modules/@ethersproject/hash/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@ethersproject/hash/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_1.id;
    } });
    var namehash_1 = require_namehash();
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return namehash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return namehash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_1.namehash;
    } });
    var message_1 = require_message();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return message_1.hashMessage;
    } });
    Object.defineProperty(exports, "messagePrefix", { enumerable: true, get: function() {
      return message_1.messagePrefix;
    } });
    var namehash_2 = require_namehash();
    Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
      return namehash_2.ensNormalize;
    } });
    var typed_data_1 = require_typed_data();
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return typed_data_1.TypedDataEncoder;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/interface.js
var require_interface = __commonJS({
  "node_modules/@ethersproject/abi/lib/interface.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib12();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var abi_coder_1 = require_abi_coder();
    var abstract_coder_1 = require_abstract_coder();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abstract_coder_1.checkResultErrors;
    } });
    var fragments_1 = require_fragments();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger19 = new logger_1.Logger(_version_1.version);
    var LogDescription2 = (
      /** @class */
      function(_super) {
        __extends2(LogDescription3, _super);
        function LogDescription3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return LogDescription3;
      }(properties_1.Description)
    );
    exports.LogDescription = LogDescription2;
    var TransactionDescription2 = (
      /** @class */
      function(_super) {
        __extends2(TransactionDescription3, _super);
        function TransactionDescription3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return TransactionDescription3;
      }(properties_1.Description)
    );
    exports.TransactionDescription = TransactionDescription2;
    var ErrorDescription = (
      /** @class */
      function(_super) {
        __extends2(ErrorDescription2, _super);
        function ErrorDescription2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return ErrorDescription2;
      }(properties_1.Description)
    );
    exports.ErrorDescription = ErrorDescription;
    var Indexed3 = (
      /** @class */
      function(_super) {
        __extends2(Indexed4, _super);
        function Indexed4() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        Indexed4.isIndexed = function(value) {
          return !!(value && value._isIndexed);
        };
        return Indexed4;
      }(properties_1.Description)
    );
    exports.Indexed = Indexed3;
    var BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    function wrapAccessError(property, error) {
      var wrap2 = new Error("deferred error during ABI decoding triggered accessing " + property);
      wrap2.error = error;
      return wrap2;
    }
    var Interface3 = (
      /** @class */
      function() {
        function Interface4(fragments) {
          var _newTarget = this.constructor;
          var _this = this;
          var abi = [];
          if (typeof fragments === "string") {
            abi = JSON.parse(fragments);
          } else {
            abi = fragments;
          }
          (0, properties_1.defineReadOnly)(this, "fragments", abi.map(function(fragment) {
            return fragments_1.Fragment.from(fragment);
          }).filter(function(fragment) {
            return fragment != null;
          }));
          (0, properties_1.defineReadOnly)(this, "_abiCoder", (0, properties_1.getStatic)(_newTarget, "getAbiCoder")());
          (0, properties_1.defineReadOnly)(this, "functions", {});
          (0, properties_1.defineReadOnly)(this, "errors", {});
          (0, properties_1.defineReadOnly)(this, "events", {});
          (0, properties_1.defineReadOnly)(this, "structs", {});
          this.fragments.forEach(function(fragment) {
            var bucket = null;
            switch (fragment.type) {
              case "constructor":
                if (_this.deploy) {
                  logger19.warn("duplicate definition - constructor");
                  return;
                }
                (0, properties_1.defineReadOnly)(_this, "deploy", fragment);
                return;
              case "function":
                bucket = _this.functions;
                break;
              case "event":
                bucket = _this.events;
                break;
              case "error":
                bucket = _this.errors;
                break;
              default:
                return;
            }
            var signature = fragment.format();
            if (bucket[signature]) {
              logger19.warn("duplicate definition - " + signature);
              return;
            }
            bucket[signature] = fragment;
          });
          if (!this.deploy) {
            (0, properties_1.defineReadOnly)(this, "deploy", fragments_1.ConstructorFragment.from({
              payable: false,
              type: "constructor"
            }));
          }
          (0, properties_1.defineReadOnly)(this, "_isInterface", true);
        }
        Interface4.prototype.format = function(format) {
          if (!format) {
            format = fragments_1.FormatTypes.full;
          }
          if (format === fragments_1.FormatTypes.sighash) {
            logger19.throwArgumentError("interface does not support formatting sighash", "format", format);
          }
          var abi = this.fragments.map(function(fragment) {
            return fragment.format(format);
          });
          if (format === fragments_1.FormatTypes.json) {
            return JSON.stringify(abi.map(function(j8) {
              return JSON.parse(j8);
            }));
          }
          return abi;
        };
        Interface4.getAbiCoder = function() {
          return abi_coder_1.defaultAbiCoder;
        };
        Interface4.getAddress = function(address) {
          return (0, address_1.getAddress)(address);
        };
        Interface4.getSighash = function(fragment) {
          return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);
        };
        Interface4.getEventTopic = function(eventFragment) {
          return (0, hash_1.id)(eventFragment.format());
        };
        Interface4.prototype.getFunction = function(nameOrSignatureOrSighash) {
          if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
            for (var name_1 in this.functions) {
              if (nameOrSignatureOrSighash === this.getSighash(name_1)) {
                return this.functions[name_1];
              }
            }
            logger19.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
          }
          if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            var name_2 = nameOrSignatureOrSighash.trim();
            var matching = Object.keys(this.functions).filter(function(f7) {
              return f7.split(
                "("
                /* fix:) */
              )[0] === name_2;
            });
            if (matching.length === 0) {
              logger19.throwArgumentError("no matching function", "name", name_2);
            } else if (matching.length > 1) {
              logger19.throwArgumentError("multiple matching functions", "name", name_2);
            }
            return this.functions[matching[0]];
          }
          var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
          if (!result) {
            logger19.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
          }
          return result;
        };
        Interface4.prototype.getEvent = function(nameOrSignatureOrTopic) {
          if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {
            var topichash = nameOrSignatureOrTopic.toLowerCase();
            for (var name_3 in this.events) {
              if (topichash === this.getEventTopic(name_3)) {
                return this.events[name_3];
              }
            }
            logger19.throwArgumentError("no matching event", "topichash", topichash);
          }
          if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            var name_4 = nameOrSignatureOrTopic.trim();
            var matching = Object.keys(this.events).filter(function(f7) {
              return f7.split(
                "("
                /* fix:) */
              )[0] === name_4;
            });
            if (matching.length === 0) {
              logger19.throwArgumentError("no matching event", "name", name_4);
            } else if (matching.length > 1) {
              logger19.throwArgumentError("multiple matching events", "name", name_4);
            }
            return this.events[matching[0]];
          }
          var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
          if (!result) {
            logger19.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
          }
          return result;
        };
        Interface4.prototype.getError = function(nameOrSignatureOrSighash) {
          if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
            var getSighash = (0, properties_1.getStatic)(this.constructor, "getSighash");
            for (var name_5 in this.errors) {
              var error = this.errors[name_5];
              if (nameOrSignatureOrSighash === getSighash(error)) {
                return this.errors[name_5];
              }
            }
            logger19.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
          }
          if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            var name_6 = nameOrSignatureOrSighash.trim();
            var matching = Object.keys(this.errors).filter(function(f7) {
              return f7.split(
                "("
                /* fix:) */
              )[0] === name_6;
            });
            if (matching.length === 0) {
              logger19.throwArgumentError("no matching error", "name", name_6);
            } else if (matching.length > 1) {
              logger19.throwArgumentError("multiple matching errors", "name", name_6);
            }
            return this.errors[matching[0]];
          }
          var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
          if (!result) {
            logger19.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
          }
          return result;
        };
        Interface4.prototype.getSighash = function(fragment) {
          if (typeof fragment === "string") {
            try {
              fragment = this.getFunction(fragment);
            } catch (error) {
              try {
                fragment = this.getError(fragment);
              } catch (_8) {
                throw error;
              }
            }
          }
          return (0, properties_1.getStatic)(this.constructor, "getSighash")(fragment);
        };
        Interface4.prototype.getEventTopic = function(eventFragment) {
          if (typeof eventFragment === "string") {
            eventFragment = this.getEvent(eventFragment);
          }
          return (0, properties_1.getStatic)(this.constructor, "getEventTopic")(eventFragment);
        };
        Interface4.prototype._decodeParams = function(params, data2) {
          return this._abiCoder.decode(params, data2);
        };
        Interface4.prototype._encodeParams = function(params, values) {
          return this._abiCoder.encode(params, values);
        };
        Interface4.prototype.encodeDeploy = function(values) {
          return this._encodeParams(this.deploy.inputs, values || []);
        };
        Interface4.prototype.decodeErrorResult = function(fragment, data2) {
          if (typeof fragment === "string") {
            fragment = this.getError(fragment);
          }
          var bytes = (0, bytes_1.arrayify)(data2);
          if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger19.throwArgumentError("data signature does not match error " + fragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
          }
          return this._decodeParams(fragment.inputs, bytes.slice(4));
        };
        Interface4.prototype.encodeErrorResult = function(fragment, values) {
          if (typeof fragment === "string") {
            fragment = this.getError(fragment);
          }
          return (0, bytes_1.hexlify)((0, bytes_1.concat)([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
          ]));
        };
        Interface4.prototype.decodeFunctionData = function(functionFragment, data2) {
          if (typeof functionFragment === "string") {
            functionFragment = this.getFunction(functionFragment);
          }
          var bytes = (0, bytes_1.arrayify)(data2);
          if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger19.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
          }
          return this._decodeParams(functionFragment.inputs, bytes.slice(4));
        };
        Interface4.prototype.encodeFunctionData = function(functionFragment, values) {
          if (typeof functionFragment === "string") {
            functionFragment = this.getFunction(functionFragment);
          }
          return (0, bytes_1.hexlify)((0, bytes_1.concat)([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
          ]));
        };
        Interface4.prototype.decodeFunctionResult = function(functionFragment, data2) {
          if (typeof functionFragment === "string") {
            functionFragment = this.getFunction(functionFragment);
          }
          var bytes = (0, bytes_1.arrayify)(data2);
          var reason = null;
          var message = "";
          var errorArgs = null;
          var errorName = null;
          var errorSignature = null;
          switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
              try {
                return this._abiCoder.decode(functionFragment.outputs, bytes);
              } catch (error2) {
              }
              break;
            case 4: {
              var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));
              var builtin = BuiltinErrors[selector];
              if (builtin) {
                errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                errorName = builtin.name;
                errorSignature = builtin.signature;
                if (builtin.reason) {
                  reason = errorArgs[0];
                }
                if (errorName === "Error") {
                  message = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(errorArgs[0]);
                } else if (errorName === "Panic") {
                  message = "; VM Exception while processing transaction: reverted with panic code " + errorArgs[0];
                }
              } else {
                try {
                  var error = this.getError(selector);
                  errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                  errorName = error.name;
                  errorSignature = error.format();
                } catch (error2) {
                }
              }
              break;
            }
          }
          return logger19.throwError("call revert exception" + message, logger_1.Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: (0, bytes_1.hexlify)(data2),
            errorArgs,
            errorName,
            errorSignature,
            reason
          });
        };
        Interface4.prototype.encodeFunctionResult = function(functionFragment, values) {
          if (typeof functionFragment === "string") {
            functionFragment = this.getFunction(functionFragment);
          }
          return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
        };
        Interface4.prototype.encodeFilterTopics = function(eventFragment, values) {
          var _this = this;
          if (typeof eventFragment === "string") {
            eventFragment = this.getEvent(eventFragment);
          }
          if (values.length > eventFragment.inputs.length) {
            logger19.throwError("too many arguments for " + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {
              argument: "values",
              value: values
            });
          }
          var topics = [];
          if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
          }
          var encodeTopic = function(param, value) {
            if (param.type === "string") {
              return (0, hash_1.id)(value);
            } else if (param.type === "bytes") {
              return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));
            }
            if (param.type === "bool" && typeof value === "boolean") {
              value = value ? "0x01" : "0x00";
            }
            if (param.type.match(/^u?int/)) {
              value = bignumber_1.BigNumber.from(value).toHexString();
            }
            if (param.type === "address") {
              _this._abiCoder.encode(["address"], [value]);
            }
            return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
          };
          values.forEach(function(value, index) {
            var param = eventFragment.inputs[index];
            if (!param.indexed) {
              if (value != null) {
                logger19.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
              }
              return;
            }
            if (value == null) {
              topics.push(null);
            } else if (param.baseType === "array" || param.baseType === "tuple") {
              logger19.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
            } else if (Array.isArray(value)) {
              topics.push(value.map(function(value2) {
                return encodeTopic(param, value2);
              }));
            } else {
              topics.push(encodeTopic(param, value));
            }
          });
          while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
          }
          return topics;
        };
        Interface4.prototype.encodeEventLog = function(eventFragment, values) {
          var _this = this;
          if (typeof eventFragment === "string") {
            eventFragment = this.getEvent(eventFragment);
          }
          var topics = [];
          var dataTypes = [];
          var dataValues = [];
          if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
          }
          if (values.length !== eventFragment.inputs.length) {
            logger19.throwArgumentError("event arguments/values mismatch", "values", values);
          }
          eventFragment.inputs.forEach(function(param, index) {
            var value = values[index];
            if (param.indexed) {
              if (param.type === "string") {
                topics.push((0, hash_1.id)(value));
              } else if (param.type === "bytes") {
                topics.push((0, keccak256_1.keccak256)(value));
              } else if (param.baseType === "tuple" || param.baseType === "array") {
                throw new Error("not implemented");
              } else {
                topics.push(_this._abiCoder.encode([param.type], [value]));
              }
            } else {
              dataTypes.push(param);
              dataValues.push(value);
            }
          });
          return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics
          };
        };
        Interface4.prototype.decodeEventLog = function(eventFragment, data2, topics) {
          if (typeof eventFragment === "string") {
            eventFragment = this.getEvent(eventFragment);
          }
          if (topics != null && !eventFragment.anonymous) {
            var topicHash = this.getEventTopic(eventFragment);
            if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
              logger19.throwError("fragment/topic mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
          }
          var indexed = [];
          var nonIndexed = [];
          var dynamic = [];
          eventFragment.inputs.forEach(function(param, index) {
            if (param.indexed) {
              if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                indexed.push(fragments_1.ParamType.fromObject({ type: "bytes32", name: param.name }));
                dynamic.push(true);
              } else {
                indexed.push(param);
                dynamic.push(false);
              }
            } else {
              nonIndexed.push(param);
              dynamic.push(false);
            }
          });
          var resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;
          var resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
          var result = [];
          var nonIndexedIndex = 0, indexedIndex = 0;
          eventFragment.inputs.forEach(function(param, index) {
            if (param.indexed) {
              if (resultIndexed == null) {
                result[index] = new Indexed3({ _isIndexed: true, hash: null });
              } else if (dynamic[index]) {
                result[index] = new Indexed3({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
              } else {
                try {
                  result[index] = resultIndexed[indexedIndex++];
                } catch (error) {
                  result[index] = error;
                }
              }
            } else {
              try {
                result[index] = resultNonIndexed[nonIndexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
            if (param.name && result[param.name] == null) {
              var value_1 = result[index];
              if (value_1 instanceof Error) {
                Object.defineProperty(result, param.name, {
                  enumerable: true,
                  get: function() {
                    throw wrapAccessError("property " + JSON.stringify(param.name), value_1);
                  }
                });
              } else {
                result[param.name] = value_1;
              }
            }
          });
          var _loop_1 = function(i11) {
            var value = result[i11];
            if (value instanceof Error) {
              Object.defineProperty(result, i11, {
                enumerable: true,
                get: function() {
                  throw wrapAccessError("index " + i11, value);
                }
              });
            }
          };
          for (var i10 = 0; i10 < result.length; i10++) {
            _loop_1(i10);
          }
          return Object.freeze(result);
        };
        Interface4.prototype.parseTransaction = function(tx) {
          var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
          if (!fragment) {
            return null;
          }
          return new TransactionDescription2({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: bignumber_1.BigNumber.from(tx.value || "0")
          });
        };
        Interface4.prototype.parseLog = function(log) {
          var fragment = this.getEvent(log.topics[0]);
          if (!fragment || fragment.anonymous) {
            return null;
          }
          return new LogDescription2({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
          });
        };
        Interface4.prototype.parseError = function(data2) {
          var hexData = (0, bytes_1.hexlify)(data2);
          var fragment = this.getError(hexData.substring(0, 10).toLowerCase());
          if (!fragment) {
            return null;
          }
          return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment)
          });
        };
        Interface4.isInterface = function(value) {
          return !!(value && value._isInterface);
        };
        return Interface4;
      }()
    );
    exports.Interface = Interface3;
  }
});

// node_modules/@ethersproject/abi/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@ethersproject/abi/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = exports.Indexed = exports.Interface = exports.defaultAbiCoder = exports.AbiCoder = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = void 0;
    var fragments_1 = require_fragments();
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return fragments_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return fragments_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return fragments_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return fragments_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return fragments_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return fragments_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return fragments_1.ParamType;
    } });
    var abi_coder_1 = require_abi_coder();
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_coder_1.AbiCoder;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_coder_1.defaultAbiCoder;
    } });
    var interface_1 = require_interface();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return interface_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return interface_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return interface_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return interface_1.LogDescription;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return interface_1.TransactionDescription;
    } });
  }
});

// node_modules/@ethersproject/abstract-provider/lib/_version.js
var require_version10 = __commonJS({
  "node_modules/@ethersproject/abstract-provider/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-provider/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-provider/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@ethersproject/abstract-provider/lib/index.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version10();
    var logger19 = new logger_1.Logger(_version_1.version);
    var ForkEvent2 = (
      /** @class */
      function(_super) {
        __extends2(ForkEvent3, _super);
        function ForkEvent3() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ForkEvent3.isForkEvent = function(value) {
          return !!(value && value._isForkEvent);
        };
        return ForkEvent3;
      }(properties_1.Description)
    );
    exports.ForkEvent = ForkEvent2;
    var BlockForkEvent = (
      /** @class */
      function(_super) {
        __extends2(BlockForkEvent2, _super);
        function BlockForkEvent2(blockHash, expiry) {
          var _this = this;
          if (!(0, bytes_1.isHexString)(blockHash, 32)) {
            logger19.throwArgumentError("invalid blockHash", "blockHash", blockHash);
          }
          _this = _super.call(this, {
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: expiry || 0,
            blockHash
          }) || this;
          return _this;
        }
        return BlockForkEvent2;
      }(ForkEvent2)
    );
    exports.BlockForkEvent = BlockForkEvent;
    var TransactionForkEvent = (
      /** @class */
      function(_super) {
        __extends2(TransactionForkEvent2, _super);
        function TransactionForkEvent2(hash, expiry) {
          var _this = this;
          if (!(0, bytes_1.isHexString)(hash, 32)) {
            logger19.throwArgumentError("invalid transaction hash", "hash", hash);
          }
          _this = _super.call(this, {
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: expiry || 0,
            hash
          }) || this;
          return _this;
        }
        return TransactionForkEvent2;
      }(ForkEvent2)
    );
    exports.TransactionForkEvent = TransactionForkEvent;
    var TransactionOrderForkEvent = (
      /** @class */
      function(_super) {
        __extends2(TransactionOrderForkEvent2, _super);
        function TransactionOrderForkEvent2(beforeHash, afterHash, expiry) {
          var _this = this;
          if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
            logger19.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
          }
          if (!(0, bytes_1.isHexString)(afterHash, 32)) {
            logger19.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
          }
          _this = _super.call(this, {
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: expiry || 0,
            beforeHash,
            afterHash
          }) || this;
          return _this;
        }
        return TransactionOrderForkEvent2;
      }(ForkEvent2)
    );
    exports.TransactionOrderForkEvent = TransactionOrderForkEvent;
    var Provider5 = (
      /** @class */
      function() {
        function Provider6() {
          var _newTarget = this.constructor;
          logger19.checkAbstract(_newTarget, Provider6);
          (0, properties_1.defineReadOnly)(this, "_isProvider", true);
        }
        Provider6.prototype.getFeeData = function() {
          return __awaiter10(this, void 0, void 0, function() {
            var _a2, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, (0, properties_1.resolveProperties)({
                    block: this.getBlock("latest"),
                    gasPrice: this.getGasPrice().catch(function(error) {
                      return null;
                    })
                  })];
                case 1:
                  _a2 = _b.sent(), block = _a2.block, gasPrice = _a2.gasPrice;
                  lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
                  if (block && block.baseFeePerGas) {
                    lastBaseFeePerGas = block.baseFeePerGas;
                    maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                    maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
                  }
                  return [2, { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice }];
              }
            });
          });
        };
        Provider6.prototype.addListener = function(eventName, listener) {
          return this.on(eventName, listener);
        };
        Provider6.prototype.removeListener = function(eventName, listener) {
          return this.off(eventName, listener);
        };
        Provider6.isProvider = function(value) {
          return !!(value && value._isProvider);
        };
        return Provider6;
      }()
    );
    exports.Provider = Provider5;
  }
});

// node_modules/@ethersproject/abstract-signer/lib/_version.js
var require_version11 = __commonJS({
  "node_modules/@ethersproject/abstract-signer/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-signer/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-signer/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@ethersproject/abstract-signer/lib/index.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoidSigner = exports.Signer = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version11();
    var logger19 = new logger_1.Logger(_version_1.version);
    var allowedTransactionKeys3 = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    var forwardErrors = [
      logger_1.Logger.errors.INSUFFICIENT_FUNDS,
      logger_1.Logger.errors.NONCE_EXPIRED,
      logger_1.Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    var Signer4 = (
      /** @class */
      function() {
        function Signer5() {
          var _newTarget = this.constructor;
          logger19.checkAbstract(_newTarget, Signer5);
          (0, properties_1.defineReadOnly)(this, "_isSigner", true);
        }
        Signer5.prototype.getBalance = function(blockTag) {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("getBalance");
                  return [4, this.provider.getBalance(this.getAddress(), blockTag)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.getTransactionCount = function(blockTag) {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("getTransactionCount");
                  return [4, this.provider.getTransactionCount(this.getAddress(), blockTag)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.estimateGas = function(transaction) {
          return __awaiter10(this, void 0, void 0, function() {
            var tx;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("estimateGas");
                  return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                case 1:
                  tx = _a2.sent();
                  return [4, this.provider.estimateGas(tx)];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.call = function(transaction, blockTag) {
          return __awaiter10(this, void 0, void 0, function() {
            var tx;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("call");
                  return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                case 1:
                  tx = _a2.sent();
                  return [4, this.provider.call(tx, blockTag)];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.sendTransaction = function(transaction) {
          return __awaiter10(this, void 0, void 0, function() {
            var tx, signedTx;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("sendTransaction");
                  return [4, this.populateTransaction(transaction)];
                case 1:
                  tx = _a2.sent();
                  return [4, this.signTransaction(tx)];
                case 2:
                  signedTx = _a2.sent();
                  return [4, this.provider.sendTransaction(signedTx)];
                case 3:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.getChainId = function() {
          return __awaiter10(this, void 0, void 0, function() {
            var network;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("getChainId");
                  return [4, this.provider.getNetwork()];
                case 1:
                  network = _a2.sent();
                  return [2, network.chainId];
              }
            });
          });
        };
        Signer5.prototype.getGasPrice = function() {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("getGasPrice");
                  return [4, this.provider.getGasPrice()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.getFeeData = function() {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("getFeeData");
                  return [4, this.provider.getFeeData()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.resolveName = function(name2) {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this._checkProvider("resolveName");
                  return [4, this.provider.resolveName(name2)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype.checkTransaction = function(transaction) {
          for (var key in transaction) {
            if (allowedTransactionKeys3.indexOf(key) === -1) {
              logger19.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
          }
          var tx = (0, properties_1.shallowCopy)(transaction);
          if (tx.from == null) {
            tx.from = this.getAddress();
          } else {
            tx.from = Promise.all([
              Promise.resolve(tx.from),
              this.getAddress()
            ]).then(function(result) {
              if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                logger19.throwArgumentError("from address mismatch", "transaction", transaction);
              }
              return result[0];
            });
          }
          return tx;
        };
        Signer5.prototype.populateTransaction = function(transaction) {
          return __awaiter10(this, void 0, void 0, function() {
            var tx, hasEip1559, feeData, gasPrice;
            var _this = this;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                case 1:
                  tx = _a2.sent();
                  if (tx.to != null) {
                    tx.to = Promise.resolve(tx.to).then(function(to2) {
                      return __awaiter10(_this, void 0, void 0, function() {
                        var address;
                        return __generator2(this, function(_a3) {
                          switch (_a3.label) {
                            case 0:
                              if (to2 == null) {
                                return [2, null];
                              }
                              return [4, this.resolveName(to2)];
                            case 1:
                              address = _a3.sent();
                              if (address == null) {
                                logger19.throwArgumentError("provided ENS name resolves to null", "tx.to", to2);
                              }
                              return [2, address];
                          }
                        });
                      });
                    });
                    tx.to.catch(function(error) {
                    });
                  }
                  hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
                  if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                    logger19.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
                  } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                    logger19.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
                  }
                  if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)))
                    return [3, 2];
                  tx.type = 2;
                  return [3, 5];
                case 2:
                  if (!(tx.type === 0 || tx.type === 1))
                    return [3, 3];
                  if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                  }
                  return [3, 5];
                case 3:
                  return [4, this.getFeeData()];
                case 4:
                  feeData = _a2.sent();
                  if (tx.type == null) {
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                      tx.type = 2;
                      if (tx.gasPrice != null) {
                        gasPrice = tx.gasPrice;
                        delete tx.gasPrice;
                        tx.maxFeePerGas = gasPrice;
                        tx.maxPriorityFeePerGas = gasPrice;
                      } else {
                        if (tx.maxFeePerGas == null) {
                          tx.maxFeePerGas = feeData.maxFeePerGas;
                        }
                        if (tx.maxPriorityFeePerGas == null) {
                          tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                        }
                      }
                    } else if (feeData.gasPrice != null) {
                      if (hasEip1559) {
                        logger19.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                          operation: "populateTransaction"
                        });
                      }
                      if (tx.gasPrice == null) {
                        tx.gasPrice = feeData.gasPrice;
                      }
                      tx.type = 0;
                    } else {
                      logger19.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "signer.getFeeData"
                      });
                    }
                  } else if (tx.type === 2) {
                    if (tx.maxFeePerGas == null) {
                      tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                      tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                  }
                  _a2.label = 5;
                case 5:
                  if (tx.nonce == null) {
                    tx.nonce = this.getTransactionCount("pending");
                  }
                  if (tx.gasLimit == null) {
                    tx.gasLimit = this.estimateGas(tx).catch(function(error) {
                      if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                      }
                      return logger19.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                        error,
                        tx
                      });
                    });
                  }
                  if (tx.chainId == null) {
                    tx.chainId = this.getChainId();
                  } else {
                    tx.chainId = Promise.all([
                      Promise.resolve(tx.chainId),
                      this.getChainId()
                    ]).then(function(results2) {
                      if (results2[1] !== 0 && results2[0] !== results2[1]) {
                        logger19.throwArgumentError("chainId address mismatch", "transaction", transaction);
                      }
                      return results2[0];
                    });
                  }
                  return [4, (0, properties_1.resolveProperties)(tx)];
                case 6:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Signer5.prototype._checkProvider = function(operation) {
          if (!this.provider) {
            logger19.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: operation || "_checkProvider"
            });
          }
        };
        Signer5.isSigner = function(value) {
          return !!(value && value._isSigner);
        };
        return Signer5;
      }()
    );
    exports.Signer = Signer4;
    var VoidSigner3 = (
      /** @class */
      function(_super) {
        __extends2(VoidSigner4, _super);
        function VoidSigner4(address, provider) {
          var _this = _super.call(this) || this;
          (0, properties_1.defineReadOnly)(_this, "address", address);
          (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
          return _this;
        }
        VoidSigner4.prototype.getAddress = function() {
          return Promise.resolve(this.address);
        };
        VoidSigner4.prototype._fail = function(message, operation) {
          return Promise.resolve().then(function() {
            logger19.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation });
          });
        };
        VoidSigner4.prototype.signMessage = function(message) {
          return this._fail("VoidSigner cannot sign messages", "signMessage");
        };
        VoidSigner4.prototype.signTransaction = function(transaction) {
          return this._fail("VoidSigner cannot sign transactions", "signTransaction");
        };
        VoidSigner4.prototype._signTypedData = function(domain2, types, value) {
          return this._fail("VoidSigner cannot sign typed data", "signTypedData");
        };
        VoidSigner4.prototype.connect = function(provider) {
          return new VoidSigner4(this.address, provider);
        };
        return VoidSigner4;
      }(Signer4)
    );
    exports.VoidSigner = VoidSigner3;
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base3, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e11) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert3(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN.prototype._initArray = function _initArray(number, base3, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          this.words[i10] = 0;
        }
        var j8, w11;
        var off = 0;
        if (endian === "be") {
          for (i10 = number.length - 1, j8 = 0; i10 >= 0; i10 -= 3) {
            w11 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
            this.words[j8] |= w11 << off & 67108863;
            this.words[j8 + 1] = w11 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        } else if (endian === "le") {
          for (i10 = 0, j8 = 0; i10 < number.length; i10 += 3) {
            w11 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
            this.words[j8] |= w11 << off & 67108863;
            this.words[j8 + 1] = w11 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j8++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index) {
        var c8 = string2.charCodeAt(index);
        if (c8 >= 65 && c8 <= 70) {
          return c8 - 55;
        } else if (c8 >= 97 && c8 <= 102) {
          return c8 - 87;
        } else {
          return c8 - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r7 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r7 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r7;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          this.words[i10] = 0;
        }
        var off = 0;
        var j8 = 0;
        var w11;
        if (endian === "be") {
          for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
            w11 = parseHexByte(number, start, i10) << off;
            this.words[j8] |= w11 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w11 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
            w11 = parseHexByte(number, start, i10) << off;
            this.words[j8] |= w11 & 67108863;
            if (off >= 18) {
              off -= 18;
              j8 += 1;
              this.words[j8] |= w11 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r7 = 0;
        var len = Math.min(str.length, end);
        for (var i10 = start; i10 < len; i10++) {
          var c8 = str.charCodeAt(i10) - 48;
          r7 *= mul;
          if (c8 >= 49) {
            r7 += c8 - 49 + 10;
          } else if (c8 >= 17) {
            r7 += c8 - 17 + 10;
          } else {
            r7 += c8;
          }
        }
        return r7;
      }
      BN.prototype._parseBase = function _parseBase(number, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i10 = start; i10 < end; i10 += limbLen) {
          word = parseBase(number, i10, i10 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i10, number.length, base3);
          for (i10 = 0; i10 < mod; i10++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i10 = 0; i10 < this.length; i10++) {
          dest.words[i10] = this.words[i10];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r7 = new BN(null);
        this.copy(r7);
        return r7;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base3, padding) {
        base3 = base3 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w11 = this.words[i10];
            var word = ((w11 << off | carry) & 16777215).toString(16);
            carry = w11 >>> 24 - off & 16777215;
            if (carry !== 0 || i10 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i10--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c8 = this.clone();
          c8.negative = 0;
          while (!c8.isZero()) {
            var r7 = c8.modn(groupBase).toString(base3);
            c8 = c8.idivn(groupBase);
            if (!c8.isZero()) {
              out = zeros[groupSize - r7.length] + r7 + out;
            } else {
              out = r7 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length2) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length2);
      };
      BN.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b10, i10;
        var q8 = this.clone();
        if (!littleEndian) {
          for (i10 = 0; i10 < reqLength - byteLength; i10++) {
            res[i10] = 0;
          }
          for (i10 = 0; !q8.isZero(); i10++) {
            b10 = q8.andln(255);
            q8.iushrn(8);
            res[reqLength - i10 - 1] = b10;
          }
        } else {
          for (i10 = 0; !q8.isZero(); i10++) {
            b10 = q8.andln(255);
            q8.iushrn(8);
            res[i10] = b10;
          }
          for (; i10 < reqLength; i10++) {
            res[i10] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w11) {
          return 32 - Math.clz32(w11);
        };
      } else {
        BN.prototype._countBits = function _countBits(w11) {
          var t8 = w11;
          var r7 = 0;
          if (t8 >= 4096) {
            r7 += 13;
            t8 >>>= 13;
          }
          if (t8 >= 64) {
            r7 += 7;
            t8 >>>= 7;
          }
          if (t8 >= 8) {
            r7 += 4;
            t8 >>>= 4;
          }
          if (t8 >= 2) {
            r7 += 2;
            t8 >>>= 2;
          }
          return r7 + t8;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w11) {
        if (w11 === 0)
          return 26;
        var t8 = w11;
        var r7 = 0;
        if ((t8 & 8191) === 0) {
          r7 += 13;
          t8 >>>= 13;
        }
        if ((t8 & 127) === 0) {
          r7 += 7;
          t8 >>>= 7;
        }
        if ((t8 & 15) === 0) {
          r7 += 4;
          t8 >>>= 4;
        }
        if ((t8 & 3) === 0) {
          r7 += 2;
          t8 >>>= 2;
        }
        if ((t8 & 1) === 0) {
          r7++;
        }
        return r7;
      };
      BN.prototype.bitLength = function bitLength() {
        var w11 = this.words[this.length - 1];
        var hi = this._countBits(w11);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w11 = new Array(num.bitLength());
        for (var bit = 0; bit < w11.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w11[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w11;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r7 = 0;
        for (var i10 = 0; i10 < this.length; i10++) {
          var b10 = this._zeroBits(this.words[i10]);
          r7 += b10;
          if (b10 !== 26)
            break;
        }
        return r7;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i10 = 0; i10 < num.length; i10++) {
          this.words[i10] = this.words[i10] | num.words[i10];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or4(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b10;
        if (this.length > num.length) {
          b10 = num;
        } else {
          b10 = this;
        }
        for (var i10 = 0; i10 < b10.length; i10++) {
          this.words[i10] = this.words[i10] & num.words[i10];
        }
        this.length = b10.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a9;
        var b10;
        if (this.length > num.length) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        for (var i10 = 0; i10 < b10.length; i10++) {
          this.words[i10] = a9.words[i10] ^ b10.words[i10];
        }
        if (this !== a9) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        this.length = a9.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i10 = 0; i10 < bytesNeeded; i10++) {
          this.words[i10] = ~this.words[i10] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r7;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r7 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r7 = this.isub(num);
          num.negative = 1;
          return r7._normSign();
        }
        var a9, b10;
        if (this.length > num.length) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        var carry = 0;
        for (var i10 = 0; i10 < b10.length; i10++) {
          r7 = (a9.words[i10] | 0) + (b10.words[i10] | 0) + carry;
          this.words[i10] = r7 & 67108863;
          carry = r7 >>> 26;
        }
        for (; carry !== 0 && i10 < a9.length; i10++) {
          r7 = (a9.words[i10] | 0) + carry;
          this.words[i10] = r7 & 67108863;
          carry = r7 >>> 26;
        }
        this.length = a9.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a9 !== this) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r7 = this.iadd(num);
          num.negative = 1;
          return r7._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a9, b10;
        if (cmp > 0) {
          a9 = this;
          b10 = num;
        } else {
          a9 = num;
          b10 = this;
        }
        var carry = 0;
        for (var i10 = 0; i10 < b10.length; i10++) {
          r7 = (a9.words[i10] | 0) - (b10.words[i10] | 0) + carry;
          carry = r7 >> 26;
          this.words[i10] = r7 & 67108863;
        }
        for (; carry !== 0 && i10 < a9.length; i10++) {
          r7 = (a9.words[i10] | 0) + carry;
          carry = r7 >> 26;
          this.words[i10] = r7 & 67108863;
        }
        if (carry === 0 && i10 < a9.length && a9 !== this) {
          for (; i10 < a9.length; i10++) {
            this.words[i10] = a9.words[i10];
          }
        }
        this.length = Math.max(this.length, i10);
        if (a9 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a9 = self2.words[0] | 0;
        var b10 = num.words[0] | 0;
        var r7 = a9 * b10;
        var lo2 = r7 & 67108863;
        var carry = r7 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k8 = 1; k8 < len; k8++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i10 = k8 - j8 | 0;
            a9 = self2.words[i10] | 0;
            b10 = num.words[j8] | 0;
            r7 = a9 * b10 + rword;
            ncarry += r7 / 67108864 | 0;
            rword = r7 & 67108863;
          }
          out.words[k8] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k8] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a9 = self2.words;
        var b10 = num.words;
        var o11 = out.words;
        var c8 = 0;
        var lo2;
        var mid;
        var hi;
        var a0 = a9[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a9[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a9[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a9[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a9[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a9[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a62 = a9[6] | 0;
        var al6 = a62 & 8191;
        var ah6 = a62 >>> 13;
        var a72 = a9[7] | 0;
        var al7 = a72 & 8191;
        var ah7 = a72 >>> 13;
        var a82 = a9[8] | 0;
        var al8 = a82 & 8191;
        var ah8 = a82 >>> 13;
        var a92 = a9[9] | 0;
        var al9 = a92 & 8191;
        var ah9 = a92 >>> 13;
        var b0 = b10[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b10[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b10[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b10[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b10[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b10[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b10[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b10[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b82 = b10[8] | 0;
        var bl8 = b82 & 8191;
        var bh8 = b82 >>> 13;
        var b92 = b10[9] | 0;
        var bl9 = b92 & 8191;
        var bh9 = b92 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w62 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w72 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w82 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
        w82 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w92 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
        w92 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w102 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w102 >>> 26) | 0;
        w102 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c8 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c8 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o11[0] = w0;
        o11[1] = w1;
        o11[2] = w22;
        o11[3] = w32;
        o11[4] = w42;
        o11[5] = w52;
        o11[6] = w62;
        o11[7] = w72;
        o11[8] = w82;
        o11[9] = w92;
        o11[10] = w102;
        o11[11] = w11;
        o11[12] = w12;
        o11[13] = w13;
        o11[14] = w14;
        o11[15] = w15;
        o11[16] = w16;
        o11[17] = w17;
        o11[18] = w18;
        if (c8 !== 0) {
          o11[19] = c8;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k8 = 0; k8 < out.length - 1; k8++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k8, num.length - 1);
          for (var j8 = Math.max(0, k8 - self2.length + 1); j8 <= maxJ; j8++) {
            var i10 = k8 - j8;
            var a9 = self2.words[i10] | 0;
            var b10 = num.words[j8] | 0;
            var r7 = a9 * b10;
            var lo2 = r7 & 67108863;
            ncarry = ncarry + (r7 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k8] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k8] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x8, y10) {
        this.x = x8;
        this.y = y10;
      }
      FFTM.prototype.makeRBT = function makeRBT(N16) {
        var t8 = new Array(N16);
        var l9 = BN.prototype._countBits(N16) - 1;
        for (var i10 = 0; i10 < N16; i10++) {
          t8[i10] = this.revBin(i10, l9, N16);
        }
        return t8;
      };
      FFTM.prototype.revBin = function revBin(x8, l9, N16) {
        if (x8 === 0 || x8 === N16 - 1)
          return x8;
        var rb = 0;
        for (var i10 = 0; i10 < l9; i10++) {
          rb |= (x8 & 1) << l9 - i10 - 1;
          x8 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N16) {
        for (var i10 = 0; i10 < N16; i10++) {
          rtws[i10] = rws[rbt[i10]];
          itws[i10] = iws[rbt[i10]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N16, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N16);
        for (var s11 = 1; s11 < N16; s11 <<= 1) {
          var l9 = s11 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l9);
          var itwdf = Math.sin(2 * Math.PI / l9);
          for (var p10 = 0; p10 < N16; p10 += l9) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j8 = 0; j8 < s11; j8++) {
              var re6 = rtws[p10 + j8];
              var ie5 = itws[p10 + j8];
              var ro2 = rtws[p10 + j8 + s11];
              var io2 = itws[p10 + j8 + s11];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p10 + j8] = re6 + ro2;
              itws[p10 + j8] = ie5 + io2;
              rtws[p10 + j8 + s11] = re6 - ro2;
              itws[p10 + j8 + s11] = ie5 - io2;
              if (j8 !== l9) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n8, m11) {
        var N16 = Math.max(m11, n8) | 1;
        var odd = N16 & 1;
        var i10 = 0;
        for (N16 = N16 / 2 | 0; N16; N16 = N16 >>> 1) {
          i10++;
        }
        return 1 << i10 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N16) {
        if (N16 <= 1)
          return;
        for (var i10 = 0; i10 < N16 / 2; i10++) {
          var t8 = rws[i10];
          rws[i10] = rws[N16 - i10 - 1];
          rws[N16 - i10 - 1] = t8;
          t8 = iws[i10];
          iws[i10] = -iws[N16 - i10 - 1];
          iws[N16 - i10 - 1] = -t8;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N16) {
        var carry = 0;
        for (var i10 = 0; i10 < N16 / 2; i10++) {
          var w11 = Math.round(ws2[2 * i10 + 1] / N16) * 8192 + Math.round(ws2[2 * i10] / N16) + carry;
          ws2[i10] = w11 & 67108863;
          if (w11 < 67108864) {
            carry = 0;
          } else {
            carry = w11 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N16) {
        var carry = 0;
        for (var i10 = 0; i10 < len; i10++) {
          carry = carry + (ws2[i10] | 0);
          rws[2 * i10] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i10 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i10 = 2 * len; i10 < N16; ++i10) {
          rws[i10] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N16) {
        var ph = new Array(N16);
        for (var i10 = 0; i10 < N16; i10++) {
          ph[i10] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x8, y10, out) {
        var N16 = 2 * this.guessLen13b(x8.length, y10.length);
        var rbt = this.makeRBT(N16);
        var _8 = this.stub(N16);
        var rws = new Array(N16);
        var rwst = new Array(N16);
        var iwst = new Array(N16);
        var nrws = new Array(N16);
        var nrwst = new Array(N16);
        var niwst = new Array(N16);
        var rmws = out.words;
        rmws.length = N16;
        this.convert13b(x8.words, x8.length, rws, N16);
        this.convert13b(y10.words, y10.length, nrws, N16);
        this.transform(rws, _8, rwst, iwst, N16, rbt);
        this.transform(nrws, _8, nrwst, niwst, N16, rbt);
        for (var i10 = 0; i10 < N16; i10++) {
          var rx = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
          iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
          rwst[i10] = rx;
        }
        this.conjugate(rwst, iwst, N16);
        this.transform(rwst, iwst, rmws, _8, N16, rbt);
        this.conjugate(rmws, _8, N16);
        this.normalize13b(rmws, N16);
        out.negative = x8.negative ^ y10.negative;
        out.length = x8.length + y10.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i10 = 0; i10 < this.length; i10++) {
          var w11 = (this.words[i10] | 0) * num;
          var lo2 = (w11 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w11 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i10] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i10] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w11 = toBitArray(num);
        if (w11.length === 0)
          return new BN(1);
        var res = this;
        for (var i10 = 0; i10 < w11.length; i10++, res = res.sqr()) {
          if (w11[i10] !== 0)
            break;
        }
        if (++i10 < w11.length) {
          for (var q8 = res.sqr(); i10 < w11.length; i10++, q8 = q8.sqr()) {
            if (w11[i10] === 0)
              continue;
            res = res.mul(q8);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r7 = bits % 26;
        var s11 = (bits - r7) / 26;
        var carryMask = 67108863 >>> 26 - r7 << 26 - r7;
        var i10;
        if (r7 !== 0) {
          var carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            var newCarry = this.words[i10] & carryMask;
            var c8 = (this.words[i10] | 0) - newCarry << r7;
            this.words[i10] = c8 | carry;
            carry = newCarry >>> 26 - r7;
          }
          if (carry) {
            this.words[i10] = carry;
            this.length++;
          }
        }
        if (s11 !== 0) {
          for (i10 = this.length - 1; i10 >= 0; i10--) {
            this.words[i10 + s11] = this.words[i10];
          }
          for (i10 = 0; i10 < s11; i10++) {
            this.words[i10] = 0;
          }
          this.length += s11;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h11;
        if (hint) {
          h11 = (hint - hint % 26) / 26;
        } else {
          h11 = 0;
        }
        var r7 = bits % 26;
        var s11 = Math.min((bits - r7) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r7 << r7;
        var maskedWords = extended;
        h11 -= s11;
        h11 = Math.max(0, h11);
        if (maskedWords) {
          for (var i10 = 0; i10 < s11; i10++) {
            maskedWords.words[i10] = this.words[i10];
          }
          maskedWords.length = s11;
        }
        if (s11 === 0) {
        } else if (this.length > s11) {
          this.length -= s11;
          for (i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = this.words[i10 + s11];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h11); i10--) {
          var word = this.words[i10] | 0;
          this.words[i10] = carry << 26 - r7 | word >>> r7;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r7 = bit % 26;
        var s11 = (bit - r7) / 26;
        var q8 = 1 << r7;
        if (this.length <= s11)
          return false;
        var w11 = this.words[s11];
        return !!(w11 & q8);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r7 = bits % 26;
        var s11 = (bits - r7) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s11) {
          return this;
        }
        if (r7 !== 0) {
          s11++;
        }
        this.length = Math.min(s11, this.length);
        if (r7 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r7 << r7;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
          this.words[i10] -= 67108864;
          if (i10 === this.length - 1) {
            this.words[i10 + 1] = 1;
          } else {
            this.words[i10 + 1]++;
          }
        }
        this.length = Math.max(this.length, i10 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
            this.words[i10] += 67108864;
            this.words[i10 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i10;
        this._expand(len);
        var w11;
        var carry = 0;
        for (i10 = 0; i10 < num.length; i10++) {
          w11 = (this.words[i10 + shift] | 0) + carry;
          var right = (num.words[i10] | 0) * mul;
          w11 -= right & 67108863;
          carry = (w11 >> 26) - (right / 67108864 | 0);
          this.words[i10 + shift] = w11 & 67108863;
        }
        for (; i10 < this.length - shift; i10++) {
          w11 = (this.words[i10 + shift] | 0) + carry;
          carry = w11 >> 26;
          this.words[i10 + shift] = w11 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i10 = 0; i10 < this.length; i10++) {
          w11 = -(this.words[i10] | 0) + carry;
          carry = w11 >> 26;
          this.words[i10] = w11 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a9 = this.clone();
        var b10 = num;
        var bhi = b10.words[b10.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b10 = b10.ushln(shift);
          a9.iushln(shift);
          bhi = b10.words[b10.length - 1] | 0;
        }
        var m11 = a9.length - b10.length;
        var q8;
        if (mode !== "mod") {
          q8 = new BN(null);
          q8.length = m11 + 1;
          q8.words = new Array(q8.length);
          for (var i10 = 0; i10 < q8.length; i10++) {
            q8.words[i10] = 0;
          }
        }
        var diff = a9.clone()._ishlnsubmul(b10, 1, m11);
        if (diff.negative === 0) {
          a9 = diff;
          if (q8) {
            q8.words[m11] = 1;
          }
        }
        for (var j8 = m11 - 1; j8 >= 0; j8--) {
          var qj = (a9.words[b10.length + j8] | 0) * 67108864 + (a9.words[b10.length + j8 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a9._ishlnsubmul(b10, qj, j8);
          while (a9.negative !== 0) {
            qj--;
            a9.negative = 0;
            a9._ishlnsubmul(b10, 1, j8);
            if (!a9.isZero()) {
              a9.negative ^= 1;
            }
          }
          if (q8) {
            q8.words[j8] = qj;
          }
        }
        if (q8) {
          q8.strip();
        }
        a9.strip();
        if (mode !== "div" && shift !== 0) {
          a9.iushrn(shift);
        }
        return {
          div: q8 || null,
          mod: a9
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p10 = (1 << 26) % num;
        var acc = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          acc = (p10 * acc + (this.words[i10] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          var w11 = (this.words[i10] | 0) + carry * 67108864;
          this.words[i10] = w11 / num | 0;
          carry = w11 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p10) {
        assert3(p10.negative === 0);
        assert3(!p10.isZero());
        var x8 = this;
        var y10 = p10.clone();
        if (x8.negative !== 0) {
          x8 = x8.umod(p10);
        } else {
          x8 = x8.clone();
        }
        var A10 = new BN(1);
        var B9 = new BN(0);
        var C10 = new BN(0);
        var D7 = new BN(1);
        var g9 = 0;
        while (x8.isEven() && y10.isEven()) {
          x8.iushrn(1);
          y10.iushrn(1);
          ++g9;
        }
        var yp = y10.clone();
        var xp = x8.clone();
        while (!x8.isZero()) {
          for (var i10 = 0, im = 1; (x8.words[0] & im) === 0 && i10 < 26; ++i10, im <<= 1)
            ;
          if (i10 > 0) {
            x8.iushrn(i10);
            while (i10-- > 0) {
              if (A10.isOdd() || B9.isOdd()) {
                A10.iadd(yp);
                B9.isub(xp);
              }
              A10.iushrn(1);
              B9.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (y10.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            y10.iushrn(j8);
            while (j8-- > 0) {
              if (C10.isOdd() || D7.isOdd()) {
                C10.iadd(yp);
                D7.isub(xp);
              }
              C10.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x8.cmp(y10) >= 0) {
            x8.isub(y10);
            A10.isub(C10);
            B9.isub(D7);
          } else {
            y10.isub(x8);
            C10.isub(A10);
            D7.isub(B9);
          }
        }
        return {
          a: C10,
          b: D7,
          gcd: y10.iushln(g9)
        };
      };
      BN.prototype._invmp = function _invmp(p10) {
        assert3(p10.negative === 0);
        assert3(!p10.isZero());
        var a9 = this;
        var b10 = p10.clone();
        if (a9.negative !== 0) {
          a9 = a9.umod(p10);
        } else {
          a9 = a9.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b10.clone();
        while (a9.cmpn(1) > 0 && b10.cmpn(1) > 0) {
          for (var i10 = 0, im = 1; (a9.words[0] & im) === 0 && i10 < 26; ++i10, im <<= 1)
            ;
          if (i10 > 0) {
            a9.iushrn(i10);
            while (i10-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j8 = 0, jm = 1; (b10.words[0] & jm) === 0 && j8 < 26; ++j8, jm <<= 1)
            ;
          if (j8 > 0) {
            b10.iushrn(j8);
            while (j8-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a9.cmp(b10) >= 0) {
            a9.isub(b10);
            x1.isub(x22);
          } else {
            b10.isub(a9);
            x22.isub(x1);
          }
        }
        var res;
        if (a9.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p10);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a9 = this.clone();
        var b10 = num.clone();
        a9.negative = 0;
        b10.negative = 0;
        for (var shift = 0; a9.isEven() && b10.isEven(); shift++) {
          a9.iushrn(1);
          b10.iushrn(1);
        }
        do {
          while (a9.isEven()) {
            a9.iushrn(1);
          }
          while (b10.isEven()) {
            b10.iushrn(1);
          }
          var r7 = a9.cmp(b10);
          if (r7 < 0) {
            var t8 = a9;
            a9 = b10;
            b10 = t8;
          } else if (r7 === 0 || b10.cmpn(1) === 0) {
            break;
          }
          a9.isub(b10);
        } while (true);
        return b10.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r7 = bit % 26;
        var s11 = (bit - r7) / 26;
        var q8 = 1 << r7;
        if (this.length <= s11) {
          this._expand(s11 + 1);
          this.words[s11] |= q8;
          return this;
        }
        var carry = q8;
        for (var i10 = s11; carry !== 0 && i10 < this.length; i10++) {
          var w11 = this.words[i10] | 0;
          w11 += carry;
          carry = w11 >>> 26;
          w11 &= 67108863;
          this.words[i10] = w11;
        }
        if (carry !== 0) {
          this.words[i10] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w11 = this.words[0] | 0;
          res = w11 === num ? 0 : w11 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i10 = this.length - 1; i10 >= 0; i10--) {
          var a9 = this.words[i10] | 0;
          var b10 = num.words[i10] | 0;
          if (a9 === b10)
            continue;
          if (a9 < b10) {
            res = -1;
          } else if (a9 > b10) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt4(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt4(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p10) {
        this.name = name2;
        this.p = new BN(p10, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r7 = num;
        var rlen;
        do {
          this.split(r7, this.tmp);
          r7 = this.imulK(r7);
          r7 = r7.iadd(this.tmp);
          rlen = r7.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r7.ucmp(this.p);
        if (cmp === 0) {
          r7.words[0] = 0;
          r7.length = 1;
        } else if (cmp > 0) {
          r7.isub(this.p);
        } else {
          if (r7.strip !== void 0) {
            r7.strip();
          } else {
            r7._strip();
          }
        }
        return r7;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i10 = 0; i10 < outLen; i10++) {
          output.words[i10] = input.words[i10];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i10 = 10; i10 < input.length; i10++) {
          var next = input.words[i10] | 0;
          input.words[i10 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i10 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i10 = 0; i10 < num.length; i10++) {
          var w11 = num.words[i10] | 0;
          lo2 += w11 * 977;
          num.words[i10] = lo2 & 67108863;
          lo2 = w11 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i10 = 0; i10 < num.length; i10++) {
          var hi = (num.words[i10] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i10] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m11) {
        if (typeof m11 === "string") {
          var prime = BN._prime(m11);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m11.gtn(1), "modulus must be greater than 1");
          this.m = m11;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a9) {
        assert3(a9.negative === 0, "red works only with positives");
        assert3(a9.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a9, b10) {
        assert3((a9.negative | b10.negative) === 0, "red works only with positives");
        assert3(
          a9.red && a9.red === b10.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a9) {
        if (this.prime)
          return this.prime.ireduce(a9)._forceRed(this);
        return a9.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a9) {
        if (a9.isZero()) {
          return a9.clone();
        }
        return this.m.sub(a9)._forceRed(this);
      };
      Red.prototype.add = function add(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.add(b10);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.iadd(b10);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.sub(b10);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a9, b10) {
        this._verify2(a9, b10);
        var res = a9.isub(b10);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a9, num) {
        this._verify1(a9);
        return this.imod(a9.ushln(num));
      };
      Red.prototype.imul = function imul(a9, b10) {
        this._verify2(a9, b10);
        return this.imod(a9.imul(b10));
      };
      Red.prototype.mul = function mul(a9, b10) {
        this._verify2(a9, b10);
        return this.imod(a9.mul(b10));
      };
      Red.prototype.isqr = function isqr(a9) {
        return this.imul(a9, a9.clone());
      };
      Red.prototype.sqr = function sqr(a9) {
        return this.mul(a9, a9);
      };
      Red.prototype.sqrt = function sqrt(a9) {
        if (a9.isZero())
          return a9.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a9, pow);
        }
        var q8 = this.m.subn(1);
        var s11 = 0;
        while (!q8.isZero() && q8.andln(1) === 0) {
          s11++;
          q8.iushrn(1);
        }
        assert3(!q8.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z8 = this.m.bitLength();
        z8 = new BN(2 * z8 * z8).toRed(this);
        while (this.pow(z8, lpow).cmp(nOne) !== 0) {
          z8.redIAdd(nOne);
        }
        var c8 = this.pow(z8, q8);
        var r7 = this.pow(a9, q8.addn(1).iushrn(1));
        var t8 = this.pow(a9, q8);
        var m11 = s11;
        while (t8.cmp(one) !== 0) {
          var tmp = t8;
          for (var i10 = 0; tmp.cmp(one) !== 0; i10++) {
            tmp = tmp.redSqr();
          }
          assert3(i10 < m11);
          var b10 = this.pow(c8, new BN(1).iushln(m11 - i10 - 1));
          r7 = r7.redMul(b10);
          c8 = b10.redSqr();
          t8 = t8.redMul(c8);
          m11 = i10;
        }
        return r7;
      };
      Red.prototype.invm = function invm(a9) {
        var inv = a9._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a9, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a9.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a9;
        for (var i10 = 2; i10 < wnd.length; i10++) {
          wnd[i10] = this.mul(wnd[i10 - 1], a9);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i10 = num.length - 1; i10 >= 0; i10--) {
          var word = num.words[i10];
          for (var j8 = start - 1; j8 >= 0; j8--) {
            var bit = word >> j8 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i10 !== 0 || j8 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r7 = num.umod(this.m);
        return r7 === num ? r7.clone() : r7;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m11) {
        Red.call(this, m11);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r7 = this.imod(num.mul(this.rinv));
        r7.red = null;
        return r7;
      };
      Mont.prototype.imul = function imul(a9, b10) {
        if (a9.isZero() || b10.isZero()) {
          a9.words[0] = 0;
          a9.length = 1;
          return a9;
        }
        var t8 = a9.imul(b10);
        var c8 = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u9 = t8.isub(c8).iushrn(this.shift);
        var res = u9;
        if (u9.cmp(this.m) >= 0) {
          res = u9.isub(this.m);
        } else if (u9.cmpn(0) < 0) {
          res = u9.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a9, b10) {
        if (a9.isZero() || b10.isZero())
          return new BN(0)._forceRed(this);
        var t8 = a9.mul(b10);
        var c8 = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u9 = t8.isub(c8).iushrn(this.shift);
        var res = u9;
        if (u9.cmp(this.m) >= 0) {
          res = u9.isub(this.m);
        } else if (u9.cmpn(0) < 0) {
          res = u9.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a9) {
        var res = this.imod(a9._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual(l9, r7, msg) {
      if (l9 != r7)
        throw new Error(msg || "Assertion failed: " + l9 + " != " + r7);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i10 = 0; i10 < msg.length; i10++)
          res[i10] = msg[i10] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i10 = 0; i10 < msg.length; i10 += 2)
          res.push(parseInt(msg[i10] + msg[i10 + 1], 16));
      } else {
        for (var i10 = 0; i10 < msg.length; i10++) {
          var c8 = msg.charCodeAt(i10);
          var hi = c8 >> 8;
          var lo2 = c8 & 255;
          if (hi)
            res.push(hi, lo2);
          else
            res.push(lo2);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i10 = 0; i10 < msg.length; i10++)
        res += zero2(msg[i10].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode5(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w11, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws2 = 1 << w11 + 1;
      var k8 = num.clone();
      for (var i10 = 0; i10 < naf.length; i10++) {
        var z8;
        var mod = k8.andln(ws2 - 1);
        if (k8.isOdd()) {
          if (mod > (ws2 >> 1) - 1)
            z8 = (ws2 >> 1) - mod;
          else
            z8 = mod;
          k8.isubn(z8);
        } else {
          z8 = 0;
        }
        naf[i10] = z8;
        k8.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m82;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m82 = k1.andln(7) + d1 & 7;
          if ((m82 === 3 || m82 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m82 = k22.andln(7) + d22 & 7;
          if ((m82 === 3 || m82 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name2, computer) {
      var key = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r7;
    module.exports = function rand(len) {
      if (!r7)
        r7 = new Rand(null);
      return r7.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n8) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n8);
      var res = new Uint8Array(n8);
      for (var i10 = 0; i10 < res.length; i10++)
        res[i10] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n8) {
          var arr = new Uint8Array(n8);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n8) {
          var arr = new Uint8Array(n8);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n8) {
          return crypto2.randomBytes(n8);
        };
      } catch (e11) {
      }
    }
    var crypto2;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert3 = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p10, k8) {
      assert3(p10.precomputed);
      var doubles = p10._getDoubles();
      var naf = getNAF(k8, 1, this._bitLength);
      var I9 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I9 /= 3;
      var repr = [];
      var j8;
      var nafW;
      for (j8 = 0; j8 < naf.length; j8 += doubles.step) {
        nafW = 0;
        for (var l9 = j8 + doubles.step - 1; l9 >= j8; l9--)
          nafW = (nafW << 1) + naf[l9];
        repr.push(nafW);
      }
      var a9 = this.jpoint(null, null, null);
      var b10 = this.jpoint(null, null, null);
      for (var i10 = I9; i10 > 0; i10--) {
        for (j8 = 0; j8 < repr.length; j8++) {
          nafW = repr[j8];
          if (nafW === i10)
            b10 = b10.mixedAdd(doubles.points[j8]);
          else if (nafW === -i10)
            b10 = b10.mixedAdd(doubles.points[j8].neg());
        }
        a9 = a9.add(b10);
      }
      return a9.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p10, k8) {
      var w11 = 4;
      var nafPoints = p10._getNAFPoints(w11);
      w11 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k8, w11, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i10 = naf.length - 1; i10 >= 0; i10--) {
        for (var l9 = 0; i10 >= 0 && naf[i10] === 0; i10--)
          l9++;
        if (i10 >= 0)
          l9++;
        acc = acc.dblp(l9);
        if (i10 < 0)
          break;
        var z8 = naf[i10];
        assert3(z8 !== 0);
        if (p10.type === "affine") {
          if (z8 > 0)
            acc = acc.mixedAdd(wnd[z8 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z8 - 1 >> 1].neg());
        } else {
          if (z8 > 0)
            acc = acc.add(wnd[z8 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z8 - 1 >> 1].neg());
        }
      }
      return p10.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i10;
      var j8;
      var p10;
      for (i10 = 0; i10 < len; i10++) {
        p10 = points[i10];
        var nafPoints = p10._getNAFPoints(defW);
        wndWidth[i10] = nafPoints.wnd;
        wnd[i10] = nafPoints.points;
      }
      for (i10 = len - 1; i10 >= 1; i10 -= 2) {
        var a9 = i10 - 1;
        var b10 = i10;
        if (wndWidth[a9] !== 1 || wndWidth[b10] !== 1) {
          naf[a9] = getNAF(coeffs[a9], wndWidth[a9], this._bitLength);
          naf[b10] = getNAF(coeffs[b10], wndWidth[b10], this._bitLength);
          max = Math.max(naf[a9].length, max);
          max = Math.max(naf[b10].length, max);
          continue;
        }
        var comb = [
          points[a9],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b10]
          /* 7 */
        ];
        if (points[a9].y.cmp(points[b10].y) === 0) {
          comb[1] = points[a9].add(points[b10]);
          comb[2] = points[a9].toJ().mixedAdd(points[b10].neg());
        } else if (points[a9].y.cmp(points[b10].y.redNeg()) === 0) {
          comb[1] = points[a9].toJ().mixedAdd(points[b10]);
          comb[2] = points[a9].add(points[b10].neg());
        } else {
          comb[1] = points[a9].toJ().mixedAdd(points[b10]);
          comb[2] = points[a9].toJ().mixedAdd(points[b10].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a9], coeffs[b10]);
        max = Math.max(jsf[0].length, max);
        naf[a9] = new Array(max);
        naf[b10] = new Array(max);
        for (j8 = 0; j8 < max; j8++) {
          var ja2 = jsf[0][j8] | 0;
          var jb = jsf[1][j8] | 0;
          naf[a9][j8] = index[(ja2 + 1) * 3 + (jb + 1)];
          naf[b10][j8] = 0;
          wnd[a9] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i10 = max; i10 >= 0; i10--) {
        var k8 = 0;
        while (i10 >= 0) {
          var zero = true;
          for (j8 = 0; j8 < len; j8++) {
            tmp[j8] = naf[j8][i10] | 0;
            if (tmp[j8] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k8++;
          i10--;
        }
        if (i10 >= 0)
          k8++;
        acc = acc.dblp(k8);
        if (i10 < 0)
          break;
        for (j8 = 0; j8 < len; j8++) {
          var z8 = tmp[j8];
          p10;
          if (z8 === 0)
            continue;
          else if (z8 > 0)
            p10 = wnd[j8][z8 - 1 >> 1];
          else if (z8 < 0)
            p10 = wnd[j8][-z8 - 1 >> 1].neg();
          if (p10.type === "affine")
            acc = acc.mixedAdd(p10);
          else
            acc = acc.add(p10);
        }
      }
      for (i10 = 0; i10 < len; i10++)
        wnd[i10] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert3(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert3(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x8 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x8);
      return [4].concat(x8, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode5(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k8) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k8.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i10 = 0; i10 < power; i10 += step) {
        for (var j8 = 0; j8 < step; j8++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i10 = 1; i10 < max; i10++)
        res[i10] = res[i10 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k8) {
      var r7 = this;
      for (var i10 = 0; i10 < k8; i10++)
        r7 = r7.dbl();
      return r7;
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert3(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s11 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s11).fromRed();
      var l22 = ntinv.redSub(s11).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u9 = lambda;
      var v7 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i10 = 0;
      var r7;
      var x8;
      while (u9.cmpn(0) !== 0) {
        var q8 = v7.div(u9);
        r7 = v7.sub(q8.mul(u9));
        x8 = x22.sub(q8.mul(x1));
        var y10 = y22.sub(q8.mul(y1));
        if (!a1 && r7.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r7.neg();
          b1 = x8;
        } else if (a1 && ++i10 === 2) {
          break;
        }
        prevR = r7;
        v7 = u9;
        u9 = r7;
        x22 = x1;
        x1 = x8;
        y22 = y1;
        y1 = y10;
      }
      a22 = r7.neg();
      b22 = x8;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k8) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k8).divRound(this.n);
      var c22 = v1.b.neg().mul(k8).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k8.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var y22 = x8.redSqr().redMul(x8).redIAdd(x8.redMul(this.a)).redIAdd(this.b);
      var y10 = y22.redSqrt();
      if (y10.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y10.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y10 = y10.redNeg();
      return this.point(x8, y10);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x8 = point.x;
      var y10 = point.y;
      var ax = this.a.redMul(x8);
      var rhs = x8.redSqr().redMul(x8).redIAdd(ax).redIAdd(this.b);
      return y10.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i10 = 0; i10 < points.length; i10++) {
        var split = this._endoSplit(coeffs[i10]);
        var p10 = points[i10];
        var beta = p10._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p10 = p10.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i10 * 2] = p10;
        npoints[i10 * 2 + 1] = beta;
        ncoeffs[i10 * 2] = split.k1;
        ncoeffs[i10 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i10 * 2, jacobianResult);
      for (var j8 = 0; j8 < i10 * 2; j8++) {
        npoints[j8] = null;
        ncoeffs[j8] = null;
      }
      return res;
    };
    function Point(curve, x8, y10, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x8 === null && y10 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y10, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x8, y10, isRed) {
      return new Point(this, x8, y10, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p10) {
          return curve.point(p10.x.redMul(curve.endo.beta), p10.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p10) {
      if (this.inf)
        return p10;
      if (p10.inf)
        return this;
      if (this.eq(p10))
        return this.dbl();
      if (this.neg().eq(p10))
        return this.curve.point(null, null);
      if (this.x.cmp(p10.x) === 0)
        return this.curve.point(null, null);
      var c8 = this.y.redSub(p10.y);
      if (c8.cmpn(0) !== 0)
        c8 = c8.redMul(this.x.redSub(p10.x).redInvm());
      var nx = c8.redSqr().redISub(this.x).redISub(p10.x);
      var ny = c8.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a9 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c8 = x22.redAdd(x22).redIAdd(x22).redIAdd(a9).redMul(dyinv);
      var nx = c8.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c8.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k8) {
      k8 = new BN(k8, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k8))
        return this.curve._fixedNafMul(this, k8);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k8]);
      else
        return this.curve._wnafMul(this, k8);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p10) {
      return this === p10 || this.inf === p10.inf && (this.inf || this.x.cmp(p10.x) === 0 && this.y.cmp(p10.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p10) {
          return p10.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x8, y10, z8) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x8 === null && y10 === null && z8 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y10, 16);
        this.z = new BN(z8, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x8, y10, z8) {
      return new JPoint(this, x8, y10, z8);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p10) {
      if (this.isInfinity())
        return p10;
      if (p10.isInfinity())
        return this;
      var pz2 = p10.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p10.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p10.z));
      var s22 = p10.y.redMul(z22.redMul(this.z));
      var h11 = u1.redSub(u22);
      var r7 = s1.redSub(s22);
      if (h11.cmpn(0) === 0) {
        if (r7.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h11.redSqr();
      var h32 = h22.redMul(h11);
      var v7 = u1.redMul(h22);
      var nx = r7.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r7.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p10.z).redMul(h11);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p10) {
      if (this.isInfinity())
        return p10.toJ();
      if (p10.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p10.x.redMul(z22);
      var s1 = this.y;
      var s22 = p10.y.redMul(z22).redMul(this.z);
      var h11 = u1.redSub(u22);
      var r7 = s1.redSub(s22);
      if (h11.cmpn(0) === 0) {
        if (r7.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h11.redSqr();
      var h32 = h22.redMul(h11);
      var v7 = u1.redMul(h22);
      var nx = r7.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r7.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h11);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i10;
      if (this.curve.zeroA || this.curve.threeA) {
        var r7 = this;
        for (i10 = 0; i10 < pow; i10++)
          r7 = r7.dbl();
        return r7;
      }
      var a9 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i10 = 0; i10 < pow; i10++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c8 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a9.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c8.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var dny = c8.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i10 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s11 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s11 = s11.redIAdd(s11);
        var m11 = xx.redAdd(xx).redIAdd(xx);
        var t8 = m11.redSqr().redISub(s11).redISub(s11);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t8;
        ny = m11.redMul(s11.redISub(t8)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a9 = this.x.redSqr();
        var b10 = this.y.redSqr();
        var c8 = b10.redSqr();
        var d9 = this.x.redAdd(b10).redSqr().redISub(a9).redISub(c8);
        d9 = d9.redIAdd(d9);
        var e11 = a9.redAdd(a9).redIAdd(a9);
        var f7 = e11.redSqr();
        var c82 = c8.redIAdd(c8);
        c82 = c82.redIAdd(c82);
        c82 = c82.redIAdd(c82);
        nx = f7.redISub(d9).redISub(d9);
        ny = e11.redMul(d9.redISub(nx)).redISub(c82);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s11 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s11 = s11.redIAdd(s11);
        var m11 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t8 = m11.redSqr().redISub(s11).redISub(s11);
        nx = t8;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m11.redMul(s11.redISub(t8)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a9 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c8 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a9.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c8.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c8.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m11 = xx.redAdd(xx).redIAdd(xx);
      var mm = m11.redSqr();
      var e11 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e11 = e11.redIAdd(e11);
      e11 = e11.redAdd(e11).redIAdd(e11);
      e11 = e11.redISub(mm);
      var ee3 = e11.redSqr();
      var t8 = yyyy.redIAdd(yyyy);
      t8 = t8.redIAdd(t8);
      t8 = t8.redIAdd(t8);
      t8 = t8.redIAdd(t8);
      var u9 = m11.redIAdd(e11).redSqr().redISub(mm).redISub(ee3).redISub(t8);
      var yyu4 = yy.redMul(u9);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee3).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u9.redMul(t8.redISub(u9)).redISub(e11.redMul(ee3)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e11).redSqr().redISub(zz).redISub(ee3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k8, kbase) {
      k8 = new BN(k8, kbase);
      return this.curve._wnafMul(this, k8);
    };
    JPoint.prototype.eq = function eq(p10) {
      if (p10.type === "affine")
        return this.eq(p10.toJ());
      if (this === p10)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p10.z.redSqr();
      if (this.x.redMul(pz2).redISub(p10.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p10.z);
      return this.y.redMul(pz3).redISub(p10.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x8) {
      var zs2 = this.z.redSqr();
      var rx = x8.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t8 = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t8);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x8 = point.normalize().x;
      var x22 = x8.redSqr();
      var rhs = x22.redMul(x8).redAdd(x22.redMul(this.a)).redAdd(x8);
      var y10 = rhs.redSqrt();
      return y10.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x8, z8) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && z8 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x8, 16);
        this.z = new BN(z8, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x8, z8) {
      return new Point(this, x8, z8);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a9 = this.x.redAdd(this.z);
      var aa2 = a9.redSqr();
      var b10 = this.x.redSub(this.z);
      var bb = b10.redSqr();
      var c8 = aa2.redSub(bb);
      var nx = aa2.redMul(bb);
      var nz = c8.redMul(bb.redAdd(this.curve.a24.redMul(c8)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p10, diff) {
      var a9 = this.x.redAdd(this.z);
      var b10 = this.x.redSub(this.z);
      var c8 = p10.x.redAdd(p10.z);
      var d9 = p10.x.redSub(p10.z);
      var da2 = d9.redMul(a9);
      var cb = c8.redMul(b10);
      var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da2.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k8) {
      var t8 = k8.clone();
      var a9 = this;
      var b10 = this.curve.point(null, null);
      var c8 = this;
      for (var bits = []; t8.cmpn(0) !== 0; t8.iushrn(1))
        bits.push(t8.andln(1));
      for (var i10 = bits.length - 1; i10 >= 0; i10--) {
        if (bits[i10] === 0) {
          a9 = a9.diffAdd(b10, c8);
          b10 = b10.dbl();
        } else {
          b10 = a9.diffAdd(b10, c8);
          a9 = a9.dbl();
        }
      }
      return b10;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert3(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x8, y10, z8, t8) {
      return this.point(x8, y10, z8, t8);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var x22 = x8.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y10 = y22.redSqrt();
      if (y10.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y10.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y10 = y10.redNeg();
      return this.point(x8, y10);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y10, odd) {
      y10 = new BN(y10, 16);
      if (!y10.red)
        y10 = y10.toRed(this.red);
      var y22 = y10.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y10);
      }
      var x8 = x22.redSqrt();
      if (x8.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x8.fromRed().isOdd() !== odd)
        x8 = x8.redNeg();
      return this.point(x8, y10);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x8, y10, z8, t8) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && y10 === null && z8 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y10, 16);
        this.z = z8 ? new BN(z8, 16) : this.curve.one;
        this.t = t8 && new BN(t8, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x8, y10, z8, t8) {
      return new Point(this, x8, y10, z8, t8);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a9 = this.x.redSqr();
      var b10 = this.y.redSqr();
      var c8 = this.z.redSqr();
      c8 = c8.redIAdd(c8);
      var d9 = this.curve._mulA(a9);
      var e11 = this.x.redAdd(this.y).redSqr().redISub(a9).redISub(b10);
      var g9 = d9.redAdd(b10);
      var f7 = g9.redSub(c8);
      var h11 = d9.redSub(b10);
      var nx = e11.redMul(f7);
      var ny = g9.redMul(h11);
      var nt4 = e11.redMul(h11);
      var nz = f7.redMul(g9);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b10 = this.x.redAdd(this.y).redSqr();
      var c8 = this.x.redSqr();
      var d9 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e11;
      var h11;
      var j8;
      if (this.curve.twisted) {
        e11 = this.curve._mulA(c8);
        var f7 = e11.redAdd(d9);
        if (this.zOne) {
          nx = b10.redSub(c8).redSub(d9).redMul(f7.redSub(this.curve.two));
          ny = f7.redMul(e11.redSub(d9));
          nz = f7.redSqr().redSub(f7).redSub(f7);
        } else {
          h11 = this.z.redSqr();
          j8 = f7.redSub(h11).redISub(h11);
          nx = b10.redSub(c8).redISub(d9).redMul(j8);
          ny = f7.redMul(e11.redSub(d9));
          nz = f7.redMul(j8);
        }
      } else {
        e11 = c8.redAdd(d9);
        h11 = this.curve._mulC(this.z).redSqr();
        j8 = e11.redSub(h11).redSub(h11);
        nx = this.curve._mulC(b10.redISub(e11)).redMul(j8);
        ny = this.curve._mulC(e11).redMul(c8.redISub(d9));
        nz = e11.redMul(j8);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p10) {
      var a9 = this.y.redSub(this.x).redMul(p10.y.redSub(p10.x));
      var b10 = this.y.redAdd(this.x).redMul(p10.y.redAdd(p10.x));
      var c8 = this.t.redMul(this.curve.dd).redMul(p10.t);
      var d9 = this.z.redMul(p10.z.redAdd(p10.z));
      var e11 = b10.redSub(a9);
      var f7 = d9.redSub(c8);
      var g9 = d9.redAdd(c8);
      var h11 = b10.redAdd(a9);
      var nx = e11.redMul(f7);
      var ny = g9.redMul(h11);
      var nt4 = e11.redMul(h11);
      var nz = f7.redMul(g9);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projAdd = function _projAdd(p10) {
      var a9 = this.z.redMul(p10.z);
      var b10 = a9.redSqr();
      var c8 = this.x.redMul(p10.x);
      var d9 = this.y.redMul(p10.y);
      var e11 = this.curve.d.redMul(c8).redMul(d9);
      var f7 = b10.redSub(e11);
      var g9 = b10.redAdd(e11);
      var tmp = this.x.redAdd(this.y).redMul(p10.x.redAdd(p10.y)).redISub(c8).redISub(d9);
      var nx = a9.redMul(f7).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a9.redMul(g9).redMul(d9.redSub(this.curve._mulA(c8)));
        nz = f7.redMul(g9);
      } else {
        ny = a9.redMul(g9).redMul(d9.redSub(c8));
        nz = this.curve._mulC(f7).redMul(g9);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p10) {
      if (this.isInfinity())
        return p10;
      if (p10.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p10);
      else
        return this._projAdd(p10);
    };
    Point.prototype.mul = function mul(k8) {
      if (this._hasDoubles(k8))
        return this.curve._fixedNafMul(this, k8);
      else
        return this.curve._wnafMul(this, k8);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p10, k22) {
      return this.curve._wnafMulAdd(1, [this, p10], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p10, k22) {
      return this.curve._wnafMulAdd(1, [this, p10], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x8) {
      var rx = x8.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t8 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t8);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i10) {
      if ((msg.charCodeAt(i10) & 64512) !== 55296) {
        return false;
      }
      if (i10 < 0 || i10 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i10 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p10 = 0;
          for (var i10 = 0; i10 < msg.length; i10++) {
            var c8 = msg.charCodeAt(i10);
            if (c8 < 128) {
              res[p10++] = c8;
            } else if (c8 < 2048) {
              res[p10++] = c8 >> 6 | 192;
              res[p10++] = c8 & 63 | 128;
            } else if (isSurrogatePair(msg, i10)) {
              c8 = 65536 + ((c8 & 1023) << 10) + (msg.charCodeAt(++i10) & 1023);
              res[p10++] = c8 >> 18 | 240;
              res[p10++] = c8 >> 12 & 63 | 128;
              res[p10++] = c8 >> 6 & 63 | 128;
              res[p10++] = c8 & 63 | 128;
            } else {
              res[p10++] = c8 >> 12 | 224;
              res[p10++] = c8 >> 6 & 63 | 128;
              res[p10++] = c8 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i10 = 0; i10 < msg.length; i10 += 2)
            res.push(parseInt(msg[i10] + msg[i10 + 1], 16));
        }
      } else {
        for (i10 = 0; i10 < msg.length; i10++)
          res[i10] = msg[i10] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i10 = 0; i10 < msg.length; i10++)
        res += zero2(msg[i10].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w11) {
      var res = w11 >>> 24 | w11 >>> 8 & 65280 | w11 << 8 & 16711680 | (w11 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i10 = 0; i10 < msg.length; i10++) {
        var w11 = msg[i10];
        if (endian === "little")
          w11 = htonl(w11);
        res += zero8(w11.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i10 = 0, k8 = start; i10 < res.length; i10++, k8 += 4) {
        var w11;
        if (endian === "big")
          w11 = msg[k8] << 24 | msg[k8 + 1] << 16 | msg[k8 + 2] << 8 | msg[k8 + 3];
        else
          w11 = msg[k8 + 3] << 24 | msg[k8 + 2] << 16 | msg[k8 + 1] << 8 | msg[k8];
        res[i10] = w11 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i10 = 0, k8 = 0; i10 < msg.length; i10++, k8 += 4) {
        var m11 = msg[i10];
        if (endian === "big") {
          res[k8] = m11 >>> 24;
          res[k8 + 1] = m11 >>> 16 & 255;
          res[k8 + 2] = m11 >>> 8 & 255;
          res[k8 + 3] = m11 & 255;
        } else {
          res[k8 + 3] = m11 >>> 24;
          res[k8 + 2] = m11 >>> 16 & 255;
          res[k8 + 1] = m11 >>> 8 & 255;
          res[k8] = m11 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w11, b10) {
      return w11 >>> b10 | w11 << 32 - b10;
    }
    exports.rotr32 = rotr32;
    function rotl32(w11, b10) {
      return w11 << b10 | w11 >>> 32 - b10;
    }
    exports.rotl32 = rotl32;
    function sum32(a9, b10) {
      return a9 + b10 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a9, b10, c8) {
      return a9 + b10 + c8 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a9, b10, c8, d9) {
      return a9 + b10 + c8 + d9 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a9, b10, c8, d9, e11) {
      return a9 + b10 + c8 + d9 + e11 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo2 = al + bl >>> 0;
      var hi = (lo2 < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo2;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo2 = al + bl >>> 0;
      var hi = (lo2 < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo2 = al + bl;
      return lo2 >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo2 = al + bl + cl + dl;
      return lo2 >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      lo2 = lo2 + el >>> 0;
      carry += lo2 < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo2 = al + bl + cl + dl + el;
      return lo2 >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r7 = al << 32 - num | ah >>> num;
      return r7 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r7 = ah << 32 - num | al >>> num;
      return r7 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r7 = ah << 32 - num | al >>> num;
      return r7 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r7 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r7, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r7, this.endian);
        for (var i10 = 0; i10 < msg.length; i10 += this._delta32)
          this._update(msg, i10, i10 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest2(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k8 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k8 + this.padLength);
      res[0] = 128;
      for (var i10 = 1; i10 < k8; i10++)
        res[i10] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t8 = 8; t8 < this.padLength; t8++)
          res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = len >>> 24 & 255;
        res[i10++] = len >>> 16 & 255;
        res[i10++] = len >>> 8 & 255;
        res[i10++] = len & 255;
      } else {
        res[i10++] = len & 255;
        res[i10++] = len >>> 8 & 255;
        res[i10++] = len >>> 16 & 255;
        res[i10++] = len >>> 24 & 255;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        for (t8 = 8; t8 < this.padLength; t8++)
          res[i10++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s11, x8, y10, z8) {
      if (s11 === 0)
        return ch32(x8, y10, z8);
      if (s11 === 1 || s11 === 3)
        return p32(x8, y10, z8);
      if (s11 === 2)
        return maj32(x8, y10, z8);
    }
    exports.ft_1 = ft_1;
    function ch32(x8, y10, z8) {
      return x8 & y10 ^ ~x8 & z8;
    }
    exports.ch32 = ch32;
    function maj32(x8, y10, z8) {
      return x8 & y10 ^ x8 & z8 ^ y10 & z8;
    }
    exports.maj32 = maj32;
    function p32(x8, y10, z8) {
      return x8 ^ y10 ^ z8;
    }
    exports.p32 = p32;
    function s0_256(x8) {
      return rotr32(x8, 2) ^ rotr32(x8, 13) ^ rotr32(x8, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x8) {
      return rotr32(x8, 6) ^ rotr32(x8, 11) ^ rotr32(x8, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x8) {
      return rotr32(x8, 7) ^ rotr32(x8, 18) ^ x8 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x8) {
      return rotr32(x8, 17) ^ rotr32(x8, 19) ^ x8 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 16; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10++)
        W5[i10] = rotl32(W5[i10 - 3] ^ W5[i10 - 8] ^ W5[i10 - 14] ^ W5[i10 - 16], 1);
      var a9 = this.h[0];
      var b10 = this.h[1];
      var c8 = this.h[2];
      var d9 = this.h[3];
      var e11 = this.h[4];
      for (i10 = 0; i10 < W5.length; i10++) {
        var s11 = ~~(i10 / 20);
        var t8 = sum32_5(rotl32(a9, 5), ft_1(s11, b10, c8, d9), e11, W5[i10], sha1_K[s11]);
        e11 = d9;
        d9 = c8;
        c8 = rotl32(b10, 30);
        b10 = a9;
        a9 = t8;
      }
      this.h[0] = sum32(this.h[0], a9);
      this.h[1] = sum32(this.h[1], b10);
      this.h[2] = sum32(this.h[2], c8);
      this.h[3] = sum32(this.h[3], d9);
      this.h[4] = sum32(this.h[4], e11);
    };
    SHA1.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 16; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10++)
        W5[i10] = sum32_4(g1_256(W5[i10 - 2]), W5[i10 - 7], g0_256(W5[i10 - 15]), W5[i10 - 16]);
      var a9 = this.h[0];
      var b10 = this.h[1];
      var c8 = this.h[2];
      var d9 = this.h[3];
      var e11 = this.h[4];
      var f7 = this.h[5];
      var g9 = this.h[6];
      var h11 = this.h[7];
      assert3(this.k.length === W5.length);
      for (i10 = 0; i10 < W5.length; i10++) {
        var T1 = sum32_5(h11, s1_256(e11), ch32(e11, f7, g9), this.k[i10], W5[i10]);
        var T22 = sum32(s0_256(a9), maj32(a9, b10, c8));
        h11 = g9;
        g9 = f7;
        f7 = e11;
        e11 = sum32(d9, T1);
        d9 = c8;
        c8 = b10;
        b10 = a9;
        a9 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a9);
      this.h[1] = sum32(this.h[1], b10);
      this.h[2] = sum32(this.h[2], c8);
      this.h[3] = sum32(this.h[3], d9);
      this.h[4] = sum32(this.h[4], e11);
      this.h[5] = sum32(this.h[5], f7);
      this.h[6] = sum32(this.h[6], g9);
      this.h[7] = sum32(this.h[7], h11);
    };
    SHA256.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 32; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10 += 2) {
        var c0_hi = g1_512_hi(W5[i10 - 4], W5[i10 - 3]);
        var c0_lo = g1_512_lo(W5[i10 - 4], W5[i10 - 3]);
        var c1_hi = W5[i10 - 14];
        var c1_lo = W5[i10 - 13];
        var c2_hi = g0_512_hi(W5[i10 - 30], W5[i10 - 29]);
        var c2_lo = g0_512_lo(W5[i10 - 30], W5[i10 - 29]);
        var c3_hi = W5[i10 - 32];
        var c3_lo = W5[i10 - 31];
        W5[i10] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W5[i10 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W5 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W5.length);
      for (var i10 = 0; i10 < W5.length; i10 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i10];
        var c3_lo = this.k[i10 + 1];
        var c4_hi = W5[i10];
        var c4_lo = W5[i10 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r7 = xh & yh ^ ~xh & zh;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r7 = xl & yl ^ ~xl & zl;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r7 = xh & yh ^ xh & zh ^ yh & zh;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r7 = xl & yl ^ xl & zl ^ yl & zl;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r7 = c0_hi ^ c1_hi ^ c2_hi;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r7 = c0_lo ^ c1_lo ^ c2_lo;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r7 = c0_hi ^ c1_hi ^ c2_hi;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r7 = c0_lo ^ c1_lo ^ c2_lo;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r7 = c0_hi ^ c1_hi ^ c2_hi;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r7 = c0_lo ^ c1_lo ^ c2_lo;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r7 = c0_hi ^ c1_hi ^ c2_hi;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r7 = c0_lo ^ c1_lo ^ c2_lo;
      if (r7 < 0)
        r7 += 4294967296;
      return r7;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A10 = this.h[0];
      var B9 = this.h[1];
      var C10 = this.h[2];
      var D7 = this.h[3];
      var E8 = this.h[4];
      var Ah = A10;
      var Bh = B9;
      var Ch = C10;
      var Dh = D7;
      var Eh = E8;
      for (var j8 = 0; j8 < 80; j8++) {
        var T6 = sum32(
          rotl32(
            sum32_4(A10, f7(j8, B9, C10, D7), msg[r7[j8] + start], K6(j8)),
            s11[j8]
          ),
          E8
        );
        A10 = E8;
        E8 = D7;
        D7 = rotl32(C10, 10);
        C10 = B9;
        B9 = T6;
        T6 = sum32(
          rotl32(
            sum32_4(Ah, f7(79 - j8, Bh, Ch, Dh), msg[rh[j8] + start], Kh(j8)),
            sh[j8]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T6;
      }
      T6 = sum32_3(this.h[1], C10, Dh);
      this.h[1] = sum32_3(this.h[2], D7, Eh);
      this.h[2] = sum32_3(this.h[3], E8, Ah);
      this.h[3] = sum32_3(this.h[4], A10, Bh);
      this.h[4] = sum32_3(this.h[0], B9, Ch);
      this.h[0] = T6;
    };
    RIPEMD160.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f7(j8, x8, y10, z8) {
      if (j8 <= 15)
        return x8 ^ y10 ^ z8;
      else if (j8 <= 31)
        return x8 & y10 | ~x8 & z8;
      else if (j8 <= 47)
        return (x8 | ~y10) ^ z8;
      else if (j8 <= 63)
        return x8 & z8 | y10 & ~z8;
      else
        return x8 ^ (y10 | ~z8);
    }
    function K6(j8) {
      if (j8 <= 15)
        return 0;
      else if (j8 <= 31)
        return 1518500249;
      else if (j8 <= 47)
        return 1859775393;
      else if (j8 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j8) {
      if (j8 <= 15)
        return 1352829926;
      else if (j8 <= 31)
        return 1548603684;
      else if (j8 <= 47)
        return 1836072691;
      else if (j8 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r7 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s11 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert3(key.length <= this.blockSize);
      for (var i10 = key.length; i10 < this.blockSize; i10++)
        key.push(0);
      for (i10 = 0; i10 < key.length; i10++)
        key[i10] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i10 = 0; i10 < key.length; i10++)
        key[i10] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash = exports;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e11) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i10 = 0; i10 < this.V.length; i10++) {
        this.K[i10] = 0;
        this.V[i10] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert3(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert3(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert3 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert3(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p10) {
      var initial = buf[p10.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i10 = 0, off = p10.place; i10 < octetLen; i10++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p10.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i10 = 0;
      var len = buf.length - 1;
      while (!buf[i10] && !(buf[i10 + 1] & 128) && i10 < len) {
        i10++;
      }
      if (i10 === 0) {
        return buf;
      }
      return buf.slice(i10);
    }
    Signature.prototype._importDER = function _importDER(data2, enc) {
      data2 = utils.toArray(data2, enc);
      var p10 = new Position();
      if (data2[p10.place++] !== 48) {
        return false;
      }
      var len = getLength(data2, p10);
      if (len === false) {
        return false;
      }
      if (len + p10.place !== data2.length) {
        return false;
      }
      if (data2[p10.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data2, p10);
      if (rlen === false) {
        return false;
      }
      var r7 = data2.slice(p10.place, rlen + p10.place);
      p10.place += rlen;
      if (data2[p10.place++] !== 2) {
        return false;
      }
      var slen = getLength(data2, p10);
      if (slen === false) {
        return false;
      }
      if (data2.length !== slen + p10.place) {
        return false;
      }
      var s11 = data2.slice(p10.place, slen + p10.place);
      if (r7[0] === 0) {
        if (r7[1] & 128) {
          r7 = r7.slice(1);
        } else {
          return false;
        }
      }
      if (s11[0] === 0) {
        if (s11[1] & 128) {
          s11 = s11.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r7);
      this.s = new BN(s11);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r7 = this.r.toArray();
      var s11 = this.s.toArray();
      if (r7[0] & 128)
        r7 = [0].concat(r7);
      if (s11[0] & 128)
        s11 = [0].concat(s11);
      r7 = rmPadding(r7);
      s11 = rmPadding(s11);
      while (!s11[0] && !(s11[1] & 128)) {
        s11 = s11.slice(1);
      }
      var arr = [2];
      constructLength(arr, r7.length);
      arr = arr.concat(r7);
      arr.push(2);
      constructLength(arr, s11.length);
      var backHalf = arr.concat(s11);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert3 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert3(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k8 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k8 = this._truncateToN(k8, true);
        if (k8.cmpn(1) <= 0 || k8.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k8);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r7 = kpX.umod(this.n);
        if (r7.cmpn(0) === 0)
          continue;
        var s11 = k8.invm(this.n).mul(r7.mul(key.getPrivate()).iadd(msg));
        s11 = s11.umod(this.n);
        if (s11.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r7) !== 0 ? 2 : 0);
        if (options.canonical && s11.cmp(this.nh) > 0) {
          s11 = this.n.sub(s11);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r7, s: s11, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r7 = signature.r;
      var s11 = signature.s;
      if (r7.cmpn(1) < 0 || r7.cmp(this.n) >= 0)
        return false;
      if (s11.cmpn(1) < 0 || s11.cmp(this.n) >= 0)
        return false;
      var sinv = s11.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r7).umod(this.n);
      var p10;
      if (!this.curve._maxwellTrick) {
        p10 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p10.isInfinity())
          return false;
        return p10.getX().umod(this.n).cmp(r7) === 0;
      }
      p10 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p10.isInfinity())
        return false;
      return p10.eqXToP(r7);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j8, enc) {
      assert3((3 & j8) === j8, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n8 = this.n;
      var e11 = new BN(msg);
      var r7 = signature.r;
      var s11 = signature.s;
      var isYOdd = j8 & 1;
      var isSecondKey = j8 >> 1;
      if (r7.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r7 = this.curve.pointFromX(r7.add(this.curve.n), isYOdd);
      else
        r7 = this.curve.pointFromX(r7, isYOdd);
      var rInv = signature.r.invm(n8);
      var s1 = n8.sub(e11).mul(rInv).umod(n8);
      var s22 = s11.mul(rInv).umod(n8);
      return this.g.mulAdd(s1, r7, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e11, signature, Q6, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i10 = 0; i10 < 4; i10++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e11, signature, i10);
        } catch (e12) {
          continue;
        }
        if (Qprime.eq(Q6))
          return i10;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a9 = hash.slice(0, eddsa.encodingLength);
      a9[0] &= 248;
      a9[lastIx] &= 127;
      a9[lastIx] |= 64;
      return a9;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert3(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert3(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert3 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert3(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S7() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R5() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert3(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r7 = this.hashInt(key.messagePrefix(), message);
      var R5 = this.g.mul(r7);
      var Rencoded = this.encodePoint(R5);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S7 = r7.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R5, S: S7, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h11 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h11));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i10 = 0; i10 < arguments.length; i10++)
        hash2.update(arguments[i10]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y10 = utils.intFromLE(normed);
      return this.curve.pointFromY(y10, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@ethersproject/signing-key/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/elliptic.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EC = void 0;
    var elliptic_1 = __importDefault2(require_elliptic());
    var EC = elliptic_1.default.ec;
    exports.EC = EC;
  }
});

// node_modules/@ethersproject/signing-key/lib/_version.js
var require_version12 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "signing-key/5.7.0";
  }
});

// node_modules/@ethersproject/signing-key/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;
    var elliptic_1 = require_elliptic2();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version12();
    var logger19 = new logger_1.Logger(_version_1.version);
    var _curve = null;
    function getCurve() {
      if (!_curve) {
        _curve = new elliptic_1.EC("secp256k1");
      }
      return _curve;
    }
    var SigningKey2 = (
      /** @class */
      function() {
        function SigningKey3(privateKey) {
          (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
          (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
          if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
            logger19.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
          }
          var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
          (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
          (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
          (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
        }
        SigningKey3.prototype._addPoint = function(other) {
          var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
          var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
          return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
        };
        SigningKey3.prototype.signDigest = function(digest2) {
          var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
          var digestBytes = (0, bytes_1.arrayify)(digest2);
          if (digestBytes.length !== 32) {
            logger19.throwArgumentError("bad digest length", "digest", digest2);
          }
          var signature = keyPair.sign(digestBytes, { canonical: true });
          return (0, bytes_1.splitSignature)({
            recoveryParam: signature.recoveryParam,
            r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
            s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32)
          });
        };
        SigningKey3.prototype.computeSharedSecret = function(otherKey) {
          var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
          var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey2(otherKey)));
          return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
        };
        SigningKey3.isSigningKey = function(value) {
          return !!(value && value._isSigningKey);
        };
        return SigningKey3;
      }()
    );
    exports.SigningKey = SigningKey2;
    function recoverPublicKey2(digest2, signature) {
      var sig = (0, bytes_1.splitSignature)(signature);
      var rs2 = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
      return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest2), rs2, sig.recoveryParam).encode("hex", false);
    }
    exports.recoverPublicKey = recoverPublicKey2;
    function computePublicKey2(key, compressed) {
      var bytes = (0, bytes_1.arrayify)(key);
      if (bytes.length === 32) {
        var signingKey = new SigningKey2(bytes);
        if (compressed) {
          return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
      } else if (bytes.length === 33) {
        if (compressed) {
          return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
      } else if (bytes.length === 65) {
        if (!compressed) {
          return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
      }
      return logger19.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
    }
    exports.computePublicKey = computePublicKey2;
  }
});

// node_modules/@ethersproject/transactions/lib/_version.js
var require_version13 = __commonJS({
  "node_modules/@ethersproject/transactions/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "transactions/5.7.0";
  }
});

// node_modules/@ethersproject/transactions/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/@ethersproject/transactions/lib/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o11, m11, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o11, k22, { enumerable: true, get: function() {
        return m11[k8];
      } });
    } : function(o11, m11, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o11[k22] = m11[k8];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o11, v7) {
      Object.defineProperty(o11, "default", { enumerable: true, value: v7 });
    } : function(o11, v7) {
      o11["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k8 in mod)
          if (k8 !== "default" && Object.prototype.hasOwnProperty.call(mod, k8))
            __createBinding2(result, mod, k8);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib8();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var RLP2 = __importStar2(require_lib6());
    var signing_key_1 = require_lib16();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger19 = new logger_1.Logger(_version_1.version);
    var TransactionTypes2;
    (function(TransactionTypes3) {
      TransactionTypes3[TransactionTypes3["legacy"] = 0] = "legacy";
      TransactionTypes3[TransactionTypes3["eip2930"] = 1] = "eip2930";
      TransactionTypes3[TransactionTypes3["eip1559"] = 2] = "eip1559";
    })(TransactionTypes2 = exports.TransactionTypes || (exports.TransactionTypes = {}));
    function handleAddress(value) {
      if (value === "0x") {
        return null;
      }
      return (0, address_1.getAddress)(value);
    }
    function handleNumber(value) {
      if (value === "0x") {
        return constants_1.Zero;
      }
      return bignumber_1.BigNumber.from(value);
    }
    var transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    var allowedTransactionKeys3 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
    function computeAddress2(key) {
      var publicKey = (0, signing_key_1.computePublicKey)(key);
      return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
    }
    exports.computeAddress = computeAddress2;
    function recoverAddress2(digest2, signature) {
      return computeAddress2((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest2), signature));
    }
    exports.recoverAddress = recoverAddress2;
    function formatNumber(value, name2) {
      var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
      if (result.length > 32) {
        logger19.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
      }
      return result;
    }
    function accessSetify(addr, storageKeys) {
      return {
        address: (0, address_1.getAddress)(addr),
        storageKeys: (storageKeys || []).map(function(storageKey, index) {
          if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
            logger19.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index + "]", storageKey);
          }
          return storageKey.toLowerCase();
        })
      };
    }
    function accessListify6(value) {
      if (Array.isArray(value)) {
        return value.map(function(set, index) {
          if (Array.isArray(set)) {
            if (set.length > 2) {
              logger19.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index + "]", set);
            }
            return accessSetify(set[0], set[1]);
          }
          return accessSetify(set.address, set.storageKeys);
        });
      }
      var result = Object.keys(value).map(function(addr) {
        var storageKeys = value[addr].reduce(function(accum, storageKey) {
          accum[storageKey] = true;
          return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
      });
      result.sort(function(a9, b10) {
        return a9.address.localeCompare(b10.address);
      });
      return result;
    }
    exports.accessListify = accessListify6;
    function formatAccessList(value) {
      return accessListify6(value).map(function(set) {
        return [set.address, set.storageKeys];
      });
    }
    function _serializeEip1559(transaction, signature) {
      if (transaction.gasPrice != null) {
        var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);
        var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
          logger19.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice,
            maxFeePerGas
          });
        }
      }
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x02", RLP2.encode(fields)]);
    }
    function _serializeEip2930(transaction, signature) {
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x01", RLP2.encode(fields)]);
    }
    function _serialize(transaction, signature) {
      (0, properties_1.checkProperties)(transaction, allowedTransactionKeys3);
      var raw = [];
      transactionFields.forEach(function(fieldInfo) {
        var value = transaction[fieldInfo.name] || [];
        var options = {};
        if (fieldInfo.numeric) {
          options.hexPad = "left";
        }
        value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
          logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
        if (fieldInfo.maxLength) {
          value = (0, bytes_1.stripZeros)(value);
          if (value.length > fieldInfo.maxLength) {
            logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
          }
        }
        raw.push((0, bytes_1.hexlify)(value));
      });
      var chainId = 0;
      if (transaction.chainId != null) {
        chainId = transaction.chainId;
        if (typeof chainId !== "number") {
          logger19.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
      } else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
        chainId = Math.floor((signature.v - 35) / 2);
      }
      if (chainId !== 0) {
        raw.push((0, bytes_1.hexlify)(chainId));
        raw.push("0x");
        raw.push("0x");
      }
      if (!signature) {
        return RLP2.encode(raw);
      }
      var sig = (0, bytes_1.splitSignature)(signature);
      var v7 = 27 + sig.recoveryParam;
      if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v7 += chainId * 2 + 8;
        if (sig.v > 28 && sig.v !== v7) {
          logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
      } else if (sig.v !== v7) {
        logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
      }
      raw.push((0, bytes_1.hexlify)(v7));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
      return RLP2.encode(raw);
    }
    function serialize3(transaction, signature) {
      if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
          logger19.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
      }
      switch (transaction.type) {
        case 1:
          return _serializeEip2930(transaction, signature);
        case 2:
          return _serializeEip1559(transaction, signature);
        default:
          break;
      }
      return logger19.throwError("unsupported transaction type: " + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
      });
    }
    exports.serialize = serialize3;
    function _parseEipSignature(tx, fields, serialize4) {
      try {
        var recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
          throw new Error("bad recid");
        }
        tx.v = recid;
      } catch (error) {
        logger19.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
      }
      tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
      tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
      try {
        var digest2 = (0, keccak256_1.keccak256)(serialize4(tx));
        tx.from = recoverAddress2(digest2, { r: tx.r, s: tx.s, recoveryParam: tx.v });
      } catch (error) {
      }
    }
    function _parseEip1559(payload) {
      var transaction = RLP2.decode(payload.slice(1));
      if (transaction.length !== 9 && transaction.length !== 12) {
        logger19.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
      }
      var maxPriorityFeePerGas = handleNumber(transaction[2]);
      var maxFeePerGas = handleNumber(transaction[3]);
      var tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas,
        maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify6(transaction[8])
      };
      if (transaction.length === 9) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
      return tx;
    }
    function _parseEip2930(payload) {
      var transaction = RLP2.decode(payload.slice(1));
      if (transaction.length !== 8 && transaction.length !== 11) {
        logger19.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
      }
      var tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify6(transaction[7])
      };
      if (transaction.length === 8) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
      return tx;
    }
    function _parse(rawTransaction) {
      var transaction = RLP2.decode(rawTransaction);
      if (transaction.length !== 9 && transaction.length !== 6) {
        logger19.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
      }
      var tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
      };
      if (transaction.length === 6) {
        return tx;
      }
      try {
        tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();
      } catch (error) {
        return tx;
      }
      tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);
      tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);
      if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
        tx.chainId = tx.v;
        tx.v = 0;
      } else {
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
          tx.chainId = 0;
        }
        var recoveryParam = tx.v - 27;
        var raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
          raw.push((0, bytes_1.hexlify)(tx.chainId));
          raw.push("0x");
          raw.push("0x");
          recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest2 = (0, keccak256_1.keccak256)(RLP2.encode(raw));
        try {
          tx.from = recoverAddress2(digest2, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam });
        } catch (error) {
        }
        tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
      }
      tx.type = null;
      return tx;
    }
    function parse3(rawTransaction) {
      var payload = (0, bytes_1.arrayify)(rawTransaction);
      if (payload[0] > 127) {
        return _parse(payload);
      }
      switch (payload[0]) {
        case 1:
          return _parseEip2930(payload);
        case 2:
          return _parseEip1559(payload);
        default:
          break;
      }
      return logger19.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
      });
    }
    exports.parse = parse3;
  }
});

// node_modules/@ethersproject/basex/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/@ethersproject/basex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base58 = exports.Base32 = exports.BaseX = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var BaseX = (
      /** @class */
      function() {
        function BaseX2(alphabet2) {
          (0, properties_1.defineReadOnly)(this, "alphabet", alphabet2);
          (0, properties_1.defineReadOnly)(this, "base", alphabet2.length);
          (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
          (0, properties_1.defineReadOnly)(this, "_leader", alphabet2.charAt(0));
          for (var i10 = 0; i10 < alphabet2.length; i10++) {
            this._alphabetMap[alphabet2.charAt(i10)] = i10;
          }
        }
        BaseX2.prototype.encode = function(value) {
          var source = (0, bytes_1.arrayify)(value);
          if (source.length === 0) {
            return "";
          }
          var digits = [0];
          for (var i10 = 0; i10 < source.length; ++i10) {
            var carry = source[i10];
            for (var j8 = 0; j8 < digits.length; ++j8) {
              carry += digits[j8] << 8;
              digits[j8] = carry % this.base;
              carry = carry / this.base | 0;
            }
            while (carry > 0) {
              digits.push(carry % this.base);
              carry = carry / this.base | 0;
            }
          }
          var string2 = "";
          for (var k8 = 0; source[k8] === 0 && k8 < source.length - 1; ++k8) {
            string2 += this._leader;
          }
          for (var q8 = digits.length - 1; q8 >= 0; --q8) {
            string2 += this.alphabet[digits[q8]];
          }
          return string2;
        };
        BaseX2.prototype.decode = function(value) {
          if (typeof value !== "string") {
            throw new TypeError("Expected String");
          }
          var bytes = [];
          if (value.length === 0) {
            return new Uint8Array(bytes);
          }
          bytes.push(0);
          for (var i10 = 0; i10 < value.length; i10++) {
            var byte = this._alphabetMap[value[i10]];
            if (byte === void 0) {
              throw new Error("Non-base" + this.base + " character");
            }
            var carry = byte;
            for (var j8 = 0; j8 < bytes.length; ++j8) {
              carry += bytes[j8] * this.base;
              bytes[j8] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k8 = 0; value[k8] === this._leader && k8 < value.length - 1; ++k8) {
            bytes.push(0);
          }
          return (0, bytes_1.arrayify)(new Uint8Array(bytes.reverse()));
        };
        return BaseX2;
      }()
    );
    exports.BaseX = BaseX;
    var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    exports.Base32 = Base32;
    var Base582 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.Base58 = Base582;
  }
});

// node_modules/@ethersproject/sha2/lib/types.js
var require_types = __commonJS({
  "node_modules/@ethersproject/sha2/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = void 0;
    var SupportedAlgorithm2;
    (function(SupportedAlgorithm3) {
      SupportedAlgorithm3["sha256"] = "sha256";
      SupportedAlgorithm3["sha512"] = "sha512";
    })(SupportedAlgorithm2 = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));
  }
});

// node_modules/@ethersproject/sha2/lib/_version.js
var require_version14 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "sha2/5.7.0";
  }
});

// node_modules/@ethersproject/sha2/lib/browser-sha2.js
var require_browser_sha2 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/browser-sha2.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;
    var hash_js_1 = __importDefault2(require_hash());
    var bytes_1 = require_lib2();
    var types_1 = require_types();
    var logger_1 = require_lib();
    var _version_1 = require_version14();
    var logger19 = new logger_1.Logger(_version_1.version);
    function ripemd1603(data2) {
      return "0x" + hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data2)).digest("hex");
    }
    exports.ripemd160 = ripemd1603;
    function sha2565(data2) {
      return "0x" + hash_js_1.default.sha256().update((0, bytes_1.arrayify)(data2)).digest("hex");
    }
    exports.sha256 = sha2565;
    function sha5124(data2) {
      return "0x" + hash_js_1.default.sha512().update((0, bytes_1.arrayify)(data2)).digest("hex");
    }
    exports.sha512 = sha5124;
    function computeHmac2(algorithm, key, data2) {
      if (!types_1.SupportedAlgorithm[algorithm]) {
        logger19.throwError("unsupported algorithm " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "hmac",
          algorithm
        });
      }
      return "0x" + hash_js_1.default.hmac(hash_js_1.default[algorithm], (0, bytes_1.arrayify)(key)).update((0, bytes_1.arrayify)(data2)).digest("hex");
    }
    exports.computeHmac = computeHmac2;
  }
});

// node_modules/@ethersproject/sha2/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;
    var sha2_1 = require_browser_sha2();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return types_1.SupportedAlgorithm;
    } });
  }
});

// node_modules/@ethersproject/pbkdf2/lib/browser-pbkdf2.js
var require_browser_pbkdf2 = __commonJS({
  "node_modules/@ethersproject/pbkdf2/lib/browser-pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = void 0;
    var bytes_1 = require_lib2();
    var sha2_1 = require_lib19();
    function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
      password = (0, bytes_1.arrayify)(password);
      salt = (0, bytes_1.arrayify)(salt);
      var hLen;
      var l9 = 1;
      var DK = new Uint8Array(keylen);
      var block1 = new Uint8Array(salt.length + 4);
      block1.set(salt);
      var r7;
      var T6;
      for (var i10 = 1; i10 <= l9; i10++) {
        block1[salt.length] = i10 >> 24 & 255;
        block1[salt.length + 1] = i10 >> 16 & 255;
        block1[salt.length + 2] = i10 >> 8 & 255;
        block1[salt.length + 3] = i10 & 255;
        var U5 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, block1));
        if (!hLen) {
          hLen = U5.length;
          T6 = new Uint8Array(hLen);
          l9 = Math.ceil(keylen / hLen);
          r7 = keylen - (l9 - 1) * hLen;
        }
        T6.set(U5);
        for (var j8 = 1; j8 < iterations; j8++) {
          U5 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, U5));
          for (var k8 = 0; k8 < hLen; k8++)
            T6[k8] ^= U5[k8];
        }
        var destPos = (i10 - 1) * hLen;
        var len = i10 === l9 ? r7 : hLen;
        DK.set((0, bytes_1.arrayify)(T6).slice(0, len), destPos);
      }
      return (0, bytes_1.hexlify)(DK);
    }
    exports.pbkdf2 = pbkdf2;
  }
});

// node_modules/@ethersproject/pbkdf2/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/@ethersproject/pbkdf2/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = void 0;
    var pbkdf2_1 = require_browser_pbkdf2();
    Object.defineProperty(exports, "pbkdf2", { enumerable: true, get: function() {
      return pbkdf2_1.pbkdf2;
    } });
  }
});

// node_modules/@ethersproject/wordlists/lib/_version.js
var require_version15 = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "wordlists/5.7.0";
  }
});

// node_modules/@ethersproject/wordlists/lib/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/wordlist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = exports.logger = void 0;
    var exportWordlist = false;
    var hash_1 = require_lib12();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version15();
    exports.logger = new logger_1.Logger(_version_1.version);
    var Wordlist2 = (
      /** @class */
      function() {
        function Wordlist3(locale) {
          var _newTarget = this.constructor;
          exports.logger.checkAbstract(_newTarget, Wordlist3);
          (0, properties_1.defineReadOnly)(this, "locale", locale);
        }
        Wordlist3.prototype.split = function(mnemonic) {
          return mnemonic.toLowerCase().split(/ +/g);
        };
        Wordlist3.prototype.join = function(words) {
          return words.join(" ");
        };
        Wordlist3.check = function(wordlist) {
          var words = [];
          for (var i10 = 0; i10 < 2048; i10++) {
            var word = wordlist.getWord(i10);
            if (i10 !== wordlist.getWordIndex(word)) {
              return "0x";
            }
            words.push(word);
          }
          return (0, hash_1.id)(words.join("\n") + "\n");
        };
        Wordlist3.register = function(lang, name2) {
          if (!name2) {
            name2 = lang.locale;
          }
          if (exportWordlist) {
            try {
              var anyGlobal = window;
              if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
                if (!anyGlobal._ethers.wordlists[name2]) {
                  (0, properties_1.defineReadOnly)(anyGlobal._ethers.wordlists, name2, lang);
                }
              }
            } catch (error) {
            }
          }
        };
        return Wordlist3;
      }()
    );
    exports.Wordlist = Wordlist2;
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-cz.js
var require_lang_cz = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-cz.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langCz = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
      }
    }
    var LangCz = (
      /** @class */
      function(_super) {
        __extends2(LangCz2, _super);
        function LangCz2() {
          return _super.call(this, "cz") || this;
        }
        LangCz2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangCz2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist.indexOf(word);
        };
        return LangCz2;
      }(wordlist_1.Wordlist)
    );
    var langCz = new LangCz();
    exports.langCz = langCz;
    wordlist_1.Wordlist.register(langCz);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-en.js
var require_lang_en = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-en.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langEn = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
      }
    }
    var LangEn = (
      /** @class */
      function(_super) {
        __extends2(LangEn2, _super);
        function LangEn2() {
          return _super.call(this, "en") || this;
        }
        LangEn2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangEn2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist.indexOf(word);
        };
        return LangEn2;
      }(wordlist_1.Wordlist)
    );
    var langEn = new LangEn();
    exports.langEn = langEn;
    wordlist_1.Wordlist.register(langEn);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-es.js
var require_lang_es = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-es.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langEs = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var words = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";
    var lookup = {};
    var wordlist = null;
    function dropDiacritic(word) {
      wordlist_1.logger.checkNormalize();
      return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c8) {
        return c8 >= 65 && c8 <= 90 || c8 >= 97 && c8 <= 123;
      }));
    }
    function expand(word) {
      var output = [];
      Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c8) {
        if (c8 === 47) {
          output.push(204);
          output.push(129);
        } else if (c8 === 126) {
          output.push(110);
          output.push(204);
          output.push(131);
        } else {
          output.push(c8);
        }
      });
      return (0, strings_1.toUtf8String)(output);
    }
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w11) {
        return expand(w11);
      });
      wordlist.forEach(function(word, index) {
        lookup[dropDiacritic(word)] = index;
      });
      if (wordlist_1.Wordlist.check(lang) !== "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for es (Spanish) FAILED");
      }
    }
    var LangEs = (
      /** @class */
      function(_super) {
        __extends2(LangEs2, _super);
        function LangEs2() {
          return _super.call(this, "es") || this;
        }
        LangEs2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangEs2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return lookup[dropDiacritic(word)];
        };
        return LangEs2;
      }(wordlist_1.Wordlist)
    );
    var langEs = new LangEs();
    exports.langEs = langEs;
    wordlist_1.Wordlist.register(langEs);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-fr.js
var require_lang_fr = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-fr.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langFr = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var words = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";
    var wordlist = null;
    var lookup = {};
    function dropDiacritic(word) {
      wordlist_1.logger.checkNormalize();
      return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c8) {
        return c8 >= 65 && c8 <= 90 || c8 >= 97 && c8 <= 123;
      }));
    }
    function expand(word) {
      var output = [];
      Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c8) {
        if (c8 === 47) {
          output.push(204);
          output.push(129);
        } else if (c8 === 45) {
          output.push(204);
          output.push(128);
        } else {
          output.push(c8);
        }
      });
      return (0, strings_1.toUtf8String)(output);
    }
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w11) {
        return expand(w11);
      });
      wordlist.forEach(function(word, index) {
        lookup[dropDiacritic(word)] = index;
      });
      if (wordlist_1.Wordlist.check(lang) !== "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for fr (French) FAILED");
      }
    }
    var LangFr = (
      /** @class */
      function(_super) {
        __extends2(LangFr2, _super);
        function LangFr2() {
          return _super.call(this, "fr") || this;
        }
        LangFr2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangFr2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return lookup[dropDiacritic(word)];
        };
        return LangFr2;
      }(wordlist_1.Wordlist)
    );
    var langFr = new LangFr();
    exports.langFr = langFr;
    wordlist_1.Wordlist.register(langFr);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-ja.js
var require_lang_ja = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-ja.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langJa = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data2 = [
      // 4-kana words
      "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
      // 5-kana words
      "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
      // 6-kana words
      "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
      // 7-kana words
      "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
      // 8-kana words
      "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
      // 9-kana words
      "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
      // 10-kana words
      "IJBEJqXZJ"
    ];
    var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
    var wordlist = null;
    function hex(word) {
      return (0, bytes_1.hexlify)((0, strings_1.toUtf8Bytes)(word));
    }
    var KiYoKu = "0xe3818de38284e3818f";
    var KyoKu = "0xe3818de38283e3818f";
    function loadWords(lang) {
      if (wordlist !== null) {
        return;
      }
      wordlist = [];
      var transform = {};
      transform[(0, strings_1.toUtf8String)([227, 130, 154])] = false;
      transform[(0, strings_1.toUtf8String)([227, 130, 153])] = false;
      transform[(0, strings_1.toUtf8String)([227, 130, 133])] = (0, strings_1.toUtf8String)([227, 130, 134]);
      transform[(0, strings_1.toUtf8String)([227, 129, 163])] = (0, strings_1.toUtf8String)([227, 129, 164]);
      transform[(0, strings_1.toUtf8String)([227, 130, 131])] = (0, strings_1.toUtf8String)([227, 130, 132]);
      transform[(0, strings_1.toUtf8String)([227, 130, 135])] = (0, strings_1.toUtf8String)([227, 130, 136]);
      function normalize(word2) {
        var result = "";
        for (var i11 = 0; i11 < word2.length; i11++) {
          var kana = word2[i11];
          var target = transform[kana];
          if (target === false) {
            continue;
          }
          if (target) {
            kana = target;
          }
          result += kana;
        }
        return result;
      }
      function sortJapanese(a9, b10) {
        a9 = normalize(a9);
        b10 = normalize(b10);
        if (a9 < b10) {
          return -1;
        }
        if (a9 > b10) {
          return 1;
        }
        return 0;
      }
      for (var length_1 = 3; length_1 <= 9; length_1++) {
        var d9 = data2[length_1 - 3];
        for (var offset = 0; offset < d9.length; offset += length_1) {
          var word = [];
          for (var i10 = 0; i10 < length_1; i10++) {
            var k8 = mapping.indexOf(d9[offset + i10]);
            word.push(227);
            word.push(k8 & 64 ? 130 : 129);
            word.push((k8 & 63) + 128);
          }
          wordlist.push((0, strings_1.toUtf8String)(word));
        }
      }
      wordlist.sort(sortJapanese);
      if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
        var tmp = wordlist[442];
        wordlist[442] = wordlist[443];
        wordlist[443] = tmp;
      }
      if (wordlist_1.Wordlist.check(lang) !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
      }
    }
    var LangJa = (
      /** @class */
      function(_super) {
        __extends2(LangJa2, _super);
        function LangJa2() {
          return _super.call(this, "ja") || this;
        }
        LangJa2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangJa2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist.indexOf(word);
        };
        LangJa2.prototype.split = function(mnemonic) {
          wordlist_1.logger.checkNormalize();
          return mnemonic.split(/(?:\u3000| )+/g);
        };
        LangJa2.prototype.join = function(words) {
          return words.join("\u3000");
        };
        return LangJa2;
      }(wordlist_1.Wordlist)
    );
    var langJa = new LangJa();
    exports.langJa = langJa;
    wordlist_1.Wordlist.register(langJa);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-ko.js
var require_lang_ko = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-ko.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langKo = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data2 = [
      "OYAa",
      "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
      "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
      "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
      "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
      "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
      "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
      "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
    ];
    var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
    function getHangul(code2) {
      if (code2 >= 40) {
        code2 = code2 + 168 - 40;
      } else if (code2 >= 19) {
        code2 = code2 + 97 - 19;
      }
      return (0, strings_1.toUtf8String)([225, (code2 >> 6) + 132, (code2 & 63) + 128]);
    }
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = [];
      data2.forEach(function(data3, length2) {
        length2 += 4;
        for (var i10 = 0; i10 < data3.length; i10 += length2) {
          var word = "";
          for (var j8 = 0; j8 < length2; j8++) {
            word += getHangul(codes.indexOf(data3[i10 + j8]));
          }
          wordlist.push(word);
        }
      });
      wordlist.sort();
      if (wordlist_1.Wordlist.check(lang) !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
      }
    }
    var LangKo = (
      /** @class */
      function(_super) {
        __extends2(LangKo2, _super);
        function LangKo2() {
          return _super.call(this, "ko") || this;
        }
        LangKo2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangKo2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist.indexOf(word);
        };
        return LangKo2;
      }(wordlist_1.Wordlist)
    );
    var langKo = new LangKo();
    exports.langKo = langKo;
    wordlist_1.Wordlist.register(langKo);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-it.js
var require_lang_it = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-it.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langIt = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for it (Italian) FAILED");
      }
    }
    var LangIt = (
      /** @class */
      function(_super) {
        __extends2(LangIt2, _super);
        function LangIt2() {
          return _super.call(this, "it") || this;
        }
        LangIt2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[index];
        };
        LangIt2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist.indexOf(word);
        };
        return LangIt2;
      }(wordlist_1.Wordlist)
    );
    var langIt = new LangIt();
    exports.langIt = langIt;
    wordlist_1.Wordlist.register(langIt);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-zh.js
var require_lang_zh = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-zh.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langZhTw = exports.langZhCn = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data2 = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
    var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
    var wordlist = {
      zh_cn: null,
      zh_tw: null
    };
    var Checks = {
      zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
      zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
    };
    var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var style2 = "~!@#$%^&*_-=[]{}|;:,.()<>?";
    function loadWords(lang) {
      if (wordlist[lang.locale] !== null) {
        return;
      }
      wordlist[lang.locale] = [];
      var deltaOffset = 0;
      for (var i10 = 0; i10 < 2048; i10++) {
        var s11 = style2.indexOf(data2[i10 * 3]);
        var bytes = [
          228 + (s11 >> 2),
          128 + codes.indexOf(data2[i10 * 3 + 1]),
          128 + codes.indexOf(data2[i10 * 3 + 2])
        ];
        if (lang.locale === "zh_tw") {
          var common = s11 % 4;
          for (var i_1 = common; i_1 < 3; i_1++) {
            bytes[i_1] = codes.indexOf(deltaData[deltaOffset++]) + (i_1 == 0 ? 228 : 128);
          }
        }
        wordlist[lang.locale].push((0, strings_1.toUtf8String)(bytes));
      }
      if (wordlist_1.Wordlist.check(lang) !== Checks[lang.locale]) {
        wordlist[lang.locale] = null;
        throw new Error("BIP39 Wordlist for " + lang.locale + " (Chinese) FAILED");
      }
    }
    var LangZh = (
      /** @class */
      function(_super) {
        __extends2(LangZh2, _super);
        function LangZh2(country) {
          return _super.call(this, "zh_" + country) || this;
        }
        LangZh2.prototype.getWord = function(index) {
          loadWords(this);
          return wordlist[this.locale][index];
        };
        LangZh2.prototype.getWordIndex = function(word) {
          loadWords(this);
          return wordlist[this.locale].indexOf(word);
        };
        LangZh2.prototype.split = function(mnemonic) {
          mnemonic = mnemonic.replace(/(?:\u3000| )+/g, "");
          return mnemonic.split("");
        };
        return LangZh2;
      }(wordlist_1.Wordlist)
    );
    var langZhCn = new LangZh("cn");
    exports.langZhCn = langZhCn;
    wordlist_1.Wordlist.register(langZhCn);
    wordlist_1.Wordlist.register(langZhCn, "zh");
    var langZhTw = new LangZh("tw");
    exports.langZhTw = langZhTw;
    wordlist_1.Wordlist.register(langZhTw);
  }
});

// node_modules/@ethersproject/wordlists/lib/wordlists.js
var require_wordlists = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/wordlists.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = void 0;
    var lang_cz_1 = require_lang_cz();
    var lang_en_1 = require_lang_en();
    var lang_es_1 = require_lang_es();
    var lang_fr_1 = require_lang_fr();
    var lang_ja_1 = require_lang_ja();
    var lang_ko_1 = require_lang_ko();
    var lang_it_1 = require_lang_it();
    var lang_zh_1 = require_lang_zh();
    exports.wordlists = {
      cz: lang_cz_1.langCz,
      en: lang_en_1.langEn,
      es: lang_es_1.langEs,
      fr: lang_fr_1.langFr,
      it: lang_it_1.langIt,
      ja: lang_ja_1.langJa,
      ko: lang_ko_1.langKo,
      zh: lang_zh_1.langZhCn,
      zh_cn: lang_zh_1.langZhCn,
      zh_tw: lang_zh_1.langZhTw
    };
  }
});

// node_modules/@ethersproject/wordlists/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = exports.Wordlist = exports.logger = void 0;
    var wordlist_1 = require_wordlist();
    Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
      return wordlist_1.logger;
    } });
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return wordlist_1.Wordlist;
    } });
    var wordlists_1 = require_wordlists();
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return wordlists_1.wordlists;
    } });
  }
});

// node_modules/@ethersproject/hdnode/lib/_version.js
var require_version16 = __commonJS({
  "node_modules/@ethersproject/hdnode/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "hdnode/5.7.0";
  }
});

// node_modules/@ethersproject/hdnode/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/@ethersproject/hdnode/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = void 0;
    var basex_1 = require_lib18();
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var strings_1 = require_lib9();
    var pbkdf2_1 = require_lib20();
    var properties_1 = require_lib4();
    var signing_key_1 = require_lib16();
    var sha2_1 = require_lib19();
    var transactions_1 = require_lib17();
    var wordlists_1 = require_lib21();
    var logger_1 = require_lib();
    var _version_1 = require_version16();
    var logger19 = new logger_1.Logger(_version_1.version);
    var N16 = bignumber_1.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var MasterSecret = (0, strings_1.toUtf8Bytes)("Bitcoin seed");
    var HardenedBit = 2147483648;
    function getUpperMask(bits) {
      return (1 << bits) - 1 << 8 - bits;
    }
    function getLowerMask(bits) {
      return (1 << bits) - 1;
    }
    function bytes32(value) {
      return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
    }
    function base58check(data2) {
      return basex_1.Base58.encode((0, bytes_1.concat)([data2, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data2)), 0, 4)]));
    }
    function getWordlist(wordlist) {
      if (wordlist == null) {
        return wordlists_1.wordlists["en"];
      }
      if (typeof wordlist === "string") {
        var words = wordlists_1.wordlists[wordlist];
        if (words == null) {
          logger19.throwArgumentError("unknown locale", "wordlist", wordlist);
        }
        return words;
      }
      return wordlist;
    }
    var _constructorGuard2 = {};
    exports.defaultPath = "m/44'/60'/0'/0/0";
    var HDNode2 = (
      /** @class */
      function() {
        function HDNode3(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
          if (constructorGuard !== _constructorGuard2) {
            throw new Error("HDNode constructor cannot be called directly");
          }
          if (privateKey) {
            var signingKey = new signing_key_1.SigningKey(privateKey);
            (0, properties_1.defineReadOnly)(this, "privateKey", signingKey.privateKey);
            (0, properties_1.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
          } else {
            (0, properties_1.defineReadOnly)(this, "privateKey", null);
            (0, properties_1.defineReadOnly)(this, "publicKey", (0, bytes_1.hexlify)(publicKey));
          }
          (0, properties_1.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
          (0, properties_1.defineReadOnly)(this, "fingerprint", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));
          (0, properties_1.defineReadOnly)(this, "address", (0, transactions_1.computeAddress)(this.publicKey));
          (0, properties_1.defineReadOnly)(this, "chainCode", chainCode);
          (0, properties_1.defineReadOnly)(this, "index", index);
          (0, properties_1.defineReadOnly)(this, "depth", depth);
          if (mnemonicOrPath == null) {
            (0, properties_1.defineReadOnly)(this, "mnemonic", null);
            (0, properties_1.defineReadOnly)(this, "path", null);
          } else if (typeof mnemonicOrPath === "string") {
            (0, properties_1.defineReadOnly)(this, "mnemonic", null);
            (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath);
          } else {
            (0, properties_1.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
            (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath.path);
          }
        }
        Object.defineProperty(HDNode3.prototype, "extendedKey", {
          get: function() {
            if (this.depth >= 256) {
              throw new Error("Depth too large!");
            }
            return base58check((0, bytes_1.concat)([
              this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
              (0, bytes_1.hexlify)(this.depth),
              this.parentFingerprint,
              (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),
              this.chainCode,
              this.privateKey != null ? (0, bytes_1.concat)(["0x00", this.privateKey]) : this.publicKey
            ]));
          },
          enumerable: false,
          configurable: true
        });
        HDNode3.prototype.neuter = function() {
          return new HDNode3(_constructorGuard2, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
        };
        HDNode3.prototype._derive = function(index) {
          if (index > 4294967295) {
            throw new Error("invalid index - " + String(index));
          }
          var path = this.path;
          if (path) {
            path += "/" + (index & ~HardenedBit);
          }
          var data2 = new Uint8Array(37);
          if (index & HardenedBit) {
            if (!this.privateKey) {
              throw new Error("cannot derive child of neutered node");
            }
            data2.set((0, bytes_1.arrayify)(this.privateKey), 1);
            if (path) {
              path += "'";
            }
          } else {
            data2.set((0, bytes_1.arrayify)(this.publicKey));
          }
          for (var i10 = 24; i10 >= 0; i10 -= 8) {
            data2[33 + (i10 >> 3)] = index >> 24 - i10 & 255;
          }
          var I9 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data2));
          var IL = I9.slice(0, 32);
          var IR = I9.slice(32);
          var ki2 = null;
          var Ki2 = null;
          if (this.privateKey) {
            ki2 = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N16));
          } else {
            var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));
            Ki2 = ek._addPoint(this.publicKey);
          }
          var mnemonicOrPath = path;
          var srcMnemonic = this.mnemonic;
          if (srcMnemonic) {
            mnemonicOrPath = Object.freeze({
              phrase: srcMnemonic.phrase,
              path,
              locale: srcMnemonic.locale || "en"
            });
          }
          return new HDNode3(_constructorGuard2, ki2, Ki2, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
        };
        HDNode3.prototype.derivePath = function(path) {
          var components = path.split("/");
          if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
            throw new Error("invalid path - " + path);
          }
          if (components[0] === "m") {
            components.shift();
          }
          var result = this;
          for (var i10 = 0; i10 < components.length; i10++) {
            var component = components[i10];
            if (component.match(/^[0-9]+'$/)) {
              var index = parseInt(component.substring(0, component.length - 1));
              if (index >= HardenedBit) {
                throw new Error("invalid path index - " + component);
              }
              result = result._derive(HardenedBit + index);
            } else if (component.match(/^[0-9]+$/)) {
              var index = parseInt(component);
              if (index >= HardenedBit) {
                throw new Error("invalid path index - " + component);
              }
              result = result._derive(index);
            } else {
              throw new Error("invalid path component - " + component);
            }
          }
          return result;
        };
        HDNode3._fromSeed = function(seed, mnemonic) {
          var seedArray = (0, bytes_1.arrayify)(seed);
          if (seedArray.length < 16 || seedArray.length > 64) {
            throw new Error("invalid seed");
          }
          var I9 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));
          return new HDNode3(_constructorGuard2, bytes32(I9.slice(0, 32)), null, "0x00000000", bytes32(I9.slice(32)), 0, 0, mnemonic);
        };
        HDNode3.fromMnemonic = function(mnemonic, password, wordlist) {
          wordlist = getWordlist(wordlist);
          mnemonic = entropyToMnemonic2(mnemonicToEntropy2(mnemonic, wordlist), wordlist);
          return HDNode3._fromSeed(mnemonicToSeed2(mnemonic, password), {
            phrase: mnemonic,
            path: "m",
            locale: wordlist.locale
          });
        };
        HDNode3.fromSeed = function(seed) {
          return HDNode3._fromSeed(seed, null);
        };
        HDNode3.fromExtendedKey = function(extendedKey) {
          var bytes = basex_1.Base58.decode(extendedKey);
          if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
            logger19.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
          }
          var depth = bytes[4];
          var parentFingerprint = (0, bytes_1.hexlify)(bytes.slice(5, 9));
          var index = parseInt((0, bytes_1.hexlify)(bytes.slice(9, 13)).substring(2), 16);
          var chainCode = (0, bytes_1.hexlify)(bytes.slice(13, 45));
          var key = bytes.slice(45, 78);
          switch ((0, bytes_1.hexlify)(bytes.slice(0, 4))) {
            case "0x0488b21e":
            case "0x043587cf":
              return new HDNode3(_constructorGuard2, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);
            case "0x0488ade4":
            case "0x04358394 ":
              if (key[0] !== 0) {
                break;
              }
              return new HDNode3(_constructorGuard2, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
          }
          return logger19.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        };
        return HDNode3;
      }()
    );
    exports.HDNode = HDNode2;
    function mnemonicToSeed2(mnemonic, password) {
      if (!password) {
        password = "";
      }
      var salt = (0, strings_1.toUtf8Bytes)("mnemonic" + password, strings_1.UnicodeNormalizationForm.NFKD);
      return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
    }
    exports.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToEntropy2(mnemonic, wordlist) {
      wordlist = getWordlist(wordlist);
      logger19.checkNormalize();
      var words = wordlist.split(mnemonic);
      if (words.length % 3 !== 0) {
        throw new Error("invalid mnemonic");
      }
      var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
      var offset = 0;
      for (var i10 = 0; i10 < words.length; i10++) {
        var index = wordlist.getWordIndex(words[i10].normalize("NFKD"));
        if (index === -1) {
          throw new Error("invalid mnemonic");
        }
        for (var bit = 0; bit < 11; bit++) {
          if (index & 1 << 10 - bit) {
            entropy[offset >> 3] |= 1 << 7 - offset % 8;
          }
          offset++;
        }
      }
      var entropyBits = 32 * words.length / 3;
      var checksumBits = words.length / 3;
      var checksumMask = getUpperMask(checksumBits);
      var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
      if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
        throw new Error("invalid checksum");
      }
      return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));
    }
    exports.mnemonicToEntropy = mnemonicToEntropy2;
    function entropyToMnemonic2(entropy, wordlist) {
      wordlist = getWordlist(wordlist);
      entropy = (0, bytes_1.arrayify)(entropy);
      if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
        throw new Error("invalid entropy");
      }
      var indices = [0];
      var remainingBits = 11;
      for (var i10 = 0; i10 < entropy.length; i10++) {
        if (remainingBits > 8) {
          indices[indices.length - 1] <<= 8;
          indices[indices.length - 1] |= entropy[i10];
          remainingBits -= 8;
        } else {
          indices[indices.length - 1] <<= remainingBits;
          indices[indices.length - 1] |= entropy[i10] >> 8 - remainingBits;
          indices.push(entropy[i10] & getLowerMask(8 - remainingBits));
          remainingBits += 3;
        }
      }
      var checksumBits = entropy.length / 4;
      var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);
      indices[indices.length - 1] <<= checksumBits;
      indices[indices.length - 1] |= checksum >> 8 - checksumBits;
      return wordlist.join(indices.map(function(index) {
        return wordlist.getWord(index);
      }));
    }
    exports.entropyToMnemonic = entropyToMnemonic2;
    function isValidMnemonic2(mnemonic, wordlist) {
      try {
        mnemonicToEntropy2(mnemonic, wordlist);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isValidMnemonic = isValidMnemonic2;
    function getAccountPath2(index) {
      if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
        logger19.throwArgumentError("invalid account index", "index", index);
      }
      return "m/44'/60'/" + index + "'/0/0";
    }
    exports.getAccountPath = getAccountPath2;
  }
});

// node_modules/@ethersproject/random/lib/_version.js
var require_version17 = __commonJS({
  "node_modules/@ethersproject/random/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "random/5.7.0";
  }
});

// node_modules/@ethersproject/random/lib/browser-random.js
var require_browser_random = __commonJS({
  "node_modules/@ethersproject/random/lib/browser-random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version17();
    var logger19 = new logger_1.Logger(_version_1.version);
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    }
    var anyGlobal = getGlobal();
    var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto2 || !crypto2.getRandomValues) {
      logger19.warn("WARNING: Missing strong random number source");
      crypto2 = {
        getRandomValues: function(buffer) {
          return logger19.throwError("no secure random source avaialble", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
    function randomBytes4(length2) {
      if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
        logger19.throwArgumentError("invalid length", "length", length2);
      }
      var result = new Uint8Array(length2);
      crypto2.getRandomValues(result);
      return (0, bytes_1.arrayify)(result);
    }
    exports.randomBytes = randomBytes4;
  }
});

// node_modules/@ethersproject/random/lib/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/@ethersproject/random/lib/shuffle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = void 0;
    function shuffled3(array) {
      array = array.slice();
      for (var i10 = array.length - 1; i10 > 0; i10--) {
        var j8 = Math.floor(Math.random() * (i10 + 1));
        var tmp = array[i10];
        array[i10] = array[j8];
        array[j8] = tmp;
      }
      return array;
    }
    exports.shuffled = shuffled3;
  }
});

// node_modules/@ethersproject/random/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/@ethersproject/random/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = exports.randomBytes = void 0;
    var random_1 = require_browser_random();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    var shuffle_1 = require_shuffle();
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return shuffle_1.shuffled;
    } });
  }
});

// node_modules/@ethersproject/json-wallets/node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/@ethersproject/json-wallets/node_modules/aes-js/index.js"(exports, module) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i10 = 0; i10 < arrayish.length; i10++) {
          if (!checkInt(arrayish[i10]) || arrayish[i10] < 0 || arrayish[i10] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length2) {
        return new Uint8Array(length2);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i10 = 0;
          text = encodeURI(text);
          while (i10 < text.length) {
            var c8 = text.charCodeAt(i10++);
            if (c8 === 37) {
              result.push(parseInt(text.substr(i10, 2), 16));
              i10 += 2;
            } else {
              result.push(c8);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i10 = 0;
          while (i10 < bytes.length) {
            var c8 = bytes[i10];
            if (c8 < 128) {
              result.push(String.fromCharCode(c8));
              i10++;
            } else if (c8 > 191 && c8 < 224) {
              result.push(String.fromCharCode((c8 & 31) << 6 | bytes[i10 + 1] & 63));
              i10 += 2;
            } else {
              result.push(String.fromCharCode((c8 & 15) << 12 | (bytes[i10 + 1] & 63) << 6 | bytes[i10 + 2] & 63));
              i10 += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i10 = 0; i10 < text.length; i10 += 2) {
            result.push(parseInt(text.substr(i10, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i10 = 0; i10 < bytes.length; i10++) {
            var v7 = bytes[i10];
            result.push(Hex[(v7 & 240) >> 4] + Hex[v7 & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S7 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i10 = 0; i10 < bytes.length; i10 += 4) {
          result.push(
            bytes[i10] << 24 | bytes[i10 + 1] << 16 | bytes[i10 + 2] << 8 | bytes[i10 + 3]
          );
        }
        return result;
      }
      var AES = function(key) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i10 = 0; i10 <= rounds; i10++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i10 = 0; i10 < KC; i10++) {
          index = i10 >> 2;
          this._Ke[index][i10 % 4] = tk[i10];
          this._Kd[rounds - index][i10 % 4] = tk[i10];
        }
        var rconpointer = 0;
        var t8 = KC, tt4;
        while (t8 < roundKeyCount) {
          tt4 = tk[KC - 1];
          tk[0] ^= S7[tt4 >> 16 & 255] << 24 ^ S7[tt4 >> 8 & 255] << 16 ^ S7[tt4 & 255] << 8 ^ S7[tt4 >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i10 = 1; i10 < KC; i10++) {
              tk[i10] ^= tk[i10 - 1];
            }
          } else {
            for (var i10 = 1; i10 < KC / 2; i10++) {
              tk[i10] ^= tk[i10 - 1];
            }
            tt4 = tk[KC / 2 - 1];
            tk[KC / 2] ^= S7[tt4 & 255] ^ S7[tt4 >> 8 & 255] << 8 ^ S7[tt4 >> 16 & 255] << 16 ^ S7[tt4 >> 24 & 255] << 24;
            for (var i10 = KC / 2 + 1; i10 < KC; i10++) {
              tk[i10] ^= tk[i10 - 1];
            }
          }
          var i10 = 0, r7, c8;
          while (i10 < KC && t8 < roundKeyCount) {
            r7 = t8 >> 2;
            c8 = t8 % 4;
            this._Ke[r7][c8] = tk[i10];
            this._Kd[rounds - r7][c8] = tk[i10++];
            t8++;
          }
        }
        for (var r7 = 1; r7 < rounds; r7++) {
          for (var c8 = 0; c8 < 4; c8++) {
            tt4 = this._Kd[r7][c8];
            this._Kd[r7][c8] = U1[tt4 >> 24 & 255] ^ U22[tt4 >> 16 & 255] ^ U32[tt4 >> 8 & 255] ^ U42[tt4 & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a9 = [0, 0, 0, 0];
        var t8 = convertToInt32(plaintext);
        for (var i10 = 0; i10 < 4; i10++) {
          t8[i10] ^= this._Ke[0][i10];
        }
        for (var r7 = 1; r7 < rounds; r7++) {
          for (var i10 = 0; i10 < 4; i10++) {
            a9[i10] = T1[t8[i10] >> 24 & 255] ^ T22[t8[(i10 + 1) % 4] >> 16 & 255] ^ T32[t8[(i10 + 2) % 4] >> 8 & 255] ^ T42[t8[(i10 + 3) % 4] & 255] ^ this._Ke[r7][i10];
          }
          t8 = a9.slice();
        }
        var result = createArray(16), tt4;
        for (var i10 = 0; i10 < 4; i10++) {
          tt4 = this._Ke[rounds][i10];
          result[4 * i10] = (S7[t8[i10] >> 24 & 255] ^ tt4 >> 24) & 255;
          result[4 * i10 + 1] = (S7[t8[(i10 + 1) % 4] >> 16 & 255] ^ tt4 >> 16) & 255;
          result[4 * i10 + 2] = (S7[t8[(i10 + 2) % 4] >> 8 & 255] ^ tt4 >> 8) & 255;
          result[4 * i10 + 3] = (S7[t8[(i10 + 3) % 4] & 255] ^ tt4) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a9 = [0, 0, 0, 0];
        var t8 = convertToInt32(ciphertext);
        for (var i10 = 0; i10 < 4; i10++) {
          t8[i10] ^= this._Kd[0][i10];
        }
        for (var r7 = 1; r7 < rounds; r7++) {
          for (var i10 = 0; i10 < 4; i10++) {
            a9[i10] = T52[t8[i10] >> 24 & 255] ^ T6[t8[(i10 + 3) % 4] >> 16 & 255] ^ T7[t8[(i10 + 2) % 4] >> 8 & 255] ^ T8[t8[(i10 + 1) % 4] & 255] ^ this._Kd[r7][i10];
          }
          t8 = a9.slice();
        }
        var result = createArray(16), tt4;
        for (var i10 = 0; i10 < 4; i10++) {
          tt4 = this._Kd[rounds][i10];
          result[4 * i10] = (Si2[t8[i10] >> 24 & 255] ^ tt4 >> 24) & 255;
          result[4 * i10 + 1] = (Si2[t8[(i10 + 3) % 4] >> 16 & 255] ^ tt4 >> 16) & 255;
          result[4 * i10 + 2] = (Si2[t8[(i10 + 2) % 4] >> 8 & 255] ^ tt4 >> 8) & 255;
          result[4 * i10 + 3] = (Si2[t8[(i10 + 1) % 4] & 255] ^ tt4) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i10 = 0; i10 < plaintext.length; i10 += 16) {
          copyArray(plaintext, block, 0, i10, i10 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i10);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i10 = 0; i10 < ciphertext.length; i10 += 16) {
          copyArray(ciphertext, block, 0, i10, i10 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i10);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i10 = 0; i10 < plaintext.length; i10 += 16) {
          copyArray(plaintext, block, 0, i10, i10 + 16);
          for (var j8 = 0; j8 < 16; j8++) {
            block[j8] ^= this._lastCipherblock[j8];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i10);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i10 = 0; i10 < ciphertext.length; i10 += 16) {
          copyArray(ciphertext, block, 0, i10, i10 + 16);
          block = this._aes.decrypt(block);
          for (var j8 = 0; j8 < 16; j8++) {
            plaintext[i10 + j8] = block[j8] ^ this._lastCipherblock[j8];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i10, i10 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i10 = 0; i10 < encrypted.length; i10 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j8 = 0; j8 < this.segmentSize; j8++) {
            encrypted[i10 + j8] ^= xorSegment[j8];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i10, i10 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i10 = 0; i10 < plaintext.length; i10 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j8 = 0; j8 < this.segmentSize; j8++) {
            plaintext[i10 + j8] ^= xorSegment[j8];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i10, i10 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i10 = 0; i10 < encrypted.length; i10++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i10] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i10 = 15; i10 >= 0; i10--) {
          if (this._counter[i10] === 255) {
            this._counter[i10] = 0;
          } else {
            this._counter[i10]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i10 = 0; i10 < encrypted.length; i10++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i10] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data2) {
        data2 = coerceArray(data2, true);
        var padder = 16 - data2.length % 16;
        var result = createArray(data2.length + padder);
        copyArray(data2, result);
        for (var i10 = data2.length; i10 < result.length; i10++) {
          result[i10] = padder;
        }
        return result;
      }
      function pkcs7strip(data2) {
        data2 = coerceArray(data2, true);
        if (data2.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data2[data2.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length2 = data2.length - padder;
        for (var i10 = 0; i10 < padder; i10++) {
          if (data2[length2 + i10] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length2);
        copyArray(data2, result, 0, 0, length2);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib/_version.js
var require_version18 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "json-wallets/5.7.0";
  }
});

// node_modules/@ethersproject/json-wallets/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuidV4 = exports.searchPath = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    function looseArrayify(hexString) {
      if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
        hexString = "0x" + hexString;
      }
      return (0, bytes_1.arrayify)(hexString);
    }
    exports.looseArrayify = looseArrayify;
    function zpad(value, length2) {
      value = String(value);
      while (value.length < length2) {
        value = "0" + value;
      }
      return value;
    }
    exports.zpad = zpad;
    function getPassword(password) {
      if (typeof password === "string") {
        return (0, strings_1.toUtf8Bytes)(password, strings_1.UnicodeNormalizationForm.NFKC);
      }
      return (0, bytes_1.arrayify)(password);
    }
    exports.getPassword = getPassword;
    function searchPath(object, path) {
      var currentChild = object;
      var comps = path.toLowerCase().split("/");
      for (var i10 = 0; i10 < comps.length; i10++) {
        var matchingChild = null;
        for (var key in currentChild) {
          if (key.toLowerCase() === comps[i10]) {
            matchingChild = currentChild[key];
            break;
          }
        }
        if (matchingChild === null) {
          return null;
        }
        currentChild = matchingChild;
      }
      return currentChild;
    }
    exports.searchPath = searchPath;
    function uuidV4(randomBytes4) {
      var bytes = (0, bytes_1.arrayify)(randomBytes4);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      var value = (0, bytes_1.hexlify)(bytes);
      return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34)
      ].join("-");
    }
    exports.uuidV4 = uuidV4;
  }
});

// node_modules/@ethersproject/json-wallets/lib/crowdsale.js
var require_crowdsale = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/crowdsale.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.CrowdsaleAccount = void 0;
    var aes_js_1 = __importDefault2(require_aes_js());
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var pbkdf2_1 = require_lib20();
    var strings_1 = require_lib9();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version18();
    var logger19 = new logger_1.Logger(_version_1.version);
    var utils_1 = require_utils4();
    var CrowdsaleAccount = (
      /** @class */
      function(_super) {
        __extends2(CrowdsaleAccount2, _super);
        function CrowdsaleAccount2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CrowdsaleAccount2.prototype.isCrowdsaleAccount = function(value) {
          return !!(value && value._isCrowdsaleAccount);
        };
        return CrowdsaleAccount2;
      }(properties_1.Description)
    );
    exports.CrowdsaleAccount = CrowdsaleAccount;
    function decrypt2(json, password) {
      var data2 = JSON.parse(json);
      password = (0, utils_1.getPassword)(password);
      var ethaddr = (0, address_1.getAddress)((0, utils_1.searchPath)(data2, "ethaddr"));
      var encseed = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "encseed"));
      if (!encseed || encseed.length % 16 !== 0) {
        logger19.throwArgumentError("invalid encseed", "json", json);
      }
      var key = (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(password, password, 2e3, 32, "sha256")).slice(0, 16);
      var iv = encseed.slice(0, 16);
      var encryptedSeed = encseed.slice(16);
      var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
      var seed = aes_js_1.default.padding.pkcs7.strip((0, bytes_1.arrayify)(aesCbc.decrypt(encryptedSeed)));
      var seedHex = "";
      for (var i10 = 0; i10 < seed.length; i10++) {
        seedHex += String.fromCharCode(seed[i10]);
      }
      var seedHexBytes = (0, strings_1.toUtf8Bytes)(seedHex);
      var privateKey = (0, keccak256_1.keccak256)(seedHexBytes);
      return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey
      });
    }
    exports.decrypt = decrypt2;
  }
});

// node_modules/@ethersproject/json-wallets/lib/inspect.js
var require_inspect = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/inspect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = void 0;
    var address_1 = require_lib7();
    function isCrowdsaleWallet(json) {
      var data2 = null;
      try {
        data2 = JSON.parse(json);
      } catch (error) {
        return false;
      }
      return data2.encseed && data2.ethaddr;
    }
    exports.isCrowdsaleWallet = isCrowdsaleWallet;
    function isKeystoreWallet(json) {
      var data2 = null;
      try {
        data2 = JSON.parse(json);
      } catch (error) {
        return false;
      }
      if (!data2.version || parseInt(data2.version) !== data2.version || parseInt(data2.version) !== 3) {
        return false;
      }
      return true;
    }
    exports.isKeystoreWallet = isKeystoreWallet;
    function getJsonWalletAddress2(json) {
      if (isCrowdsaleWallet(json)) {
        try {
          return (0, address_1.getAddress)(JSON.parse(json).ethaddr);
        } catch (error) {
          return null;
        }
      }
      if (isKeystoreWallet(json)) {
        try {
          return (0, address_1.getAddress)(JSON.parse(json).address);
        } catch (error) {
          return null;
        }
      }
      return null;
    }
    exports.getJsonWalletAddress = getJsonWalletAddress2;
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA256(m11) {
        const K6 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
        let h42 = 1359893119, h52 = 2600822924, h62 = 528734635, h72 = 1541459225;
        const w11 = new Uint32Array(64);
        function blocks(p11) {
          let off = 0, len = p11.length;
          while (len >= 64) {
            let a9 = h0, b10 = h1, c8 = h22, d9 = h32, e11 = h42, f7 = h52, g9 = h62, h11 = h72, u9, i11, j8, t1, t22;
            for (i11 = 0; i11 < 16; i11++) {
              j8 = off + i11 * 4;
              w11[i11] = (p11[j8] & 255) << 24 | (p11[j8 + 1] & 255) << 16 | (p11[j8 + 2] & 255) << 8 | p11[j8 + 3] & 255;
            }
            for (i11 = 16; i11 < 64; i11++) {
              u9 = w11[i11 - 2];
              t1 = (u9 >>> 17 | u9 << 32 - 17) ^ (u9 >>> 19 | u9 << 32 - 19) ^ u9 >>> 10;
              u9 = w11[i11 - 15];
              t22 = (u9 >>> 7 | u9 << 32 - 7) ^ (u9 >>> 18 | u9 << 32 - 18) ^ u9 >>> 3;
              w11[i11] = (t1 + w11[i11 - 7] | 0) + (t22 + w11[i11 - 16] | 0) | 0;
            }
            for (i11 = 0; i11 < 64; i11++) {
              t1 = (((e11 >>> 6 | e11 << 32 - 6) ^ (e11 >>> 11 | e11 << 32 - 11) ^ (e11 >>> 25 | e11 << 32 - 25)) + (e11 & f7 ^ ~e11 & g9) | 0) + (h11 + (K6[i11] + w11[i11] | 0) | 0) | 0;
              t22 = ((a9 >>> 2 | a9 << 32 - 2) ^ (a9 >>> 13 | a9 << 32 - 13) ^ (a9 >>> 22 | a9 << 32 - 22)) + (a9 & b10 ^ a9 & c8 ^ b10 & c8) | 0;
              h11 = g9;
              g9 = f7;
              f7 = e11;
              e11 = d9 + t1 | 0;
              d9 = c8;
              c8 = b10;
              b10 = a9;
              a9 = t1 + t22 | 0;
            }
            h0 = h0 + a9 | 0;
            h1 = h1 + b10 | 0;
            h22 = h22 + c8 | 0;
            h32 = h32 + d9 | 0;
            h42 = h42 + e11 | 0;
            h52 = h52 + f7 | 0;
            h62 = h62 + g9 | 0;
            h72 = h72 + h11 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m11);
        let i10, bytesLeft = m11.length % 64, bitLenHi = m11.length / 536870912 | 0, bitLenLo = m11.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p10 = m11.slice(m11.length - bytesLeft, m11.length);
        p10.push(128);
        for (i10 = bytesLeft + 1; i10 < numZeros; i10++) {
          p10.push(0);
        }
        p10.push(bitLenHi >>> 24 & 255);
        p10.push(bitLenHi >>> 16 & 255);
        p10.push(bitLenHi >>> 8 & 255);
        p10.push(bitLenHi >>> 0 & 255);
        p10.push(bitLenLo >>> 24 & 255);
        p10.push(bitLenLo >>> 16 & 255);
        p10.push(bitLenLo >>> 8 & 255);
        p10.push(bitLenLo >>> 0 & 255);
        blocks(p10);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h22 >>> 24 & 255,
          h22 >>> 16 & 255,
          h22 >>> 8 & 255,
          h22 >>> 0 & 255,
          h32 >>> 24 & 255,
          h32 >>> 16 & 255,
          h32 >>> 8 & 255,
          h32 >>> 0 & 255,
          h42 >>> 24 & 255,
          h42 >>> 16 & 255,
          h42 >>> 8 & 255,
          h42 >>> 0 & 255,
          h52 >>> 24 & 255,
          h52 >>> 16 & 255,
          h52 >>> 8 & 255,
          h52 >>> 0 & 255,
          h62 >>> 24 & 255,
          h62 >>> 16 & 255,
          h62 >>> 8 & 255,
          h62 >>> 0 & 255,
          h72 >>> 24 & 255,
          h72 >>> 16 & 255,
          h72 >>> 8 & 255,
          h72 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i10;
        let dk = [];
        for (i10 = 0; i10 < 64; i10++) {
          inner[i10] = 54;
        }
        for (i10 = 0; i10 < password.length; i10++) {
          inner[i10] ^= password[i10];
        }
        for (i10 = 0; i10 < salt.length; i10++) {
          inner[64 + i10] = salt[i10];
        }
        for (i10 = innerLen - 4; i10 < innerLen; i10++) {
          inner[i10] = 0;
        }
        for (i10 = 0; i10 < 64; i10++)
          outerKey[i10] = 92;
        for (i10 = 0; i10 < password.length; i10++)
          outerKey[i10] ^= password[i10];
        function incrementCounter() {
          for (let i11 = innerLen - 1; i11 >= innerLen - 4; i11--) {
            inner[i11]++;
            if (inner[i11] <= 255)
              return;
            inner[i11] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi2, r7, x8, _X) {
        let i10;
        arraycopy(BY, (2 * r7 - 1) * 16, _X, 0, 16);
        for (i10 = 0; i10 < 2 * r7; i10++) {
          blockxor(BY, i10 * 16, _X, 16);
          salsa20_8(_X, x8);
          arraycopy(_X, 0, BY, Yi2 + i10 * 16, 16);
        }
        for (i10 = 0; i10 < r7; i10++) {
          arraycopy(BY, Yi2 + i10 * 2 * 16, BY, i10 * 16, 16);
        }
        for (i10 = 0; i10 < r7; i10++) {
          arraycopy(BY, Yi2 + (i10 * 2 + 1) * 16, BY, (i10 + r7) * 16, 16);
        }
      }
      function R5(a9, b10) {
        return a9 << b10 | a9 >>> 32 - b10;
      }
      function salsa20_8(B9, x8) {
        arraycopy(B9, 0, x8, 0, 16);
        for (let i10 = 8; i10 > 0; i10 -= 2) {
          x8[4] ^= R5(x8[0] + x8[12], 7);
          x8[8] ^= R5(x8[4] + x8[0], 9);
          x8[12] ^= R5(x8[8] + x8[4], 13);
          x8[0] ^= R5(x8[12] + x8[8], 18);
          x8[9] ^= R5(x8[5] + x8[1], 7);
          x8[13] ^= R5(x8[9] + x8[5], 9);
          x8[1] ^= R5(x8[13] + x8[9], 13);
          x8[5] ^= R5(x8[1] + x8[13], 18);
          x8[14] ^= R5(x8[10] + x8[6], 7);
          x8[2] ^= R5(x8[14] + x8[10], 9);
          x8[6] ^= R5(x8[2] + x8[14], 13);
          x8[10] ^= R5(x8[6] + x8[2], 18);
          x8[3] ^= R5(x8[15] + x8[11], 7);
          x8[7] ^= R5(x8[3] + x8[15], 9);
          x8[11] ^= R5(x8[7] + x8[3], 13);
          x8[15] ^= R5(x8[11] + x8[7], 18);
          x8[1] ^= R5(x8[0] + x8[3], 7);
          x8[2] ^= R5(x8[1] + x8[0], 9);
          x8[3] ^= R5(x8[2] + x8[1], 13);
          x8[0] ^= R5(x8[3] + x8[2], 18);
          x8[6] ^= R5(x8[5] + x8[4], 7);
          x8[7] ^= R5(x8[6] + x8[5], 9);
          x8[4] ^= R5(x8[7] + x8[6], 13);
          x8[5] ^= R5(x8[4] + x8[7], 18);
          x8[11] ^= R5(x8[10] + x8[9], 7);
          x8[8] ^= R5(x8[11] + x8[10], 9);
          x8[9] ^= R5(x8[8] + x8[11], 13);
          x8[10] ^= R5(x8[9] + x8[8], 18);
          x8[12] ^= R5(x8[15] + x8[14], 7);
          x8[13] ^= R5(x8[12] + x8[15], 9);
          x8[14] ^= R5(x8[13] + x8[12], 13);
          x8[15] ^= R5(x8[14] + x8[13], 18);
        }
        for (let i10 = 0; i10 < 16; ++i10) {
          B9[i10] += x8[i10];
        }
      }
      function blockxor(S7, Si2, D7, len) {
        for (let i10 = 0; i10 < len; i10++) {
          D7[i10] ^= S7[Si2 + i10];
        }
      }
      function arraycopy(src2, srcPos, dest, destPos, length2) {
        while (length2--) {
          dest[destPos++] = src2[srcPos++];
        }
      }
      function checkBufferish(o11) {
        if (!o11 || typeof o11.length !== "number") {
          return false;
        }
        for (let i10 = 0; i10 < o11.length; i10++) {
          const v7 = o11[i10];
          if (typeof v7 !== "number" || v7 % 1 || v7 < 0 || v7 >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name2) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name2);
        }
        return value;
      }
      function _scrypt(password, salt, N16, r7, p10, dkLen, callback) {
        N16 = ensureInteger(N16, "N");
        r7 = ensureInteger(r7, "r");
        p10 = ensureInteger(p10, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N16 === 0 || (N16 & N16 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N16 > MAX_VALUE / 128 / r7) {
          throw new Error("N too large");
        }
        if (r7 > MAX_VALUE / 128 / p10) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b10 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p10 * 128 * r7);
        const B9 = new Uint32Array(p10 * 32 * r7);
        for (let i10 = 0; i10 < B9.length; i10++) {
          const j8 = i10 * 4;
          B9[i10] = (b10[j8 + 3] & 255) << 24 | (b10[j8 + 2] & 255) << 16 | (b10[j8 + 1] & 255) << 8 | (b10[j8 + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r7);
        const V8 = new Uint32Array(32 * r7 * N16);
        const Yi2 = 32 * r7;
        const x8 = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p10 * N16 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi2;
        const limit = callback ? parseInt(1e3 / r7) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps2;
          switch (state) {
            case 0:
              Bi2 = i0 * 32 * r7;
              arraycopy(B9, Bi2, XY, 0, Yi2);
              state = 1;
              i1 = 0;
            case 1:
              steps2 = N16 - i1;
              if (steps2 > limit) {
                steps2 = limit;
              }
              for (let i10 = 0; i10 < steps2; i10++) {
                arraycopy(XY, 0, V8, (i1 + i10) * Yi2, Yi2);
                blockmix_salsa8(XY, Yi2, r7, x8, _X);
              }
              i1 += steps2;
              currentOp += steps2;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N16) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps2 = N16 - i1;
              if (steps2 > limit) {
                steps2 = limit;
              }
              for (let i10 = 0; i10 < steps2; i10++) {
                const offset = (2 * r7 - 1) * 16;
                const j8 = XY[offset] & N16 - 1;
                blockxor(V8, j8 * Yi2, XY, Yi2);
                blockmix_salsa8(XY, Yi2, r7, x8, _X);
              }
              i1 += steps2;
              currentOp += steps2;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N16) {
                break;
              }
              arraycopy(XY, 0, B9, Bi2, Yi2);
              i0++;
              if (i0 < p10) {
                state = 0;
                break;
              }
              b10 = [];
              for (let i10 = 0; i10 < B9.length; i10++) {
                b10.push(B9[i10] >> 0 & 255);
                b10.push(B9[i10] >> 8 & 255);
                b10.push(B9[i10] >> 16 & 255);
                b10.push(B9[i10] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b10, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N16, r7, p10, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N16, r7, p10, dkLen, function(error, progress2, key) {
              if (error) {
                reject(error);
              } else if (key) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key));
              } else if (progressCallback && progress2 !== lastProgress) {
                lastProgress = progress2;
                return progressCallback(progress2);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N16, r7, p10, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N16, r7, p10, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib/keystore.js
var require_keystore = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/keystore.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = void 0;
    var aes_js_1 = __importDefault2(require_aes_js());
    var scrypt_js_1 = __importDefault2(require_scrypt());
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var hdnode_1 = require_lib22();
    var keccak256_1 = require_lib5();
    var pbkdf2_1 = require_lib20();
    var random_1 = require_lib23();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib17();
    var utils_1 = require_utils4();
    var logger_1 = require_lib();
    var _version_1 = require_version18();
    var logger19 = new logger_1.Logger(_version_1.version);
    function hasMnemonic(value) {
      return value != null && value.mnemonic && value.mnemonic.phrase;
    }
    var KeystoreAccount = (
      /** @class */
      function(_super) {
        __extends2(KeystoreAccount2, _super);
        function KeystoreAccount2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        KeystoreAccount2.prototype.isKeystoreAccount = function(value) {
          return !!(value && value._isKeystoreAccount);
        };
        return KeystoreAccount2;
      }(properties_1.Description)
    );
    exports.KeystoreAccount = KeystoreAccount;
    function _decrypt(data2, key, ciphertext) {
      var cipher = (0, utils_1.searchPath)(data2, "crypto/cipher");
      if (cipher === "aes-128-ctr") {
        var iv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "crypto/cipherparams/iv"));
        var counter = new aes_js_1.default.Counter(iv);
        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);
        return (0, bytes_1.arrayify)(aesCtr.decrypt(ciphertext));
      }
      return null;
    }
    function _getAccount(data2, key) {
      var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "crypto/ciphertext"));
      var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
      if (computedMAC !== (0, utils_1.searchPath)(data2, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
      }
      var privateKey = _decrypt(data2, key.slice(0, 16), ciphertext);
      if (!privateKey) {
        logger19.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "decrypt"
        });
      }
      var mnemonicKey = key.slice(32, 64);
      var address = (0, transactions_1.computeAddress)(privateKey);
      if (data2.address) {
        var check = data2.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
          check = "0x" + check;
        }
        if ((0, address_1.getAddress)(check) !== address) {
          throw new Error("address mismatch");
        }
      }
      var account = {
        _isKeystoreAccount: true,
        address,
        privateKey: (0, bytes_1.hexlify)(privateKey)
      };
      if ((0, utils_1.searchPath)(data2, "x-ethers/version") === "0.1") {
        var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "x-ethers/mnemonicCiphertext"));
        var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "x-ethers/mnemonicCounter"));
        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        var path = (0, utils_1.searchPath)(data2, "x-ethers/path") || hdnode_1.defaultPath;
        var locale = (0, utils_1.searchPath)(data2, "x-ethers/locale") || "en";
        var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
          var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
          var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
          if (node.privateKey != account.privateKey) {
            throw new Error("mnemonic mismatch");
          }
          account.mnemonic = node.mnemonic;
        } catch (error) {
          if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
            throw error;
          }
        }
      }
      return new KeystoreAccount(account);
    }
    function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
      return (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
    }
    function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
      return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
    }
    function _computeKdfKey(data2, password, pbkdf2Func, scryptFunc, progressCallback) {
      var passwordBytes = (0, utils_1.getPassword)(password);
      var kdf = (0, utils_1.searchPath)(data2, "crypto/kdf");
      if (kdf && typeof kdf === "string") {
        var throwError = function(name2, value) {
          return logger19.throwArgumentError("invalid key-derivation function parameters", name2, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
          var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "crypto/kdfparams/salt"));
          var N16 = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/n"));
          var r7 = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/r"));
          var p10 = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/p"));
          if (!N16 || !r7 || !p10) {
            throwError("kdf", kdf);
          }
          if ((N16 & N16 - 1) !== 0) {
            throwError("N", N16);
          }
          var dkLen = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/dklen"));
          if (dkLen !== 32) {
            throwError("dklen", dkLen);
          }
          return scryptFunc(passwordBytes, salt, N16, r7, p10, 64, progressCallback);
        } else if (kdf.toLowerCase() === "pbkdf2") {
          var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data2, "crypto/kdfparams/salt"));
          var prfFunc = null;
          var prf = (0, utils_1.searchPath)(data2, "crypto/kdfparams/prf");
          if (prf === "hmac-sha256") {
            prfFunc = "sha256";
          } else if (prf === "hmac-sha512") {
            prfFunc = "sha512";
          } else {
            throwError("prf", prf);
          }
          var count = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/c"));
          var dkLen = parseInt((0, utils_1.searchPath)(data2, "crypto/kdfparams/dklen"));
          if (dkLen !== 32) {
            throwError("dklen", dkLen);
          }
          return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
      }
      return logger19.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
    }
    function decryptSync(json, password) {
      var data2 = JSON.parse(json);
      var key = _computeKdfKey(data2, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);
      return _getAccount(data2, key);
    }
    exports.decryptSync = decryptSync;
    function decrypt2(json, password, progressCallback) {
      return __awaiter10(this, void 0, void 0, function() {
        var data2, key;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              data2 = JSON.parse(json);
              return [4, _computeKdfKey(data2, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback)];
            case 1:
              key = _a2.sent();
              return [2, _getAccount(data2, key)];
          }
        });
      });
    }
    exports.decrypt = decrypt2;
    function encrypt2(account, password, options, progressCallback) {
      try {
        if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
          throw new Error("address/privateKey mismatch");
        }
        if (hasMnemonic(account)) {
          var mnemonic = account.mnemonic;
          var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
          if (node.privateKey != account.privateKey) {
            throw new Error("mnemonic mismatch");
          }
        }
      } catch (e11) {
        return Promise.reject(e11);
      }
      if (typeof options === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      var privateKey = (0, bytes_1.arrayify)(account.privateKey);
      var passwordBytes = (0, utils_1.getPassword)(password);
      var entropy = null;
      var path = null;
      var locale = null;
      if (hasMnemonic(account)) {
        var srcMnemonic = account.mnemonic;
        entropy = (0, bytes_1.arrayify)((0, hdnode_1.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || hdnode_1.defaultPath;
        locale = srcMnemonic.locale || "en";
      }
      var client2 = options.client;
      if (!client2) {
        client2 = "ethers.js";
      }
      var salt = null;
      if (options.salt) {
        salt = (0, bytes_1.arrayify)(options.salt);
      } else {
        salt = (0, random_1.randomBytes)(32);
        ;
      }
      var iv = null;
      if (options.iv) {
        iv = (0, bytes_1.arrayify)(options.iv);
        if (iv.length !== 16) {
          throw new Error("invalid iv");
        }
      } else {
        iv = (0, random_1.randomBytes)(16);
      }
      var uuidRandom = null;
      if (options.uuid) {
        uuidRandom = (0, bytes_1.arrayify)(options.uuid);
        if (uuidRandom.length !== 16) {
          throw new Error("invalid uuid");
        }
      } else {
        uuidRandom = (0, random_1.randomBytes)(16);
      }
      var N16 = 1 << 17, r7 = 8, p10 = 1;
      if (options.scrypt) {
        if (options.scrypt.N) {
          N16 = options.scrypt.N;
        }
        if (options.scrypt.r) {
          r7 = options.scrypt.r;
        }
        if (options.scrypt.p) {
          p10 = options.scrypt.p;
        }
      }
      return scrypt_js_1.default.scrypt(passwordBytes, salt, N16, r7, p10, 64, progressCallback).then(function(key) {
        key = (0, bytes_1.arrayify)(key);
        var derivedKey = key.slice(0, 16);
        var macPrefix = key.slice(16, 32);
        var mnemonicKey = key.slice(32, 64);
        var counter = new aes_js_1.default.Counter(iv);
        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
        var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
        var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
        var data2 = {
          address: account.address.substring(2).toLowerCase(),
          id: (0, utils_1.uuidV4)(uuidRandom),
          version: 3,
          crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
              iv: (0, bytes_1.hexlify)(iv).substring(2)
            },
            ciphertext: (0, bytes_1.hexlify)(ciphertext).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: (0, bytes_1.hexlify)(salt).substring(2),
              n: N16,
              dklen: 32,
              p: p10,
              r: r7
            },
            mac: mac.substring(2)
          }
        };
        if (entropy) {
          var mnemonicIv = (0, random_1.randomBytes)(16);
          var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
          var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
          var mnemonicCiphertext = (0, bytes_1.arrayify)(mnemonicAesCtr.encrypt(entropy));
          var now2 = /* @__PURE__ */ new Date();
          var timestamp = now2.getUTCFullYear() + "-" + (0, utils_1.zpad)(now2.getUTCMonth() + 1, 2) + "-" + (0, utils_1.zpad)(now2.getUTCDate(), 2) + "T" + (0, utils_1.zpad)(now2.getUTCHours(), 2) + "-" + (0, utils_1.zpad)(now2.getUTCMinutes(), 2) + "-" + (0, utils_1.zpad)(now2.getUTCSeconds(), 2) + ".0Z";
          data2["x-ethers"] = {
            client: client2,
            gethFilename: "UTC--" + timestamp + "--" + data2.address,
            mnemonicCounter: (0, bytes_1.hexlify)(mnemonicIv).substring(2),
            mnemonicCiphertext: (0, bytes_1.hexlify)(mnemonicCiphertext).substring(2),
            path,
            locale,
            version: "0.1"
          };
        }
        return JSON.stringify(data2);
      });
    }
    exports.encrypt = encrypt2;
  }
});

// node_modules/@ethersproject/json-wallets/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptJsonWalletSync = exports.decryptJsonWallet = exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = exports.encryptKeystore = exports.decryptKeystoreSync = exports.decryptKeystore = exports.decryptCrowdsale = void 0;
    var crowdsale_1 = require_crowdsale();
    Object.defineProperty(exports, "decryptCrowdsale", { enumerable: true, get: function() {
      return crowdsale_1.decrypt;
    } });
    var inspect_1 = require_inspect();
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return inspect_1.getJsonWalletAddress;
    } });
    Object.defineProperty(exports, "isCrowdsaleWallet", { enumerable: true, get: function() {
      return inspect_1.isCrowdsaleWallet;
    } });
    Object.defineProperty(exports, "isKeystoreWallet", { enumerable: true, get: function() {
      return inspect_1.isKeystoreWallet;
    } });
    var keystore_1 = require_keystore();
    Object.defineProperty(exports, "decryptKeystore", { enumerable: true, get: function() {
      return keystore_1.decrypt;
    } });
    Object.defineProperty(exports, "decryptKeystoreSync", { enumerable: true, get: function() {
      return keystore_1.decryptSync;
    } });
    Object.defineProperty(exports, "encryptKeystore", { enumerable: true, get: function() {
      return keystore_1.encrypt;
    } });
    function decryptJsonWallet(json, password, progressCallback) {
      if ((0, inspect_1.isCrowdsaleWallet)(json)) {
        if (progressCallback) {
          progressCallback(0);
        }
        var account = (0, crowdsale_1.decrypt)(json, password);
        if (progressCallback) {
          progressCallback(1);
        }
        return Promise.resolve(account);
      }
      if ((0, inspect_1.isKeystoreWallet)(json)) {
        return (0, keystore_1.decrypt)(json, password, progressCallback);
      }
      return Promise.reject(new Error("invalid JSON wallet"));
    }
    exports.decryptJsonWallet = decryptJsonWallet;
    function decryptJsonWalletSync(json, password) {
      if ((0, inspect_1.isCrowdsaleWallet)(json)) {
        return (0, crowdsale_1.decrypt)(json, password);
      }
      if ((0, inspect_1.isKeystoreWallet)(json)) {
        return (0, keystore_1.decryptSync)(json, password);
      }
      throw new Error("invalid JSON wallet");
    }
    exports.decryptJsonWalletSync = decryptJsonWalletSync;
  }
});

// node_modules/@ethersproject/wallet/lib/_version.js
var require_version19 = __commonJS({
  "node_modules/@ethersproject/wallet/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "wallet/5.7.0";
  }
});

// node_modules/@ethersproject/wallet/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/@ethersproject/wallet/lib/index.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d9, b10) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
          d10.__proto__ = b11;
        } || function(d10, b11) {
          for (var p10 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p10))
              d10[p10] = b11[p10];
        };
        return extendStatics2(d9, b10);
      };
      return function(d9, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics2(d9, b10);
        function __() {
          this.constructor = d9;
        }
        d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = exports.verifyMessage = exports.Wallet = void 0;
    var address_1 = require_lib7();
    var abstract_provider_1 = require_lib14();
    var abstract_signer_1 = require_lib15();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib12();
    var hdnode_1 = require_lib22();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var random_1 = require_lib23();
    var signing_key_1 = require_lib16();
    var json_wallets_1 = require_lib24();
    var transactions_1 = require_lib17();
    var logger_1 = require_lib();
    var _version_1 = require_version19();
    var logger19 = new logger_1.Logger(_version_1.version);
    function isAccount(value) {
      return value != null && (0, bytes_1.isHexString)(value.privateKey, 32) && value.address != null;
    }
    function hasMnemonic(value) {
      var mnemonic = value.mnemonic;
      return mnemonic && mnemonic.phrase;
    }
    var Wallet2 = (
      /** @class */
      function(_super) {
        __extends2(Wallet3, _super);
        function Wallet3(privateKey, provider) {
          var _this = _super.call(this) || this;
          if (isAccount(privateKey)) {
            var signingKey_1 = new signing_key_1.SigningKey(privateKey.privateKey);
            (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
              return signingKey_1;
            });
            (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
            if (_this.address !== (0, address_1.getAddress)(privateKey.address)) {
              logger19.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
            }
            if (hasMnemonic(privateKey)) {
              var srcMnemonic_1 = privateKey.mnemonic;
              (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
                return {
                  phrase: srcMnemonic_1.phrase,
                  path: srcMnemonic_1.path || hdnode_1.defaultPath,
                  locale: srcMnemonic_1.locale || "en"
                };
              });
              var mnemonic = _this.mnemonic;
              var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
              if ((0, transactions_1.computeAddress)(node.privateKey) !== _this.address) {
                logger19.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
              }
            } else {
              (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
                return null;
              });
            }
          } else {
            if (signing_key_1.SigningKey.isSigningKey(privateKey)) {
              if (privateKey.curve !== "secp256k1") {
                logger19.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
              }
              (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
                return privateKey;
              });
            } else {
              if (typeof privateKey === "string") {
                if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                  privateKey = "0x" + privateKey;
                }
              }
              var signingKey_2 = new signing_key_1.SigningKey(privateKey);
              (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
                return signingKey_2;
              });
            }
            (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
              return null;
            });
            (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
          }
          if (provider && !abstract_provider_1.Provider.isProvider(provider)) {
            logger19.throwArgumentError("invalid provider", "provider", provider);
          }
          (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
          return _this;
        }
        Object.defineProperty(Wallet3.prototype, "mnemonic", {
          get: function() {
            return this._mnemonic();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Wallet3.prototype, "privateKey", {
          get: function() {
            return this._signingKey().privateKey;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Wallet3.prototype, "publicKey", {
          get: function() {
            return this._signingKey().publicKey;
          },
          enumerable: false,
          configurable: true
        });
        Wallet3.prototype.getAddress = function() {
          return Promise.resolve(this.address);
        };
        Wallet3.prototype.connect = function(provider) {
          return new Wallet3(this, provider);
        };
        Wallet3.prototype.signTransaction = function(transaction) {
          var _this = this;
          return (0, properties_1.resolveProperties)(transaction).then(function(tx) {
            if (tx.from != null) {
              if ((0, address_1.getAddress)(tx.from) !== _this.address) {
                logger19.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
              }
              delete tx.from;
            }
            var signature = _this._signingKey().signDigest((0, keccak256_1.keccak256)((0, transactions_1.serialize)(tx)));
            return (0, transactions_1.serialize)(tx, signature);
          });
        };
        Wallet3.prototype.signMessage = function(message) {
          return __awaiter10(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest((0, hash_1.hashMessage)(message)))];
            });
          });
        };
        Wallet3.prototype._signTypedData = function(domain2, types, value) {
          return __awaiter10(this, void 0, void 0, function() {
            var populated;
            var _this = this;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, hash_1._TypedDataEncoder.resolveNames(domain2, types, value, function(name2) {
                    if (_this.provider == null) {
                      logger19.throwError("cannot resolve ENS names without a provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "resolveName",
                        value: name2
                      });
                    }
                    return _this.provider.resolveName(name2);
                  })];
                case 1:
                  populated = _a2.sent();
                  return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest(hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value)))];
              }
            });
          });
        };
        Wallet3.prototype.encrypt = function(password, options, progressCallback) {
          if (typeof options === "function" && !progressCallback) {
            progressCallback = options;
            options = {};
          }
          if (progressCallback && typeof progressCallback !== "function") {
            throw new Error("invalid callback");
          }
          if (!options) {
            options = {};
          }
          return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
        };
        Wallet3.createRandom = function(options) {
          var entropy = (0, random_1.randomBytes)(16);
          if (!options) {
            options = {};
          }
          if (options.extraEntropy) {
            entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
          }
          var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
          return Wallet3.fromMnemonic(mnemonic, options.path, options.locale);
        };
        Wallet3.fromEncryptedJson = function(json, password, progressCallback) {
          return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then(function(account) {
            return new Wallet3(account);
          });
        };
        Wallet3.fromEncryptedJsonSync = function(json, password) {
          return new Wallet3((0, json_wallets_1.decryptJsonWalletSync)(json, password));
        };
        Wallet3.fromMnemonic = function(mnemonic, path, wordlist) {
          if (!path) {
            path = hdnode_1.defaultPath;
          }
          return new Wallet3(hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
        };
        return Wallet3;
      }(abstract_signer_1.Signer)
    );
    exports.Wallet = Wallet2;
    function verifyMessage2(message, signature) {
      return (0, transactions_1.recoverAddress)((0, hash_1.hashMessage)(message), signature);
    }
    exports.verifyMessage = verifyMessage2;
    function verifyTypedData2(domain2, types, value, signature) {
      return (0, transactions_1.recoverAddress)(hash_1._TypedDataEncoder.hash(domain2, types, value), signature);
    }
    exports.verifyTypedData = verifyTypedData2;
  }
});

// node_modules/@ethersproject/web/lib/_version.js
var require_version20 = __commonJS({
  "node_modules/@ethersproject/web/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "web/5.7.1";
  }
});

// node_modules/@ethersproject/web/lib/browser-geturl.js
var require_browser_geturl = __commonJS({
  "node_modules/@ethersproject/web/lib/browser-geturl.js"(exports) {
    "use strict";
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUrl = void 0;
    var bytes_1 = require_lib2();
    function getUrl(href, options) {
      return __awaiter10(this, void 0, void 0, function() {
        var request, opts, response, body, headers;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (options == null) {
                options = {};
              }
              request = {
                method: options.method || "GET",
                headers: options.headers || {},
                body: options.body || void 0
              };
              if (options.skipFetchSetup !== true) {
                request.mode = "cors";
                request.cache = "no-cache";
                request.credentials = "same-origin";
                request.redirect = "follow";
                request.referrer = "client";
              }
              ;
              if (options.fetchOptions != null) {
                opts = options.fetchOptions;
                if (opts.mode) {
                  request.mode = opts.mode;
                }
                if (opts.cache) {
                  request.cache = opts.cache;
                }
                if (opts.credentials) {
                  request.credentials = opts.credentials;
                }
                if (opts.redirect) {
                  request.redirect = opts.redirect;
                }
                if (opts.referrer) {
                  request.referrer = opts.referrer;
                }
              }
              return [4, fetch(href, request)];
            case 1:
              response = _a2.sent();
              return [4, response.arrayBuffer()];
            case 2:
              body = _a2.sent();
              headers = {};
              if (response.headers.forEach) {
                response.headers.forEach(function(value, key) {
                  headers[key.toLowerCase()] = value;
                });
              } else {
                response.headers.keys().forEach(function(key) {
                  headers[key.toLowerCase()] = response.headers.get(key);
                });
              }
              return [2, {
                headers,
                statusCode: response.status,
                statusMessage: response.statusText,
                body: (0, bytes_1.arrayify)(new Uint8Array(body))
              }];
          }
        });
      });
    }
    exports.getUrl = getUrl;
  }
});

// node_modules/@ethersproject/web/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/@ethersproject/web/lib/index.js"(exports) {
    "use strict";
    var __awaiter10 = exports && exports.__awaiter || function(thisArg, _arguments, P10, generator) {
      function adopt(value) {
        return value instanceof P10 ? value : new P10(function(resolve) {
          resolve(value);
        });
      }
      return new (P10 || (P10 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e11) {
            reject(e11);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e11) {
            reject(e11);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _8 = { label: 0, sent: function() {
        if (t8[0] & 1)
          throw t8[1];
        return t8[1];
      }, trys: [], ops: [] }, f7, y10, t8, g9;
      return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
        return this;
      }), g9;
      function verb(n8) {
        return function(v7) {
          return step([n8, v7]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_8)
          try {
            if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
              return t8;
            if (y10 = 0, t8)
              op = [op[0] & 2, t8.value];
            switch (op[0]) {
              case 0:
              case 1:
                t8 = op;
                break;
              case 4:
                _8.label++;
                return { value: op[1], done: false };
              case 5:
                _8.label++;
                y10 = op[1];
                op = [0];
                continue;
              case 7:
                op = _8.ops.pop();
                _8.trys.pop();
                continue;
              default:
                if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _8 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                  _8.label = op[1];
                  break;
                }
                if (op[0] === 6 && _8.label < t8[1]) {
                  _8.label = t8[1];
                  t8 = op;
                  break;
                }
                if (t8 && _8.label < t8[2]) {
                  _8.label = t8[2];
                  _8.ops.push(op);
                  break;
                }
                if (t8[2])
                  _8.ops.pop();
                _8.trys.pop();
                continue;
            }
            op = body.call(thisArg, _8);
          } catch (e11) {
            op = [6, e11];
            y10 = 0;
          } finally {
            f7 = t8 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = exports.fetchJson = exports._fetchData = void 0;
    var base64_1 = require_lib10();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var strings_1 = require_lib9();
    var logger_1 = require_lib();
    var _version_1 = require_version20();
    var logger19 = new logger_1.Logger(_version_1.version);
    var geturl_1 = require_browser_geturl();
    function staller(duration) {
      return new Promise(function(resolve) {
        setTimeout(resolve, duration);
      });
    }
    function bodyify(value, type) {
      if (value == null) {
        return null;
      }
      if (typeof value === "string") {
        return value;
      }
      if ((0, bytes_1.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
          try {
            return (0, strings_1.toUtf8String)(value);
          } catch (error) {
          }
          ;
        }
        return (0, bytes_1.hexlify)(value);
      }
      return value;
    }
    function unpercent(value) {
      return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function(all, code2) {
        return String.fromCharCode(parseInt(code2, 16));
      }));
    }
    function _fetchData2(connection, body, processFunc) {
      var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
      logger19.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
      var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
      var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
      logger19.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
      var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
      var headers = {};
      var url = null;
      var options = {
        method: "GET"
      };
      var allow304 = false;
      var timeout = 2 * 60 * 1e3;
      if (typeof connection === "string") {
        url = connection;
      } else if (typeof connection === "object") {
        if (connection == null || connection.url == null) {
          logger19.throwArgumentError("missing URL", "connection.url", connection);
        }
        url = connection.url;
        if (typeof connection.timeout === "number" && connection.timeout > 0) {
          timeout = connection.timeout;
        }
        if (connection.headers) {
          for (var key in connection.headers) {
            headers[key.toLowerCase()] = { key, value: String(connection.headers[key]) };
            if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
              allow304 = true;
            }
          }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
          if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
            logger19.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
          }
          var authorization = connection.user + ":" + connection.password;
          headers["authorization"] = {
            key: "Authorization",
            value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
          };
        }
        if (connection.skipFetchSetup != null) {
          options.skipFetchSetup = !!connection.skipFetchSetup;
        }
        if (connection.fetchOptions != null) {
          options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
        }
      }
      var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
      var dataMatch = url ? url.match(reData) : null;
      if (dataMatch) {
        try {
          var response = {
            statusCode: 200,
            statusMessage: "OK",
            headers: { "content-type": dataMatch[1] || "text/plain" },
            body: dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3])
          };
          var result = response.body;
          if (processFunc) {
            result = processFunc(response.body, response);
          }
          return Promise.resolve(result);
        } catch (error) {
          logger19.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
            body: bodyify(dataMatch[1], dataMatch[2]),
            error,
            requestBody: null,
            requestMethod: "GET",
            url
          });
        }
      }
      if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
          headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
          headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
      }
      var flatHeaders = {};
      Object.keys(headers).forEach(function(key2) {
        var header = headers[key2];
        flatHeaders[header.key] = header.value;
      });
      options.headers = flatHeaders;
      var runningTimeout = function() {
        var timer2 = null;
        var promise = new Promise(function(resolve, reject) {
          if (timeout) {
            timer2 = setTimeout(function() {
              if (timer2 == null) {
                return;
              }
              timer2 = null;
              reject(logger19.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                timeout,
                url
              }));
            }, timeout);
          }
        });
        var cancel = function() {
          if (timer2 == null) {
            return;
          }
          clearTimeout(timer2);
          timer2 = null;
        };
        return { promise, cancel };
      }();
      var runningFetch = function() {
        return __awaiter10(this, void 0, void 0, function() {
          var attempt, response2, location_1, tryAgain, stall3, retryAfter, error_1, body_1, result2, error_2, tryAgain, timeout_1;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                attempt = 0;
                _a2.label = 1;
              case 1:
                if (!(attempt < attemptLimit))
                  return [3, 20];
                response2 = null;
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 9, , 10]);
                return [4, (0, geturl_1.getUrl)(url, options)];
              case 3:
                response2 = _a2.sent();
                if (!(attempt < attemptLimit))
                  return [3, 8];
                if (!(response2.statusCode === 301 || response2.statusCode === 302))
                  return [3, 4];
                location_1 = response2.headers.location || "";
                if (options.method === "GET" && location_1.match(/^https:/)) {
                  url = response2.headers.location;
                  return [3, 19];
                }
                return [3, 8];
              case 4:
                if (!(response2.statusCode === 429))
                  return [3, 8];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 6];
                return [4, throttleCallback(attempt, url)];
              case 5:
                tryAgain = _a2.sent();
                _a2.label = 6;
              case 6:
                if (!tryAgain)
                  return [3, 8];
                stall3 = 0;
                retryAfter = response2.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                return [4, staller(stall3)];
              case 7:
                _a2.sent();
                return [3, 19];
              case 8:
                return [3, 10];
              case 9:
                error_1 = _a2.sent();
                response2 = error_1.response;
                if (response2 == null) {
                  runningTimeout.cancel();
                  logger19.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    serverError: error_1,
                    url
                  });
                }
                return [3, 10];
              case 10:
                body_1 = response2.body;
                if (allow304 && response2.statusCode === 304) {
                  body_1 = null;
                } else if (!errorPassThrough && (response2.statusCode < 200 || response2.statusCode >= 300)) {
                  runningTimeout.cancel();
                  logger19.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                    status: response2.statusCode,
                    headers: response2.headers,
                    body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    url
                  });
                }
                if (!processFunc)
                  return [3, 18];
                _a2.label = 11;
              case 11:
                _a2.trys.push([11, 13, , 18]);
                return [4, processFunc(body_1, response2)];
              case 12:
                result2 = _a2.sent();
                runningTimeout.cancel();
                return [2, result2];
              case 13:
                error_2 = _a2.sent();
                if (!(error_2.throttleRetry && attempt < attemptLimit))
                  return [3, 17];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 15];
                return [4, throttleCallback(attempt, url)];
              case 14:
                tryAgain = _a2.sent();
                _a2.label = 15;
              case 15:
                if (!tryAgain)
                  return [3, 17];
                timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                return [4, staller(timeout_1)];
              case 16:
                _a2.sent();
                return [3, 19];
              case 17:
                runningTimeout.cancel();
                logger19.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                  body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                  error: error_2,
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url
                });
                return [3, 18];
              case 18:
                runningTimeout.cancel();
                return [2, body_1];
              case 19:
                attempt++;
                return [3, 1];
              case 20:
                return [2, logger19.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url
                })];
            }
          });
        });
      }();
      return Promise.race([runningTimeout.promise, runningFetch]);
    }
    exports._fetchData = _fetchData2;
    function fetchJson6(connection, json, processFunc) {
      var processJsonFunc = function(value, response) {
        var result = null;
        if (value != null) {
          try {
            result = JSON.parse((0, strings_1.toUtf8String)(value));
          } catch (error) {
            logger19.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
              body: value,
              error
            });
          }
        }
        if (processFunc) {
          result = processFunc(result, response);
        }
        return result;
      };
      var body = null;
      if (json != null) {
        body = (0, strings_1.toUtf8Bytes)(json);
        var updated = typeof connection === "string" ? { url: connection } : (0, properties_1.shallowCopy)(connection);
        if (updated.headers) {
          var hasContentType = Object.keys(updated.headers).filter(function(k8) {
            return k8.toLowerCase() === "content-type";
          }).length !== 0;
          if (!hasContentType) {
            updated.headers = (0, properties_1.shallowCopy)(updated.headers);
            updated.headers["content-type"] = "application/json";
          }
        } else {
          updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
      }
      return _fetchData2(connection, body, processJsonFunc);
    }
    exports.fetchJson = fetchJson6;
    function poll5(func, options) {
      if (!options) {
        options = {};
      }
      options = (0, properties_1.shallowCopy)(options);
      if (options.floor == null) {
        options.floor = 0;
      }
      if (options.ceiling == null) {
        options.ceiling = 1e4;
      }
      if (options.interval == null) {
        options.interval = 250;
      }
      return new Promise(function(resolve, reject) {
        var timer2 = null;
        var done = false;
        var cancel = function() {
          if (done) {
            return false;
          }
          done = true;
          if (timer2) {
            clearTimeout(timer2);
          }
          return true;
        };
        if (options.timeout) {
          timer2 = setTimeout(function() {
            if (cancel()) {
              reject(new Error("timeout"));
            }
          }, options.timeout);
        }
        var retryLimit = options.retryLimit;
        var attempt = 0;
        function check() {
          return func().then(function(result) {
            if (result !== void 0) {
              if (cancel()) {
                resolve(result);
              }
            } else if (options.oncePoll) {
              options.oncePoll.once("poll", check);
            } else if (options.onceBlock) {
              options.onceBlock.once("block", check);
            } else if (!done) {
              attempt++;
              if (attempt > retryLimit) {
                if (cancel()) {
                  reject(new Error("retry limit reached"));
                }
                return;
              }
              var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              if (timeout < options.floor) {
                timeout = options.floor;
              }
              if (timeout > options.ceiling) {
                timeout = options.ceiling;
              }
              setTimeout(check, timeout);
            }
            return null;
          }, function(error) {
            if (cancel()) {
              reject(error);
            }
          });
        }
        check();
      });
    }
    exports.poll = poll5;
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z8 = 0; z8 < ALPHABET.length; z8++) {
      x8 = ALPHABET.charAt(z8);
      if (ALPHABET_MAP[x8] !== void 0)
        throw new TypeError(x8 + " is ambiguous");
      ALPHABET_MAP[x8] = z8;
    }
    var x8;
    var z8;
    function polymodStep(pre) {
      var b10 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b10 >> 0 & 1) & 996825010 ^ -(b10 >> 1 & 1) & 642813549 ^ -(b10 >> 2 & 1) & 513874426 ^ -(b10 >> 3 & 1) & 1027748829 ^ -(b10 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i10 = 0; i10 < prefix.length; ++i10) {
        var c8 = prefix.charCodeAt(i10);
        if (c8 < 33 || c8 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c8 >> 5;
      }
      chk = polymodStep(chk);
      for (i10 = 0; i10 < prefix.length; ++i10) {
        var v7 = prefix.charCodeAt(i10);
        chk = polymodStep(chk) ^ v7 & 31;
      }
      return chk;
    }
    function encode5(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i10 = 0; i10 < words.length; ++i10) {
        var x9 = words[i10];
        if (x9 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x9;
        result += ALPHABET.charAt(x9);
      }
      for (i10 = 0; i10 < 6; ++i10) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i10 = 0; i10 < 6; ++i10) {
        var v7 = chk >> (5 - i10) * 5 & 31;
        result += ALPHABET.charAt(v7);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words = [];
      for (var i10 = 0; i10 < wordChars.length; ++i10) {
        var c8 = wordChars.charAt(i10);
        var v7 = ALPHABET_MAP[c8];
        if (v7 === void 0)
          return "Unknown character " + c8;
        chk = polymodStep(chk) ^ v7;
        if (i10 + 6 >= wordChars.length)
          continue;
        words.push(v7);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode6(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data2, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i10 = 0; i10 < data2.length; ++i10) {
        value = value << inBits | data2[i10];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode: decode6,
      encode: encode5,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/solidity/lib/_version.js
var require_version21 = __commonJS({
  "node_modules/@ethersproject/solidity/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "solidity/5.7.0";
  }
});

// node_modules/@ethersproject/solidity/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/@ethersproject/solidity/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = exports.keccak256 = exports.pack = void 0;
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var sha2_1 = require_lib19();
    var strings_1 = require_lib9();
    var regexBytes = new RegExp("^bytes([0-9]+)$");
    var regexNumber = new RegExp("^(u?int)([0-9]*)$");
    var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    var Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
    var logger_1 = require_lib();
    var _version_1 = require_version21();
    var logger19 = new logger_1.Logger(_version_1.version);
    function _pack(type, value, isArray) {
      switch (type) {
        case "address":
          if (isArray) {
            return (0, bytes_1.zeroPad)(value, 32);
          }
          return (0, bytes_1.arrayify)(value);
        case "string":
          return (0, strings_1.toUtf8Bytes)(value);
        case "bytes":
          return (0, bytes_1.arrayify)(value);
        case "bool":
          value = value ? "0x01" : "0x00";
          if (isArray) {
            return (0, bytes_1.zeroPad)(value, 32);
          }
          return (0, bytes_1.arrayify)(value);
      }
      var match = type.match(regexNumber);
      if (match) {
        var size = parseInt(match[2] || "256");
        if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
          logger19.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray) {
          size = 256;
        }
        value = bignumber_1.BigNumber.from(value).toTwos(size);
        return (0, bytes_1.zeroPad)(value, size / 8);
      }
      match = type.match(regexBytes);
      if (match) {
        var size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
          logger19.throwArgumentError("invalid bytes type", "type", type);
        }
        if ((0, bytes_1.arrayify)(value).byteLength !== size) {
          logger19.throwArgumentError("invalid value for " + type, "value", value);
        }
        if (isArray) {
          return (0, bytes_1.arrayify)((value + Zeros).substring(0, 66));
        }
        return value;
      }
      match = type.match(regexArray);
      if (match && Array.isArray(value)) {
        var baseType_1 = match[1];
        var count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
          logger19.throwArgumentError("invalid array length for " + type, "value", value);
        }
        var result_1 = [];
        value.forEach(function(value2) {
          result_1.push(_pack(baseType_1, value2, true));
        });
        return (0, bytes_1.concat)(result_1);
      }
      return logger19.throwArgumentError("invalid type", "type", type);
    }
    function pack(types, values) {
      if (types.length != values.length) {
        logger19.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
      }
      var tight = [];
      types.forEach(function(type, index) {
        tight.push(_pack(type, values[index]));
      });
      return (0, bytes_1.hexlify)((0, bytes_1.concat)(tight));
    }
    exports.pack = pack;
    function keccak2562(types, values) {
      return (0, keccak256_1.keccak256)(pack(types, values));
    }
    exports.keccak256 = keccak2562;
    function sha2565(types, values) {
      return (0, sha2_1.sha256)(pack(types, values));
    }
    exports.sha256 = sha2565;
  }
});

// node_modules/@ethersproject/units/lib/_version.js
var require_version22 = __commonJS({
  "node_modules/@ethersproject/units/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "units/5.7.0";
  }
});

// node_modules/@ethersproject/units/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/@ethersproject/units/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = exports.commify = void 0;
    var bignumber_1 = require_lib3();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger19 = new logger_1.Logger(_version_1.version);
    var names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
    function commify2(value) {
      var comps = String(value).split(".");
      if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
        logger19.throwArgumentError("invalid value", "value", value);
      }
      var whole = comps[0];
      var negative = "";
      if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
      }
      while (whole.substring(0, 1) === "0") {
        whole = whole.substring(1);
      }
      if (whole === "") {
        whole = "0";
      }
      var suffix = "";
      if (comps.length === 2) {
        suffix = "." + (comps[1] || "0");
      }
      while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
        suffix = suffix.substring(0, suffix.length - 1);
      }
      var formatted = [];
      while (whole.length) {
        if (whole.length <= 3) {
          formatted.unshift(whole);
          break;
        } else {
          var index = whole.length - 3;
          formatted.unshift(whole.substring(index));
          whole = whole.substring(0, index);
        }
      }
      return negative + formatted.join(",") + suffix;
    }
    exports.commify = commify2;
    function formatUnits4(value, unitName) {
      if (typeof unitName === "string") {
        var index = names.indexOf(unitName);
        if (index !== -1) {
          unitName = 3 * index;
        }
      }
      return (0, bignumber_1.formatFixed)(value, unitName != null ? unitName : 18);
    }
    exports.formatUnits = formatUnits4;
    function parseUnits2(value, unitName) {
      if (typeof value !== "string") {
        logger19.throwArgumentError("value must be a string", "value", value);
      }
      if (typeof unitName === "string") {
        var index = names.indexOf(unitName);
        if (index !== -1) {
          unitName = 3 * index;
        }
      }
      return (0, bignumber_1.parseFixed)(value, unitName != null ? unitName : 18);
    }
    exports.parseUnits = parseUnits2;
    function formatEther2(wei) {
      return formatUnits4(wei, 18);
    }
    exports.formatEther = formatEther2;
    function parseEther2(ether) {
      return parseUnits2(ether, 18);
    }
    exports.parseEther = parseEther2;
  }
});

// node_modules/ethers/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o11, m11, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      Object.defineProperty(o11, k22, { enumerable: true, get: function() {
        return m11[k8];
      } });
    } : function(o11, m11, k8, k22) {
      if (k22 === void 0)
        k22 = k8;
      o11[k22] = m11[k8];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o11, v7) {
      Object.defineProperty(o11, "default", { enumerable: true, value: v7 });
    } : function(o11, v7) {
      o11["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k8 in mod)
          if (k8 !== "default" && Object.prototype.hasOwnProperty.call(mod, k8))
            __createBinding2(result, mod, k8);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = require_lib13();
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = require_lib7();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base643 = __importStar2(require_lib10());
    exports.base64 = base643;
    var basex_1 = require_lib18();
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = require_lib2();
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = require_lib12();
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = require_lib22();
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = require_lib24();
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = require_lib5();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = require_lib();
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = require_lib19();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = require_lib27();
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = require_lib23();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = require_lib4();
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP2 = __importStar2(require_lib6());
    exports.RLP = RLP2;
    var signing_key_1 = require_lib16();
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = require_lib9();
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = require_lib17();
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = require_lib28();
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = require_lib25();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = require_lib26();
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = require_lib19();
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = require_lib9();
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R5 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R5 && typeof R5.apply === "function" ? R5.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R5 && typeof R5.ownKeys === "function") {
      ReflectOwnKeys = R5.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning2) {
      if (console && console.warn)
        console.warn(warning2);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter7() {
      EventEmitter7.init.call(this);
    }
    module.exports = EventEmitter7;
    module.exports.once = once;
    EventEmitter7.EventEmitter = EventEmitter7;
    EventEmitter7.prototype._events = void 0;
    EventEmitter7.prototype._eventsCount = 0;
    EventEmitter7.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter7, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter7.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter7.prototype.setMaxListeners = function setMaxListeners(n8) {
      if (typeof n8 !== "number" || n8 < 0 || NumberIsNaN(n8)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n8 + ".");
      }
      this._maxListeners = n8;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter7.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter7.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter7.prototype.emit = function emit(type) {
      var args = [];
      for (var i10 = 1; i10 < arguments.length; i10++)
        args.push(arguments[i10]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err.context = er3;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i10 = 0; i10 < len; ++i10)
          ReflectApply(listeners[i10], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m11;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m11 = _getMaxListeners(target);
        if (m11 > 0 && existing.length > m11 && !existing.warned) {
          existing.warned = true;
          var w11 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w11.name = "MaxListenersExceededWarning";
          w11.emitter = target;
          w11.type = type;
          w11.count = existing.length;
          ProcessEmitWarning(w11);
        }
      }
      return target;
    }
    EventEmitter7.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter7.prototype.on = EventEmitter7.prototype.addListener;
    EventEmitter7.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter7.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter7.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter7.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i10, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i10 = list.length - 1; i10 >= 0; i10--) {
          if (list[i10] === listener || list[i10].listener === listener) {
            originalListener = list[i10].listener;
            position = i10;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter7.prototype.off = EventEmitter7.prototype.removeListener;
    EventEmitter7.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i10;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i10 = 0; i10 < keys.length; ++i10) {
          key = keys[i10];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i10 = listeners.length - 1; i10 >= 0; i10--) {
          this.removeListener(type, listeners[i10]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter7.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter7.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter7.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter7.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter7.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n8) {
      var copy = new Array(n8);
      for (var i10 = 0; i10 < n8; ++i10)
        copy[i10] = arr[i10];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i10 = 0; i10 < ret.length; ++i10) {
        ret[i10] = arr[i10].listener || arr[i10];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a9, b10) {
      var ah = a9 >>> 16 & 65535, al = a9 & 65535;
      var bh = b10 >>> 16 & 65535, bl = b10 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add(a9, b10) {
      return a9 + b10 | 0;
    }
    exports.add = add;
    function sub(a9, b10) {
      return a9 - b10 | 0;
    }
    exports.sub = sub;
    function rotl(x8, n8) {
      return x8 << n8 | x8 >>> 32 - n8;
    }
    exports.rotl = rotl;
    function rotr(x8, n8) {
      return x8 << 32 - n8 | x8 >>> n8;
    }
    exports.rotr = rotr;
    function isIntegerShim(n8) {
      return typeof n8 === "number" && isFinite(n8) && Math.floor(n8) === n8;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n8) {
      return exports.isInteger(n8) && (n8 >= -exports.MAX_SAFE_INTEGER && n8 <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo2 = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo2 - (lo2 >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo2 = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo2;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo2 = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo2 - (lo2 >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo2 = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo2;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i10 = bitLength / 8 + offset - 1; i10 >= offset; i10--) {
        result += array[i10] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i10 = offset; i10 < offset + bitLength / 8; i10++) {
        result += array[i10] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i10 = bitLength / 8 + offset - 1; i10 >= offset; i10--) {
        out[i10] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i10 = offset; i10 < offset + bitLength / 8; i10++) {
        out[i10] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i10 = 0; i10 < array.length; i10++) {
        array[i10] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j22 = 2036477234;
      var j32 = 1797285236;
      var j42 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j52 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j62 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j72 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x22 = j22;
      var x32 = j32;
      var x42 = j42;
      var x52 = j52;
      var x62 = j62;
      var x72 = j72;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i10 = 0; i10 < ROUNDS; i10 += 2) {
        x0 = x0 + x42 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x42 ^= x8;
        x42 = x42 >>> 32 - 12 | x42 << 12;
        x1 = x1 + x52 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x52 ^= x9;
        x52 = x52 >>> 32 - 12 | x52 << 12;
        x22 = x22 + x62 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x62 ^= x10;
        x62 = x62 >>> 32 - 12 | x62 << 12;
        x32 = x32 + x72 | 0;
        x15 ^= x32;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x72 ^= x11;
        x72 = x72 >>> 32 - 12 | x72 << 12;
        x22 = x22 + x62 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x62 ^= x10;
        x62 = x62 >>> 32 - 7 | x62 << 7;
        x32 = x32 + x72 | 0;
        x15 ^= x32;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x72 ^= x11;
        x72 = x72 >>> 32 - 7 | x72 << 7;
        x1 = x1 + x52 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x52 ^= x9;
        x52 = x52 >>> 32 - 7 | x52 << 7;
        x0 = x0 + x42 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x42 ^= x8;
        x42 = x42 >>> 32 - 7 | x42 << 7;
        x0 = x0 + x52 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x52 ^= x10;
        x52 = x52 >>> 32 - 12 | x52 << 12;
        x1 = x1 + x62 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x62 ^= x11;
        x62 = x62 >>> 32 - 12 | x62 << 12;
        x22 = x22 + x72 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x72 ^= x8;
        x72 = x72 >>> 32 - 12 | x72 << 12;
        x32 = x32 + x42 | 0;
        x14 ^= x32;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x42 ^= x9;
        x42 = x42 >>> 32 - 12 | x42 << 12;
        x22 = x22 + x72 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x72 ^= x8;
        x72 = x72 >>> 32 - 7 | x72 << 7;
        x32 = x32 + x42 | 0;
        x14 ^= x32;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x42 ^= x9;
        x42 = x42 >>> 32 - 7 | x42 << 7;
        x1 = x1 + x62 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x62 ^= x11;
        x62 = x62 >>> 32 - 7 | x62 << 7;
        x0 = x0 + x52 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x52 ^= x10;
        x52 = x52 >>> 32 - 7 | x52 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x22 + j22 | 0, out, 8);
      binary_1.writeUint32LE(x32 + j32 | 0, out, 12);
      binary_1.writeUint32LE(x42 + j42 | 0, out, 16);
      binary_1.writeUint32LE(x52 + j52 | 0, out, 20);
      binary_1.writeUint32LE(x62 + j62 | 0, out, 24);
      binary_1.writeUint32LE(x72 + j72 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i10 = 0; i10 < src2.length; i10 += 64) {
        core(block, nc, key);
        for (var j8 = i10; j8 < i10 + 64 && j8 < src2.length; j8++) {
          dst[j8] = src2[j8] ^ block[j8 - i10];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports.select = select;
    function lessOrEqual(a9, b10) {
      return (a9 | 0) - (b10 | 0) - 1 >>> 31 & 1;
    }
    exports.lessOrEqual = lessOrEqual;
    function compare2(a9, b10) {
      if (a9.length !== b10.length) {
        return 0;
      }
      var result = 0;
      for (var i10 = 0; i10 < a9.length; i10++) {
        result |= a9[i10] ^ b10[i10];
      }
      return 1 & result - 1 >>> 8;
    }
    exports.compare = compare2;
    function equal(a9, b10) {
      if (a9.length === 0 || b10.length === 0) {
        return false;
      }
      return compare2(a9, b10) !== 0;
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      function() {
        function Poly13052(key) {
          this.digestLength = exports.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key[0] | key[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key[2] | key[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t22 = key[4] | key[5] << 8;
          this._r[2] = (t1 >>> 10 | t22 << 6) & 7939;
          var t32 = key[6] | key[7] << 8;
          this._r[3] = (t22 >>> 7 | t32 << 9) & 8191;
          var t42 = key[8] | key[9] << 8;
          this._r[4] = (t32 >>> 4 | t42 << 12) & 255;
          this._r[5] = t42 >>> 1 & 8190;
          var t52 = key[10] | key[11] << 8;
          this._r[6] = (t42 >>> 14 | t52 << 2) & 8191;
          var t62 = key[12] | key[13] << 8;
          this._r[7] = (t52 >>> 11 | t62 << 5) & 8065;
          var t72 = key[14] | key[15] << 8;
          this._r[8] = (t62 >>> 8 | t72 << 8) & 8191;
          this._r[9] = t72 >>> 5 & 127;
          this._pad[0] = key[16] | key[17] << 8;
          this._pad[1] = key[18] | key[19] << 8;
          this._pad[2] = key[20] | key[21] << 8;
          this._pad[3] = key[22] | key[23] << 8;
          this._pad[4] = key[24] | key[25] << 8;
          this._pad[5] = key[26] | key[27] << 8;
          this._pad[6] = key[28] | key[29] << 8;
          this._pad[7] = key[30] | key[31] << 8;
        }
        Poly13052.prototype._blocks = function(m11, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h42 = this._h[4], h52 = this._h[5], h62 = this._h[6], h72 = this._h[7], h82 = this._h[8], h92 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r22 = this._r[2], r32 = this._r[3], r42 = this._r[4], r52 = this._r[5], r62 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t0 = m11[mpos + 0] | m11[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m11[mpos + 2] | m11[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t22 = m11[mpos + 4] | m11[mpos + 5] << 8;
            h22 += (t1 >>> 10 | t22 << 6) & 8191;
            var t32 = m11[mpos + 6] | m11[mpos + 7] << 8;
            h32 += (t22 >>> 7 | t32 << 9) & 8191;
            var t42 = m11[mpos + 8] | m11[mpos + 9] << 8;
            h42 += (t32 >>> 4 | t42 << 12) & 8191;
            h52 += t42 >>> 1 & 8191;
            var t52 = m11[mpos + 10] | m11[mpos + 11] << 8;
            h62 += (t42 >>> 14 | t52 << 2) & 8191;
            var t62 = m11[mpos + 12] | m11[mpos + 13] << 8;
            h72 += (t52 >>> 11 | t62 << 5) & 8191;
            var t72 = m11[mpos + 14] | m11[mpos + 15] << 8;
            h82 += (t62 >>> 8 | t72 << 8) & 8191;
            h92 += t72 >>> 5 | hibit;
            var c8 = 0;
            var d0 = c8;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h22 * (5 * r8);
            d0 += h32 * (5 * r7);
            d0 += h42 * (5 * r62);
            c8 = d0 >>> 13;
            d0 &= 8191;
            d0 += h52 * (5 * r52);
            d0 += h62 * (5 * r42);
            d0 += h72 * (5 * r32);
            d0 += h82 * (5 * r22);
            d0 += h92 * (5 * r1);
            c8 += d0 >>> 13;
            d0 &= 8191;
            var d1 = c8;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h22 * (5 * r9);
            d1 += h32 * (5 * r8);
            d1 += h42 * (5 * r7);
            c8 = d1 >>> 13;
            d1 &= 8191;
            d1 += h52 * (5 * r62);
            d1 += h62 * (5 * r52);
            d1 += h72 * (5 * r42);
            d1 += h82 * (5 * r32);
            d1 += h92 * (5 * r22);
            c8 += d1 >>> 13;
            d1 &= 8191;
            var d22 = c8;
            d22 += h0 * r22;
            d22 += h1 * r1;
            d22 += h22 * r0;
            d22 += h32 * (5 * r9);
            d22 += h42 * (5 * r8);
            c8 = d22 >>> 13;
            d22 &= 8191;
            d22 += h52 * (5 * r7);
            d22 += h62 * (5 * r62);
            d22 += h72 * (5 * r52);
            d22 += h82 * (5 * r42);
            d22 += h92 * (5 * r32);
            c8 += d22 >>> 13;
            d22 &= 8191;
            var d32 = c8;
            d32 += h0 * r32;
            d32 += h1 * r22;
            d32 += h22 * r1;
            d32 += h32 * r0;
            d32 += h42 * (5 * r9);
            c8 = d32 >>> 13;
            d32 &= 8191;
            d32 += h52 * (5 * r8);
            d32 += h62 * (5 * r7);
            d32 += h72 * (5 * r62);
            d32 += h82 * (5 * r52);
            d32 += h92 * (5 * r42);
            c8 += d32 >>> 13;
            d32 &= 8191;
            var d42 = c8;
            d42 += h0 * r42;
            d42 += h1 * r32;
            d42 += h22 * r22;
            d42 += h32 * r1;
            d42 += h42 * r0;
            c8 = d42 >>> 13;
            d42 &= 8191;
            d42 += h52 * (5 * r9);
            d42 += h62 * (5 * r8);
            d42 += h72 * (5 * r7);
            d42 += h82 * (5 * r62);
            d42 += h92 * (5 * r52);
            c8 += d42 >>> 13;
            d42 &= 8191;
            var d52 = c8;
            d52 += h0 * r52;
            d52 += h1 * r42;
            d52 += h22 * r32;
            d52 += h32 * r22;
            d52 += h42 * r1;
            c8 = d52 >>> 13;
            d52 &= 8191;
            d52 += h52 * r0;
            d52 += h62 * (5 * r9);
            d52 += h72 * (5 * r8);
            d52 += h82 * (5 * r7);
            d52 += h92 * (5 * r62);
            c8 += d52 >>> 13;
            d52 &= 8191;
            var d62 = c8;
            d62 += h0 * r62;
            d62 += h1 * r52;
            d62 += h22 * r42;
            d62 += h32 * r32;
            d62 += h42 * r22;
            c8 = d62 >>> 13;
            d62 &= 8191;
            d62 += h52 * r1;
            d62 += h62 * r0;
            d62 += h72 * (5 * r9);
            d62 += h82 * (5 * r8);
            d62 += h92 * (5 * r7);
            c8 += d62 >>> 13;
            d62 &= 8191;
            var d72 = c8;
            d72 += h0 * r7;
            d72 += h1 * r62;
            d72 += h22 * r52;
            d72 += h32 * r42;
            d72 += h42 * r32;
            c8 = d72 >>> 13;
            d72 &= 8191;
            d72 += h52 * r22;
            d72 += h62 * r1;
            d72 += h72 * r0;
            d72 += h82 * (5 * r9);
            d72 += h92 * (5 * r8);
            c8 += d72 >>> 13;
            d72 &= 8191;
            var d82 = c8;
            d82 += h0 * r8;
            d82 += h1 * r7;
            d82 += h22 * r62;
            d82 += h32 * r52;
            d82 += h42 * r42;
            c8 = d82 >>> 13;
            d82 &= 8191;
            d82 += h52 * r32;
            d82 += h62 * r22;
            d82 += h72 * r1;
            d82 += h82 * r0;
            d82 += h92 * (5 * r9);
            c8 += d82 >>> 13;
            d82 &= 8191;
            var d9 = c8;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h22 * r7;
            d9 += h32 * r62;
            d9 += h42 * r52;
            c8 = d9 >>> 13;
            d9 &= 8191;
            d9 += h52 * r42;
            d9 += h62 * r32;
            d9 += h72 * r22;
            d9 += h82 * r1;
            d9 += h92 * r0;
            c8 += d9 >>> 13;
            d9 &= 8191;
            c8 = (c8 << 2) + c8 | 0;
            c8 = c8 + d0 | 0;
            d0 = c8 & 8191;
            c8 = c8 >>> 13;
            d1 += c8;
            h0 = d0;
            h1 = d1;
            h22 = d22;
            h32 = d32;
            h42 = d42;
            h52 = d52;
            h62 = d62;
            h72 = d72;
            h82 = d82;
            h92 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h22;
          this._h[3] = h32;
          this._h[4] = h42;
          this._h[5] = h52;
          this._h[6] = h62;
          this._h[7] = h72;
          this._h[8] = h82;
          this._h[9] = h92;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g9 = new Uint16Array(10);
          var c8;
          var mask;
          var f7;
          var i10;
          if (this._leftover) {
            i10 = this._leftover;
            this._buffer[i10++] = 1;
            for (; i10 < 16; i10++) {
              this._buffer[i10] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c8 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i10 = 2; i10 < 10; i10++) {
            this._h[i10] += c8;
            c8 = this._h[i10] >>> 13;
            this._h[i10] &= 8191;
          }
          this._h[0] += c8 * 5;
          c8 = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c8;
          c8 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c8;
          g9[0] = this._h[0] + 5;
          c8 = g9[0] >>> 13;
          g9[0] &= 8191;
          for (i10 = 1; i10 < 10; i10++) {
            g9[i10] = this._h[i10] + c8;
            c8 = g9[i10] >>> 13;
            g9[i10] &= 8191;
          }
          g9[9] -= 1 << 13;
          mask = (c8 ^ 1) - 1;
          for (i10 = 0; i10 < 10; i10++) {
            g9[i10] &= mask;
          }
          mask = ~mask;
          for (i10 = 0; i10 < 10; i10++) {
            this._h[i10] = this._h[i10] & mask | g9[i10];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f7 = this._h[0] + this._pad[0];
          this._h[0] = f7 & 65535;
          for (i10 = 1; i10 < 8; i10++) {
            f7 = (this._h[i10] + this._pad[i10] | 0) + (f7 >>> 16) | 0;
            this._h[i10] = f7 & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m11) {
          var mpos = 0;
          var bytes = m11.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i10 = 0; i10 < want; i10++) {
              this._buffer[this._leftover + i10] = m11[mpos + i10];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m11, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i10 = 0; i10 < bytes; i10++) {
              this._buffer[this._leftover + i10] = m11[mpos + i10];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }()
    );
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key, data2) {
      var h11 = new Poly1305(key);
      h11.update(data2);
      var digest2 = h11.digest();
      h11.clean();
      return digest2;
    }
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a9, b10) {
      if (a9.length !== exports.DIGEST_LENGTH || b10.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a9, b10);
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = (
      /** @class */
      function() {
        function ChaCha20Poly13052(key) {
          this.nonceLength = exports.NONCE_LENGTH;
          this.tagLength = exports.TAG_LENGTH;
          if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h11 = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h11.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h11.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h11.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h11.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length2 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length2);
          }
          h11.update(length2);
          binary_1.writeUint64LE(ciphertext.length, length2);
          h11.update(length2);
          var tag = h11.digest();
          for (var i10 = 0; i10 < tag.length; i10++) {
            tagOut[i10] = tag[i10];
          }
          h11.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length2);
        };
        return ChaCha20Poly13052;
      }()
    );
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializableHash(h11) {
      return typeof h11.saveState !== "undefined" && typeof h11.restoreState !== "undefined" && typeof h11.cleanSavedState !== "undefined";
    }
    exports.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_1 = require_hash2();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = (
      /** @class */
      function() {
        function HMAC2(hash, key) {
          this._finished = false;
          this._inner = new hash();
          this._outer = new hash();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key.length > this.blockSize) {
            this._inner.update(key).finish(pad).clean();
          } else {
            pad.set(key);
          }
          for (var i10 = 0; i10 < pad.length; i10++) {
            pad[i10] ^= 54;
          }
          this._inner.update(pad);
          for (var i10 = 0; i10 < pad.length; i10++) {
            pad[i10] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data2) {
          this._inner.update(data2);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }()
    );
    exports.HMAC = HMAC;
    function hmac(hash, key, data2) {
      var h11 = new HMAC(hash, key);
      h11.update(data2);
      var digest2 = h11.digest();
      h11.clean();
      return digest2;
    }
    exports.hmac = hmac;
    exports.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hmac_1 = require_hmac2();
    var wipe_1 = require_wipe();
    var HKDF = (
      /** @class */
      function() {
        function HKDF2(hash, key, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key);
          this._hmac = new hmac_1.HMAC(hash, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF2.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF2.prototype.expand = function(length2) {
          var out = new Uint8Array(length2);
          for (var i10 = 0; i10 < out.length; i10++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i10] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF2.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF2;
      }()
    );
    exports.HKDF = HKDF;
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i10 = 0; i10 < out.length; i10 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i10, i10 + Math.min(out.length - i10, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer = this._crypto.randomBytes(length2);
        if (buffer.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i10 = 0; i10 < out.length; i10++) {
          out[i10] = buffer[i10];
        }
        (0, wipe_1.wipe)(buffer);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes4(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports.randomBytes = randomBytes4;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes4(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes4(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i10 = 0; i10 < buf.length && length2 > 0; i10++) {
          const randomByte = buf[i10];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = (
      /** @class */
      function() {
        function SHA2562() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data2, dataLength) {
          if (dataLength === void 0) {
            dataLength = data2.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i10 = left + 1; i10 < padLength - 8; i10++) {
              this._buffer[i10] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i10 = 0; i10 < this.digestLength / 4; i10++) {
            binary_1.writeUint32BE(this._state[i10], out, i10 * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }()
    );
    exports.SHA256 = SHA256;
    var K6 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w11, v7, p10, pos, len) {
      while (len >= 64) {
        var a9 = v7[0];
        var b10 = v7[1];
        var c8 = v7[2];
        var d9 = v7[3];
        var e11 = v7[4];
        var f7 = v7[5];
        var g9 = v7[6];
        var h11 = v7[7];
        for (var i10 = 0; i10 < 16; i10++) {
          var j8 = pos + i10 * 4;
          w11[i10] = binary_1.readUint32BE(p10, j8);
        }
        for (var i10 = 16; i10 < 64; i10++) {
          var u9 = w11[i10 - 2];
          var t1 = (u9 >>> 17 | u9 << 32 - 17) ^ (u9 >>> 19 | u9 << 32 - 19) ^ u9 >>> 10;
          u9 = w11[i10 - 15];
          var t22 = (u9 >>> 7 | u9 << 32 - 7) ^ (u9 >>> 18 | u9 << 32 - 18) ^ u9 >>> 3;
          w11[i10] = (t1 + w11[i10 - 7] | 0) + (t22 + w11[i10 - 16] | 0);
        }
        for (var i10 = 0; i10 < 64; i10++) {
          var t1 = (((e11 >>> 6 | e11 << 32 - 6) ^ (e11 >>> 11 | e11 << 32 - 11) ^ (e11 >>> 25 | e11 << 32 - 25)) + (e11 & f7 ^ ~e11 & g9) | 0) + (h11 + (K6[i10] + w11[i10] | 0) | 0) | 0;
          var t22 = ((a9 >>> 2 | a9 << 32 - 2) ^ (a9 >>> 13 | a9 << 32 - 13) ^ (a9 >>> 22 | a9 << 32 - 22)) + (a9 & b10 ^ a9 & c8 ^ b10 & c8) | 0;
          h11 = g9;
          g9 = f7;
          f7 = e11;
          e11 = d9 + t1 | 0;
          d9 = c8;
          c8 = b10;
          b10 = a9;
          a9 = t1 + t22 | 0;
        }
        v7[0] += a9;
        v7[1] += b10;
        v7[2] += c8;
        v7[3] += d9;
        v7[4] += e11;
        v7[5] += f7;
        v7[6] += g9;
        v7[7] += h11;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash(data2) {
      var h11 = new SHA256();
      h11.update(data2);
      var digest2 = h11.digest();
      h11.clean();
      return digest2;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r7 = new Float64Array(16);
      if (init) {
        for (let i10 = 0; i10 < init.length; i10++) {
          r7[i10] = init[i10];
        }
      }
      return r7;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o11) {
      let c8 = 1;
      for (let i10 = 0; i10 < 16; i10++) {
        let v7 = o11[i10] + c8 + 65535;
        c8 = Math.floor(v7 / 65536);
        o11[i10] = v7 - c8 * 65536;
      }
      o11[0] += c8 - 1 + 37 * (c8 - 1);
    }
    function sel25519(p10, q8, b10) {
      const c8 = ~(b10 - 1);
      for (let i10 = 0; i10 < 16; i10++) {
        const t8 = c8 & (p10[i10] ^ q8[i10]);
        p10[i10] ^= t8;
        q8[i10] ^= t8;
      }
    }
    function pack25519(o11, n8) {
      const m11 = gf();
      const t8 = gf();
      for (let i10 = 0; i10 < 16; i10++) {
        t8[i10] = n8[i10];
      }
      car25519(t8);
      car25519(t8);
      car25519(t8);
      for (let j8 = 0; j8 < 2; j8++) {
        m11[0] = t8[0] - 65517;
        for (let i10 = 1; i10 < 15; i10++) {
          m11[i10] = t8[i10] - 65535 - (m11[i10 - 1] >> 16 & 1);
          m11[i10 - 1] &= 65535;
        }
        m11[15] = t8[15] - 32767 - (m11[14] >> 16 & 1);
        const b10 = m11[15] >> 16 & 1;
        m11[14] &= 65535;
        sel25519(t8, m11, 1 - b10);
      }
      for (let i10 = 0; i10 < 16; i10++) {
        o11[2 * i10] = t8[i10] & 255;
        o11[2 * i10 + 1] = t8[i10] >> 8;
      }
    }
    function unpack25519(o11, n8) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = n8[2 * i10] + (n8[2 * i10 + 1] << 8);
      }
      o11[15] &= 32767;
    }
    function add(o11, a9, b10) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = a9[i10] + b10[i10];
      }
    }
    function sub(o11, a9, b10) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = a9[i10] - b10[i10];
      }
    }
    function mul(o11, a9, b10) {
      let v7, c8, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b10[0], b1 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8], b92 = b10[9], b102 = b10[10], b11 = b10[11], b12 = b10[12], b13 = b10[13], b14 = b10[14], b15 = b10[15];
      v7 = a9[0];
      t0 += v7 * b0;
      t1 += v7 * b1;
      t22 += v7 * b22;
      t32 += v7 * b32;
      t42 += v7 * b42;
      t52 += v7 * b52;
      t62 += v7 * b62;
      t72 += v7 * b72;
      t8 += v7 * b82;
      t9 += v7 * b92;
      t10 += v7 * b102;
      t11 += v7 * b11;
      t12 += v7 * b12;
      t13 += v7 * b13;
      t14 += v7 * b14;
      t15 += v7 * b15;
      v7 = a9[1];
      t1 += v7 * b0;
      t22 += v7 * b1;
      t32 += v7 * b22;
      t42 += v7 * b32;
      t52 += v7 * b42;
      t62 += v7 * b52;
      t72 += v7 * b62;
      t8 += v7 * b72;
      t9 += v7 * b82;
      t10 += v7 * b92;
      t11 += v7 * b102;
      t12 += v7 * b11;
      t13 += v7 * b12;
      t14 += v7 * b13;
      t15 += v7 * b14;
      t16 += v7 * b15;
      v7 = a9[2];
      t22 += v7 * b0;
      t32 += v7 * b1;
      t42 += v7 * b22;
      t52 += v7 * b32;
      t62 += v7 * b42;
      t72 += v7 * b52;
      t8 += v7 * b62;
      t9 += v7 * b72;
      t10 += v7 * b82;
      t11 += v7 * b92;
      t12 += v7 * b102;
      t13 += v7 * b11;
      t14 += v7 * b12;
      t15 += v7 * b13;
      t16 += v7 * b14;
      t17 += v7 * b15;
      v7 = a9[3];
      t32 += v7 * b0;
      t42 += v7 * b1;
      t52 += v7 * b22;
      t62 += v7 * b32;
      t72 += v7 * b42;
      t8 += v7 * b52;
      t9 += v7 * b62;
      t10 += v7 * b72;
      t11 += v7 * b82;
      t12 += v7 * b92;
      t13 += v7 * b102;
      t14 += v7 * b11;
      t15 += v7 * b12;
      t16 += v7 * b13;
      t17 += v7 * b14;
      t18 += v7 * b15;
      v7 = a9[4];
      t42 += v7 * b0;
      t52 += v7 * b1;
      t62 += v7 * b22;
      t72 += v7 * b32;
      t8 += v7 * b42;
      t9 += v7 * b52;
      t10 += v7 * b62;
      t11 += v7 * b72;
      t12 += v7 * b82;
      t13 += v7 * b92;
      t14 += v7 * b102;
      t15 += v7 * b11;
      t16 += v7 * b12;
      t17 += v7 * b13;
      t18 += v7 * b14;
      t19 += v7 * b15;
      v7 = a9[5];
      t52 += v7 * b0;
      t62 += v7 * b1;
      t72 += v7 * b22;
      t8 += v7 * b32;
      t9 += v7 * b42;
      t10 += v7 * b52;
      t11 += v7 * b62;
      t12 += v7 * b72;
      t13 += v7 * b82;
      t14 += v7 * b92;
      t15 += v7 * b102;
      t16 += v7 * b11;
      t17 += v7 * b12;
      t18 += v7 * b13;
      t19 += v7 * b14;
      t20 += v7 * b15;
      v7 = a9[6];
      t62 += v7 * b0;
      t72 += v7 * b1;
      t8 += v7 * b22;
      t9 += v7 * b32;
      t10 += v7 * b42;
      t11 += v7 * b52;
      t12 += v7 * b62;
      t13 += v7 * b72;
      t14 += v7 * b82;
      t15 += v7 * b92;
      t16 += v7 * b102;
      t17 += v7 * b11;
      t18 += v7 * b12;
      t19 += v7 * b13;
      t20 += v7 * b14;
      t21 += v7 * b15;
      v7 = a9[7];
      t72 += v7 * b0;
      t8 += v7 * b1;
      t9 += v7 * b22;
      t10 += v7 * b32;
      t11 += v7 * b42;
      t12 += v7 * b52;
      t13 += v7 * b62;
      t14 += v7 * b72;
      t15 += v7 * b82;
      t16 += v7 * b92;
      t17 += v7 * b102;
      t18 += v7 * b11;
      t19 += v7 * b12;
      t20 += v7 * b13;
      t21 += v7 * b14;
      t222 += v7 * b15;
      v7 = a9[8];
      t8 += v7 * b0;
      t9 += v7 * b1;
      t10 += v7 * b22;
      t11 += v7 * b32;
      t12 += v7 * b42;
      t13 += v7 * b52;
      t14 += v7 * b62;
      t15 += v7 * b72;
      t16 += v7 * b82;
      t17 += v7 * b92;
      t18 += v7 * b102;
      t19 += v7 * b11;
      t20 += v7 * b12;
      t21 += v7 * b13;
      t222 += v7 * b14;
      t23 += v7 * b15;
      v7 = a9[9];
      t9 += v7 * b0;
      t10 += v7 * b1;
      t11 += v7 * b22;
      t12 += v7 * b32;
      t13 += v7 * b42;
      t14 += v7 * b52;
      t15 += v7 * b62;
      t16 += v7 * b72;
      t17 += v7 * b82;
      t18 += v7 * b92;
      t19 += v7 * b102;
      t20 += v7 * b11;
      t21 += v7 * b12;
      t222 += v7 * b13;
      t23 += v7 * b14;
      t24 += v7 * b15;
      v7 = a9[10];
      t10 += v7 * b0;
      t11 += v7 * b1;
      t12 += v7 * b22;
      t13 += v7 * b32;
      t14 += v7 * b42;
      t15 += v7 * b52;
      t16 += v7 * b62;
      t17 += v7 * b72;
      t18 += v7 * b82;
      t19 += v7 * b92;
      t20 += v7 * b102;
      t21 += v7 * b11;
      t222 += v7 * b12;
      t23 += v7 * b13;
      t24 += v7 * b14;
      t25 += v7 * b15;
      v7 = a9[11];
      t11 += v7 * b0;
      t12 += v7 * b1;
      t13 += v7 * b22;
      t14 += v7 * b32;
      t15 += v7 * b42;
      t16 += v7 * b52;
      t17 += v7 * b62;
      t18 += v7 * b72;
      t19 += v7 * b82;
      t20 += v7 * b92;
      t21 += v7 * b102;
      t222 += v7 * b11;
      t23 += v7 * b12;
      t24 += v7 * b13;
      t25 += v7 * b14;
      t26 += v7 * b15;
      v7 = a9[12];
      t12 += v7 * b0;
      t13 += v7 * b1;
      t14 += v7 * b22;
      t15 += v7 * b32;
      t16 += v7 * b42;
      t17 += v7 * b52;
      t18 += v7 * b62;
      t19 += v7 * b72;
      t20 += v7 * b82;
      t21 += v7 * b92;
      t222 += v7 * b102;
      t23 += v7 * b11;
      t24 += v7 * b12;
      t25 += v7 * b13;
      t26 += v7 * b14;
      t27 += v7 * b15;
      v7 = a9[13];
      t13 += v7 * b0;
      t14 += v7 * b1;
      t15 += v7 * b22;
      t16 += v7 * b32;
      t17 += v7 * b42;
      t18 += v7 * b52;
      t19 += v7 * b62;
      t20 += v7 * b72;
      t21 += v7 * b82;
      t222 += v7 * b92;
      t23 += v7 * b102;
      t24 += v7 * b11;
      t25 += v7 * b12;
      t26 += v7 * b13;
      t27 += v7 * b14;
      t28 += v7 * b15;
      v7 = a9[14];
      t14 += v7 * b0;
      t15 += v7 * b1;
      t16 += v7 * b22;
      t17 += v7 * b32;
      t18 += v7 * b42;
      t19 += v7 * b52;
      t20 += v7 * b62;
      t21 += v7 * b72;
      t222 += v7 * b82;
      t23 += v7 * b92;
      t24 += v7 * b102;
      t25 += v7 * b11;
      t26 += v7 * b12;
      t27 += v7 * b13;
      t28 += v7 * b14;
      t29 += v7 * b15;
      v7 = a9[15];
      t15 += v7 * b0;
      t16 += v7 * b1;
      t17 += v7 * b22;
      t18 += v7 * b32;
      t19 += v7 * b42;
      t20 += v7 * b52;
      t21 += v7 * b62;
      t222 += v7 * b72;
      t23 += v7 * b82;
      t24 += v7 * b92;
      t25 += v7 * b102;
      t26 += v7 * b11;
      t27 += v7 * b12;
      t28 += v7 * b13;
      t29 += v7 * b14;
      t30 += v7 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t22 += 38 * t18;
      t32 += 38 * t19;
      t42 += 38 * t20;
      t52 += 38 * t21;
      t62 += 38 * t222;
      t72 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c8 = 1;
      v7 = t0 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t0 = v7 - c8 * 65536;
      v7 = t1 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t1 = v7 - c8 * 65536;
      v7 = t22 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t22 = v7 - c8 * 65536;
      v7 = t32 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t32 = v7 - c8 * 65536;
      v7 = t42 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t42 = v7 - c8 * 65536;
      v7 = t52 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t52 = v7 - c8 * 65536;
      v7 = t62 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t62 = v7 - c8 * 65536;
      v7 = t72 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t72 = v7 - c8 * 65536;
      v7 = t8 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t8 = v7 - c8 * 65536;
      v7 = t9 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t9 = v7 - c8 * 65536;
      v7 = t10 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t10 = v7 - c8 * 65536;
      v7 = t11 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t11 = v7 - c8 * 65536;
      v7 = t12 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t12 = v7 - c8 * 65536;
      v7 = t13 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t13 = v7 - c8 * 65536;
      v7 = t14 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t14 = v7 - c8 * 65536;
      v7 = t15 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t15 = v7 - c8 * 65536;
      t0 += c8 - 1 + 37 * (c8 - 1);
      c8 = 1;
      v7 = t0 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t0 = v7 - c8 * 65536;
      v7 = t1 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t1 = v7 - c8 * 65536;
      v7 = t22 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t22 = v7 - c8 * 65536;
      v7 = t32 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t32 = v7 - c8 * 65536;
      v7 = t42 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t42 = v7 - c8 * 65536;
      v7 = t52 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t52 = v7 - c8 * 65536;
      v7 = t62 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t62 = v7 - c8 * 65536;
      v7 = t72 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t72 = v7 - c8 * 65536;
      v7 = t8 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t8 = v7 - c8 * 65536;
      v7 = t9 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t9 = v7 - c8 * 65536;
      v7 = t10 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t10 = v7 - c8 * 65536;
      v7 = t11 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t11 = v7 - c8 * 65536;
      v7 = t12 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t12 = v7 - c8 * 65536;
      v7 = t13 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t13 = v7 - c8 * 65536;
      v7 = t14 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t14 = v7 - c8 * 65536;
      v7 = t15 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t15 = v7 - c8 * 65536;
      t0 += c8 - 1 + 37 * (c8 - 1);
      o11[0] = t0;
      o11[1] = t1;
      o11[2] = t22;
      o11[3] = t32;
      o11[4] = t42;
      o11[5] = t52;
      o11[6] = t62;
      o11[7] = t72;
      o11[8] = t8;
      o11[9] = t9;
      o11[10] = t10;
      o11[11] = t11;
      o11[12] = t12;
      o11[13] = t13;
      o11[14] = t14;
      o11[15] = t15;
    }
    function square(o11, a9) {
      mul(o11, a9, a9);
    }
    function inv25519(o11, inp) {
      const c8 = gf();
      for (let i10 = 0; i10 < 16; i10++) {
        c8[i10] = inp[i10];
      }
      for (let i10 = 253; i10 >= 0; i10--) {
        square(c8, c8);
        if (i10 !== 2 && i10 !== 4) {
          mul(c8, c8, inp);
        }
      }
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = c8[i10];
      }
    }
    function scalarMult(n8, p10) {
      const z8 = new Uint8Array(32);
      const x8 = new Float64Array(80);
      const a9 = gf(), b10 = gf(), c8 = gf(), d9 = gf(), e11 = gf(), f7 = gf();
      for (let i10 = 0; i10 < 31; i10++) {
        z8[i10] = n8[i10];
      }
      z8[31] = n8[31] & 127 | 64;
      z8[0] &= 248;
      unpack25519(x8, p10);
      for (let i10 = 0; i10 < 16; i10++) {
        b10[i10] = x8[i10];
      }
      a9[0] = d9[0] = 1;
      for (let i10 = 254; i10 >= 0; --i10) {
        const r7 = z8[i10 >>> 3] >>> (i10 & 7) & 1;
        sel25519(a9, b10, r7);
        sel25519(c8, d9, r7);
        add(e11, a9, c8);
        sub(a9, a9, c8);
        add(c8, b10, d9);
        sub(b10, b10, d9);
        square(d9, e11);
        square(f7, a9);
        mul(a9, c8, a9);
        mul(c8, b10, e11);
        add(e11, a9, c8);
        sub(a9, a9, c8);
        square(b10, a9);
        sub(c8, d9, f7);
        mul(a9, c8, _121665);
        add(a9, a9, d9);
        mul(c8, c8, a9);
        mul(a9, d9, f7);
        mul(d9, b10, x8);
        square(b10, e11);
        sel25519(a9, b10, r7);
        sel25519(c8, d9, r7);
      }
      for (let i10 = 0; i10 < 16; i10++) {
        x8[i10 + 16] = a9[i10];
        x8[i10 + 32] = c8[i10];
        x8[i10 + 48] = b10[i10];
        x8[i10 + 64] = d9[i10];
      }
      const x32 = x8.subarray(32);
      const x16 = x8.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q8 = new Uint8Array(32);
      pack25519(q8, x16);
      return q8;
    }
    exports.scalarMult = scalarMult;
    function scalarMultBase(n8) {
      return scalarMult(n8, _9);
    }
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i10 = 0; i10 < result.length; i10++) {
          zeros |= result[i10];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports.sharedKey = sharedKey2;
  }
});

// node_modules/uint8arrays/esm/src/compare.js
var init_compare = __esm({
  "node_modules/uint8arrays/esm/src/compare.js"() {
  }
});

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
var init_as_uint8array = __esm({
  "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
  }
});

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/concat.js
function concat4(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/equals.js
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
  }
});

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j8 = 0; j8 < BASE_MAP.length; j8++) {
    BASE_MAP[j8] = 255;
  }
  for (var i10 = 0; i10 < ALPHABET.length; i10++) {
    var x8 = ALPHABET.charAt(i10);
    var xc = x8.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x8 + " is ambiguous");
    }
    BASE_MAP[xc] = i10;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode5(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i11 = 0;
      for (var it1 = size - 1; (carry !== 0 || i11 < length2) && it1 !== -1; it1--, i11++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i11;
      pbegin++;
    }
    var it22 = size - length2;
    while (it22 !== size && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size; ++it22) {
      str += ALPHABET.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i11 = 0;
      for (var it32 = size - 1; (carry !== 0 || i11 < length2) && it32 !== -1; it32--, i11++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i11;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j9 = zeroes;
    while (it4 !== size) {
      vch[j9++] = b256[it4++];
    }
    return vch;
  }
  function decode6(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode5,
    decodeUnsafe,
    decode: decode6
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = (aa2, bb) => {
      if (aa2 === bb)
        return true;
      if (aa2.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa2.byteLength; ii++) {
        if (aa2[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o11) => {
      if (o11 instanceof Uint8Array && o11.constructor.name === "Uint8Array")
        return o11;
      if (o11 instanceof ArrayBuffer)
        return new Uint8Array(o11);
      if (ArrayBuffer.isView(o11)) {
        return new Uint8Array(o11.buffer, o11.byteOffset, o11.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b10) => new TextDecoder().decode(b10);
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
var init_base = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);
    baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
      const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);
      return from({
        prefix,
        name: name2,
        encode: encode5,
        decode: (text) => coerce(decode6(text))
      });
    };
    decode = (string2, alphabet2, bitsPerChar, name2) => {
      const codes = {};
      for (let i10 = 0; i10 < alphabet2.length; ++i10) {
        codes[alphabet2[i10]] = i10;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i10 = 0; i10 < end; ++i10) {
        const value = codes[string2[i10]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode = (data2, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i10 = 0; i10 < data2.length; ++i10) {
        buffer = buffer << 8 | data2[i10];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode(input, alphabet2, bitsPerChar, name2);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString(buf),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base642,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base642, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base642 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode2(data2) {
  return data2.reduce((p10, c8) => {
    p10 += alphabetBytesToChars[c8];
    return p10;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p10, c8, i10) => {
      p10[i10] = c8;
      return p10;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p10, c8, i10) => {
      p10[c8.codePointAt(0)] = i10;
      return p10;
    }, []);
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode2,
      decode: decode2
    });
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b10, l9 = buf.length;
  do {
    if (counter >= l9) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b10 = buf[counter++];
    res += shift < 28 ? (b10 & REST$1) << shift : (b10 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b10 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var decode4, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode4 = (data2, offset = 0) => {
      const code2 = varint_default.decode(data2, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var create, decode5, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code2, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code2, size, digest2, bytes);
    };
    decode5 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode4(bytes);
      const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest2, bytes);
    };
    equals2 = (a9, b10) => {
      if (a9 === b10) {
        return true;
      } else {
        return a9.code === b10.code && a9.size === b10.size && equals(a9.bytes, b10.bytes);
      }
    };
    Digest = class {
      constructor(code2, size, digest2, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);
    Hasher = class {
      constructor(name2, code2, encode5) {
        this.name = name2;
        this.code = code2;
        this.encode = encode5;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2563,
  sha512: () => sha5122
});
var sha, sha2563, sha5122;
var init_sha2_browser = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha = (name2) => async (data2) => new Uint8Array(await crypto.subtle.digest(name2, data2));
    sha2563 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha5122 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode4, digest, identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode4 = coerce;
    digest = (input) => create(code, encode4(input));
    identity2 = {
      code,
      name,
      encode: encode4,
      digest
    };
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder, textDecoder;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});

// node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version5, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class {
      constructor(version6, code2, multihash, bytes) {
        this.code = code2;
        this.version = version6;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes, version: version6, _baseCache } = this;
        switch (version6) {
          case 0:
            return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version6, code: code2, multihash, bytes } = value;
          return new CID(version6, code2, multihash, bytes || encodeCID(version6, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version6, multihash, code: code2 } = value;
          const digest2 = decode5(multihash);
          return CID.create(version6, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version6, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version6) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version6, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version6, code2, digest2.bytes);
            return new CID(version6, code2, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return CID.create(1, code2, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i10, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i10;
        };
        let version6 = next();
        let codec = DAG_PB_CODE;
        if (version6 === 18) {
          version6 = 0;
          offset = 0;
        } else if (version6 === 1) {
          codec = next();
        }
        if (version6 !== 0 && version6 !== 1) {
          throw new RangeError(`Invalid CID version ${version6}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version6,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes] = parseCIDtoBytes(source, base3);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base3 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version6, code2, multihash) => {
      const codeOffset = encodingLength(version6);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version6, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version5 = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version5)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/basics.js
var bases, hashes;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode5, decode6) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode6 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i10 = 0; i10 < buf.length; i10++) {
        string2 += String.fromCharCode(buf[i10]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = allocUnsafe(str.length);
      for (let i10 = 0; i10 < str.length; i10++) {
        buf[i10] = str.charCodeAt(i10);
      }
      return buf;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
  }
});

// node_modules/uint8arrays/esm/src/xor.js
var init_xor = __esm({
  "node_modules/uint8arrays/esm/src/xor.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/index.js
var init_src2 = __esm({
  "node_modules/uint8arrays/esm/src/index.js"() {
    init_compare();
    init_concat();
    init_equals();
    init_from_string();
    init_to_string();
    init_xor();
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version6 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version6, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version6, os2);
}
function detectOS(ua2) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a2 = operatingSystemRules[ii], os2 = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArray, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    __spreadArray = function(to2, from3, pack) {
      if (pack || arguments.length === 2)
        for (var i10 = 0, l9 = from3.length, ar3; i10 < l9; i10++) {
          if (ar3 || !(i10 in from3)) {
            if (!ar3)
              ar3 = Array.prototype.slice.call(from3, 0, i10);
            ar3[i10] = from3[i10];
          }
        }
      return to2.concat(ar3 || Array.prototype.slice.call(from3));
    };
    BrowserInfo = /** @class */
    function() {
      function BrowserInfo2(name2, version6, os2) {
        this.name = name2;
        this.version = version6;
        this.os = os2;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = /** @class */
    function() {
      function NodeInfo2(version6) {
        this.version = version6;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = /** @class */
    function() {
      function SearchBotDeviceInfo2(name2, version6, os2, bot) {
        this.name = name2;
        this.version = version6;
        this.os = os2;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = /** @class */
    function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = /** @class */
    function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
      ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
      ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FB[AS]V\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["curl", /^curl\/([0-9\.]+)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter9,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d9, b10) {
  extendStatics(d9, b10);
  function __() {
    this.constructor = d9;
  }
  d9.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __rest(s11, e11) {
  var t8 = {};
  for (var p10 in s11)
    if (Object.prototype.hasOwnProperty.call(s11, p10) && e11.indexOf(p10) < 0)
      t8[p10] = s11[p10];
  if (s11 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p10 = Object.getOwnPropertySymbols(s11); i10 < p10.length; i10++) {
      if (e11.indexOf(p10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s11, p10[i10]))
        t8[p10[i10]] = s11[p10[i10]];
    }
  return t8;
}
function __decorate(decorators, target, key, desc) {
  var c8 = arguments.length, r7 = c8 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d9;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r7 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d9 = decorators[i10])
        r7 = (c8 < 3 ? d9(r7) : c8 > 3 ? d9(target, key, r7) : d9(target, key)) || r7;
  return c8 > 3 && r7 && Object.defineProperty(target, key, r7), r7;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter9(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _8 = { label: 0, sent: function() {
    if (t8[0] & 1)
      throw t8[1];
    return t8[1];
  }, trys: [], ops: [] }, f7, y10, t8, g9;
  return g9 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g9[Symbol.iterator] = function() {
    return this;
  }), g9;
  function verb(n8) {
    return function(v7) {
      return step([n8, v7]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_8)
      try {
        if (f7 = 1, y10 && (t8 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t8 = y10["return"]) && t8.call(y10), 0) : y10.next) && !(t8 = t8.call(y10, op[1])).done)
          return t8;
        if (y10 = 0, t8)
          op = [op[0] & 2, t8.value];
        switch (op[0]) {
          case 0:
          case 1:
            t8 = op;
            break;
          case 4:
            _8.label++;
            return { value: op[1], done: false };
          case 5:
            _8.label++;
            y10 = op[1];
            op = [0];
            continue;
          case 7:
            op = _8.ops.pop();
            _8.trys.pop();
            continue;
          default:
            if (!(t8 = _8.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _8 = 0;
              continue;
            }
            if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
              _8.label = op[1];
              break;
            }
            if (op[0] === 6 && _8.label < t8[1]) {
              _8.label = t8[1];
              t8 = op;
              break;
            }
            if (t8 && _8.label < t8[2]) {
              _8.label = t8[2];
              _8.ops.push(op);
              break;
            }
            if (t8[2])
              _8.ops.pop();
            _8.trys.pop();
            continue;
        }
        op = body.call(thisArg, _8);
      } catch (e11) {
        op = [6, e11];
        y10 = 0;
      } finally {
        f7 = t8 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o11, m11, k8, k22) {
  if (k22 === void 0)
    k22 = k8;
  o11[k22] = m11[k8];
}
function __exportStar(m11, exports) {
  for (var p10 in m11)
    if (p10 !== "default" && !exports.hasOwnProperty(p10))
      exports[p10] = m11[p10];
}
function __values(o11) {
  var s11 = typeof Symbol === "function" && Symbol.iterator, m11 = s11 && o11[s11], i10 = 0;
  if (m11)
    return m11.call(o11);
  if (o11 && typeof o11.length === "number")
    return {
      next: function() {
        if (o11 && i10 >= o11.length)
          o11 = void 0;
        return { value: o11 && o11[i10++], done: !o11 };
      }
    };
  throw new TypeError(s11 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o11, n8) {
  var m11 = typeof Symbol === "function" && o11[Symbol.iterator];
  if (!m11)
    return o11;
  var i10 = m11.call(o11), r7, ar3 = [], e11;
  try {
    while ((n8 === void 0 || n8-- > 0) && !(r7 = i10.next()).done)
      ar3.push(r7.value);
  } catch (error) {
    e11 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m11 = i10["return"]))
        m11.call(i10);
    } finally {
      if (e11)
        throw e11.error;
    }
  }
  return ar3;
}
function __spread() {
  for (var ar3 = [], i10 = 0; i10 < arguments.length; i10++)
    ar3 = ar3.concat(__read(arguments[i10]));
  return ar3;
}
function __spreadArrays() {
  for (var s11 = 0, i10 = 0, il = arguments.length; i10 < il; i10++)
    s11 += arguments[i10].length;
  for (var r7 = Array(s11), k8 = 0, i10 = 0; i10 < il; i10++)
    for (var a9 = arguments[i10], j8 = 0, jl = a9.length; j8 < jl; j8++, k8++)
      r7[k8] = a9[j8];
  return r7;
}
function __await(v7) {
  return this instanceof __await ? (this.v = v7, this) : new __await(v7);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g9 = generator.apply(thisArg, _arguments || []), i10, q8 = [];
  return i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10;
  function verb(n8) {
    if (g9[n8])
      i10[n8] = function(v7) {
        return new Promise(function(a9, b10) {
          q8.push([n8, v7, a9, b10]) > 1 || resume(n8, v7);
        });
      };
  }
  function resume(n8, v7) {
    try {
      step(g9[n8](v7));
    } catch (e11) {
      settle(q8[0][3], e11);
    }
  }
  function step(r7) {
    r7.value instanceof __await ? Promise.resolve(r7.value.v).then(fulfill, reject) : settle(q8[0][2], r7);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f7, v7) {
    if (f7(v7), q8.shift(), q8.length)
      resume(q8[0][0], q8[0][1]);
  }
}
function __asyncDelegator(o11) {
  var i10, p10;
  return i10 = {}, verb("next"), verb("throw", function(e11) {
    throw e11;
  }), verb("return"), i10[Symbol.iterator] = function() {
    return this;
  }, i10;
  function verb(n8, f7) {
    i10[n8] = o11[n8] ? function(v7) {
      return (p10 = !p10) ? { value: __await(o11[n8](v7)), done: n8 === "return" } : f7 ? f7(v7) : v7;
    } : f7;
  }
}
function __asyncValues(o11) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m11 = o11[Symbol.asyncIterator], i10;
  return m11 ? m11.call(o11) : (o11 = typeof __values === "function" ? __values(o11) : o11[Symbol.iterator](), i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10);
  function verb(n8) {
    i10[n8] = o11[n8] && function(v7) {
      return new Promise(function(resolve, reject) {
        v7 = o11[n8](v7), settle(resolve, reject, v7.done, v7.value);
      });
    };
  }
  function settle(resolve, reject, d9, v7) {
    Promise.resolve(v7).then(function(v8) {
      resolve({ value: v8, done: d9 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k8 in mod)
      if (Object.hasOwnProperty.call(mod, k8))
        result[k8] = mod[k8];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d9, b10) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d10, b11) {
        d10.__proto__ = b11;
      } || function(d10, b11) {
        for (var p10 in b11)
          if (b11.hasOwnProperty(p10))
            d10[p10] = b11[p10];
      };
      return extendStatics(d9, b10);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t8) {
        for (var s11, i10 = 1, n8 = arguments.length; i10 < n8; i10++) {
          s11 = arguments[i10];
          for (var p10 in s11)
            if (Object.prototype.hasOwnProperty.call(s11, p10))
              t8[p10] = s11[p10];
        }
        return t8;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports.delay = delay;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds2(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils6(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name2) {
      const res = getFromWindow3(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e11) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i10 = 0; i10 < links.length; i10++) {
          const link = links[i10];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i10 = 0; i10 < metaTags.length; i10++) {
          const tag = metaTags[i10];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x8) => `%${x8.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode6(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i10 = 1; i10 < tokens.length; i10++) {
          input = decodeComponents(tokens, i10).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode6(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i10 = 0; i10 < entries.length; i10++) {
        var key = entries[i10];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string2, separator) => {
      if (!(typeof string2 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string2];
      }
      const separatorIndex = string2.indexOf(separator);
      if (separatorIndex === -1) {
        return [string2];
      }
      return [
        string2.slice(0, separatorIndex),
        string2.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i10 = 0; i10 < keys.length; i10++) {
        var key = keys[i10];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode5(key, options), "[", encode5(index, options), "]=", encode5(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[]"].join("")];
            }
            return [...result, [encode5(key, options), "[]=", encode5(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), ":list="].join("")];
            }
            return [...result, [encode5(key, options), ":list=", encode5(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode5(key, options), keyValueSep, encode5(value, options)].join("")];
            }
            return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode5(key, options)];
            }
            return [...result, [encode5(key, options), "=", encode5(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode6(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode6(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode6(item, options)) : value === null ? value : decode6(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode6(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode6(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode5(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode6(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a9, b10) => Number(a9) - Number(b10)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode6(value, options);
        formatter(decode6(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k8 of Object.keys(value)) {
            value[k8] = parseValue(value[k8], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse3;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode5(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode5(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode5(key, options) + "=" + encode5(value, options);
      }).filter((x8) => x8.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode6(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode5(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/types.js
var init_types = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/types.js"() {
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/misc.js
var init_misc = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/misc.js"() {
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/validators.js
var init_validators = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/validators.js"() {
    init_misc();
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/parsers.js
var init_parsers = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/parsers.js"() {
    init_misc();
    init_validators();
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js
var RELAY_JSONRPC;
var init_jsonrpc = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js"() {
    RELAY_JSONRPC = {
      waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe"
      },
      irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe"
      },
      iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe"
      }
    };
  }
});

// node_modules/@walletconnect/relay-api/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@walletconnect/relay-api/dist/esm/index.js"() {
    init_types();
    init_parsers();
    init_jsonrpc();
    init_validators();
  }
});

// node_modules/@walletconnect/utils/dist/index.es.js
function rn(e11, n8 = []) {
  const t8 = [];
  return Object.keys(e11).forEach((r7) => {
    if (n8.length && !n8.includes(r7))
      return;
    const o11 = e11[r7];
    t8.push(...o11.accounts);
  }), t8;
}
function R(e11, n8) {
  return e11.includes(":") ? [e11] : n8.chains || [];
}
function dn() {
  const e11 = X.generateKeyPair();
  return { privateKey: toString2(e11.secretKey, u), publicKey: toString2(e11.publicKey, u) };
}
function ln() {
  const e11 = (0, import_random3.randomBytes)(L);
  return toString2(e11, u);
}
function fn(e11, n8) {
  const t8 = X.sharedKey(fromString2(e11, u), fromString2(n8, u)), r7 = new import_hkdf.HKDF(import_sha256.SHA256, t8).expand(L);
  return toString2(r7, u);
}
function pn(e11) {
  const n8 = (0, import_sha256.hash)(fromString2(e11, u));
  return toString2(n8, u);
}
function mn(e11) {
  const n8 = (0, import_sha256.hash)(fromString2(e11, _));
  return toString2(n8, u);
}
function pe(e11) {
  return fromString2(`${e11}`, M);
}
function S(e11) {
  return Number(toString2(e11, M));
}
function yn(e11) {
  const n8 = pe(typeof e11.type < "u" ? e11.type : K);
  if (S(n8) === b && typeof e11.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t8 = typeof e11.senderPublicKey < "u" ? fromString2(e11.senderPublicKey, u) : void 0, r7 = typeof e11.iv < "u" ? fromString2(e11.iv, u) : (0, import_random3.randomBytes)(k), o11 = new import_chacha20poly1305.ChaCha20Poly1305(fromString2(e11.symKey, u)).seal(r7, fromString2(e11.message, _));
  return me({ type: n8, sealed: o11, iv: r7, senderPublicKey: t8 });
}
function En(e11) {
  const n8 = new import_chacha20poly1305.ChaCha20Poly1305(fromString2(e11.symKey, u)), { sealed: t8, iv: r7 } = F(e11.encoded), o11 = n8.open(r7, t8);
  if (o11 === null)
    throw new Error("Failed to decrypt");
  return toString2(o11, _);
}
function me(e11) {
  if (S(e11.type) === b) {
    if (typeof e11.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat4([e11.type, e11.senderPublicKey, e11.iv, e11.sealed]), A);
  }
  return toString2(concat4([e11.type, e11.iv, e11.sealed]), A);
}
function F(e11) {
  const n8 = fromString2(e11, A), t8 = n8.slice(un, fe), r7 = fe;
  if (S(t8) === b) {
    const a9 = r7 + L, p10 = a9 + k, y10 = n8.slice(r7, a9), m11 = n8.slice(a9, p10), c8 = n8.slice(p10);
    return { type: t8, sealed: c8, iv: m11, senderPublicKey: y10 };
  }
  const o11 = r7 + k, s11 = n8.slice(r7, o11), i10 = n8.slice(o11);
  return { type: t8, sealed: i10, iv: s11 };
}
function gn(e11, n8) {
  const t8 = F(e11);
  return ye({ type: S(t8.type), senderPublicKey: typeof t8.senderPublicKey < "u" ? toString2(t8.senderPublicKey, u) : void 0, receiverPublicKey: n8?.receiverPublicKey });
}
function ye(e11) {
  const n8 = e11?.type || K;
  if (n8 === b) {
    if (typeof e11?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e11?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n8, senderPublicKey: e11?.senderPublicKey, receiverPublicKey: e11?.receiverPublicKey };
}
function hn(e11) {
  return e11.type === b && typeof e11.senderPublicKey == "string" && typeof e11.receiverPublicKey == "string";
}
function H() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Oe() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ne;
}
function Se() {
  return !H() && !!(0, import_window_getters.getNavigator)();
}
function q() {
  return Oe() ? O.reactNative : H() ? O.node : Se() ? O.browser : O.unknown;
}
function Ie(e11, n8) {
  let t8 = P.parse(e11);
  return t8 = he(he({}, t8), n8), e11 = P.stringify(t8), e11;
}
function In() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Pe() {
  const e11 = detect();
  if (e11 === null)
    return "unknown";
  const n8 = e11.os ? e11.os.replace(" ", "").toLowerCase() : "unknown";
  return e11.type === "browser" ? [n8, e11.name, e11.version].join("-") : [n8, e11.version].join("-");
}
function Te() {
  var e11;
  const n8 = q();
  return n8 === O.browser ? [n8, ((e11 = (0, import_window_getters.getLocation)()) == null ? void 0 : e11.host) || "unknown"].join(":") : n8;
}
function Re(e11, n8, t8) {
  const r7 = Pe(), o11 = Te();
  return [[e11, n8].join("-"), [be, t8].join("-"), r7, o11].join("/");
}
function Tn({ protocol: e11, version: n8, relayUrl: t8, sdkVersion: r7, auth: o11, projectId: s11, useOnCloseEvent: i10 }) {
  const a9 = t8.split("?"), p10 = Re(e11, n8, r7), y10 = { auth: o11, ua: p10, projectId: s11, useOnCloseEvent: i10 || void 0 }, m11 = Ie(a9[1] || "", y10);
  return a9[0] + "?" + m11;
}
function g(e11, n8) {
  return e11.filter((t8) => n8.includes(t8)).length === e11.length;
}
function _n(e11) {
  return Object.fromEntries(e11.entries());
}
function Cn(e11) {
  return new Map(Object.entries(e11));
}
function jn(e11 = import_time.FIVE_MINUTES, n8) {
  const t8 = (0, import_time.toMiliseconds)(e11 || import_time.FIVE_MINUTES);
  let r7, o11, s11;
  return { resolve: (i10) => {
    s11 && r7 && (clearTimeout(s11), r7(i10));
  }, reject: (i10) => {
    s11 && o11 && (clearTimeout(s11), o11(i10));
  }, done: () => new Promise((i10, a9) => {
    s11 = setTimeout(() => {
      a9(new Error(n8));
    }, t8), r7 = i10, o11 = a9;
  }) };
}
function Vn(e11, n8, t8) {
  return new Promise(async (r7, o11) => {
    const s11 = setTimeout(() => o11(new Error(t8)), n8);
    try {
      const i10 = await e11;
      r7(i10);
    } catch (i10) {
      o11(i10);
    }
    clearTimeout(s11);
  });
}
function B(e11, n8) {
  if (typeof n8 == "string" && n8.startsWith(`${e11}:`))
    return n8;
  if (e11.toLowerCase() === "topic") {
    if (typeof n8 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n8}`;
  } else if (e11.toLowerCase() === "id") {
    if (typeof n8 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n8}`;
  }
  throw new Error(`Unknown expirer target type: ${e11}`);
}
function Mn(e11) {
  return B("topic", e11);
}
function Kn(e11) {
  return B("id", e11);
}
function kn(e11) {
  const [n8, t8] = e11.split(":"), r7 = { id: void 0, topic: void 0 };
  if (n8 === "topic" && typeof t8 == "string")
    r7.topic = t8;
  else if (n8 === "id" && Number.isInteger(Number(t8)))
    r7.id = Number(t8);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n8}:${t8}`);
  return r7;
}
function Ln(e11, n8) {
  return (0, import_time.fromMiliseconds)((n8 || Date.now()) + (0, import_time.toMiliseconds)(e11));
}
function Fn(e11) {
  return Date.now() >= (0, import_time.toMiliseconds)(e11);
}
function xn(e11, n8) {
  return `${e11}${n8 ? `:${n8}` : ""}`;
}
function Hn(e11) {
  return e11?.relay || { protocol: Ce };
}
function qn(e11) {
  const n8 = RELAY_JSONRPC[e11];
  if (typeof n8 > "u")
    throw new Error(`Relay Protocol not supported: ${e11}`);
  return n8;
}
function De(e11, n8 = "-") {
  const t8 = {}, r7 = "relay" + n8;
  return Object.keys(e11).forEach((o11) => {
    if (o11.startsWith(r7)) {
      const s11 = o11.replace(r7, ""), i10 = e11[o11];
      t8[s11] = i10;
    }
  }), t8;
}
function Wn(e11) {
  const n8 = e11.indexOf(":"), t8 = e11.indexOf("?") !== -1 ? e11.indexOf("?") : void 0, r7 = e11.substring(0, n8), o11 = e11.substring(n8 + 1, t8).split("@"), s11 = typeof t8 < "u" ? e11.substring(t8) : "", i10 = P.parse(s11);
  return { protocol: r7, topic: o11[0], version: parseInt(o11[1], 10), symKey: i10.symKey, relay: De(i10) };
}
function je(e11, n8 = "-") {
  const t8 = "relay", r7 = {};
  return Object.keys(e11).forEach((o11) => {
    const s11 = t8 + n8 + o11;
    e11[o11] && (r7[s11] = e11[o11]);
  }), r7;
}
function Jn(e11) {
  return `${e11.protocol}:${e11.topic}@${e11.version}?` + P.stringify(Yn({ symKey: e11.symKey }, je(e11.relay)));
}
function N(e11) {
  const n8 = [];
  return e11.forEach((t8) => {
    const [r7, o11] = t8.split(":");
    n8.push(`${r7}:${o11}`);
  }), n8;
}
function Ve(e11) {
  const n8 = [];
  return Object.values(e11).forEach((t8) => {
    n8.push(...N(t8.accounts));
  }), n8;
}
function Me(e11, n8) {
  const t8 = [];
  return Object.values(e11).forEach((r7) => {
    N(r7.accounts).includes(n8) && t8.push(...r7.methods);
  }), t8;
}
function Ke(e11, n8) {
  const t8 = [];
  return Object.values(e11).forEach((r7) => {
    N(r7.accounts).includes(n8) && t8.push(...r7.events);
  }), t8;
}
function Qn(e11, n8) {
  const t8 = Be(e11, n8);
  if (t8)
    throw new Error(t8.message);
  const r7 = {};
  for (const [o11, s11] of Object.entries(e11))
    r7[o11] = { methods: s11.methods, events: s11.events, chains: s11.accounts.map((i10) => `${i10.split(":")[0]}:${i10.split(":")[1]}`) };
  return r7;
}
function E(e11, n8) {
  const { message: t8, code: r7 } = Xn[e11];
  return { message: n8 ? `${t8} ${n8}` : t8, code: r7 };
}
function v(e11, n8) {
  const { message: t8, code: r7 } = Zn[e11];
  return { message: n8 ? `${t8} ${n8}` : t8, code: r7 };
}
function I(e11, n8) {
  return Array.isArray(e11) ? typeof n8 < "u" && e11.length ? e11.every(n8) : true : false;
}
function G(e11) {
  return Object.getPrototypeOf(e11) === Object.prototype && Object.keys(e11).length;
}
function h(e11) {
  return typeof e11 > "u";
}
function d(e11, n8) {
  return n8 && h(e11) ? true : typeof e11 == "string" && Boolean(e11.trim().length);
}
function w(e11, n8) {
  return n8 && h(e11) ? true : typeof e11 == "number" && !isNaN(e11);
}
function et(e11, n8) {
  const { requiredNamespaces: t8 } = n8, r7 = Object.keys(e11.namespaces), o11 = Object.keys(t8);
  let s11 = true;
  return g(o11, r7) ? (r7.forEach((i10) => {
    const { accounts: a9, methods: p10, events: y10 } = e11.namespaces[i10], m11 = N(a9), c8 = t8[i10];
    (!g(R(i10, c8), m11) || !g(c8.methods, p10) || !g(c8.events, y10)) && (s11 = false);
  }), s11) : false;
}
function $(e11) {
  return d(e11, false) && e11.includes(":") ? e11.split(":").length === 2 : false;
}
function ke(e11) {
  if (d(e11, false) && e11.includes(":")) {
    const n8 = e11.split(":");
    if (n8.length === 3) {
      const t8 = n8[0] + ":" + n8[1];
      return !!n8[2] && $(t8);
    }
  }
  return false;
}
function nt(e11) {
  if (d(e11, false))
    try {
      return typeof new URL(e11) < "u";
    } catch {
      return false;
    }
  return false;
}
function tt(e11) {
  var n8;
  return (n8 = e11?.proposer) == null ? void 0 : n8.publicKey;
}
function rt(e11) {
  return e11?.topic;
}
function ot(e11, n8) {
  let t8 = null;
  return d(e11?.publicKey, false) || (t8 = E("MISSING_OR_INVALID", `${n8} controller public key should be a string`)), t8;
}
function z(e11) {
  let n8 = true;
  return I(e11) ? e11.length && (n8 = e11.every((t8) => d(t8, false))) : n8 = false, n8;
}
function Le(e11, n8, t8) {
  let r7 = null;
  return I(n8) ? n8.forEach((o11) => {
    r7 || (!$(o11) || !o11.includes(e11)) && (r7 = v("UNSUPPORTED_CHAINS", `${t8}, chain ${o11} should be a string and conform to "namespace:chainId" format`));
  }) : r7 = v("UNSUPPORTED_CHAINS", `${t8}, chains ${n8} should be an array of strings conforming to "namespace:chainId" format`), r7;
}
function Fe(e11, n8) {
  let t8 = null;
  return Object.entries(e11).forEach(([r7, o11]) => {
    if (t8)
      return;
    const s11 = Le(r7, R(r7, o11), `${n8} requiredNamespace`);
    s11 && (t8 = s11);
  }), t8;
}
function xe(e11, n8) {
  let t8 = null;
  return I(e11) ? e11.forEach((r7) => {
    t8 || ke(r7) || (t8 = v("UNSUPPORTED_ACCOUNTS", `${n8}, account ${r7} should be a string and conform to "namespace:chainId:address" format`));
  }) : t8 = v("UNSUPPORTED_ACCOUNTS", `${n8}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t8;
}
function He(e11, n8) {
  let t8 = null;
  return Object.values(e11).forEach((r7) => {
    if (t8)
      return;
    const o11 = xe(r7?.accounts, `${n8} namespace`);
    o11 && (t8 = o11);
  }), t8;
}
function qe(e11, n8) {
  let t8 = null;
  return z(e11?.methods) ? z(e11?.events) || (t8 = v("UNSUPPORTED_EVENTS", `${n8}, events should be an array of strings or empty array for no events`)) : t8 = v("UNSUPPORTED_METHODS", `${n8}, methods should be an array of strings or empty array for no methods`), t8;
}
function Y(e11, n8) {
  let t8 = null;
  return Object.values(e11).forEach((r7) => {
    if (t8)
      return;
    const o11 = qe(r7, `${n8}, namespace`);
    o11 && (t8 = o11);
  }), t8;
}
function st(e11, n8, t8) {
  let r7 = null;
  if (e11 && G(e11)) {
    const o11 = Y(e11, n8);
    o11 && (r7 = o11);
    const s11 = Fe(e11, n8);
    s11 && (r7 = s11);
  } else
    r7 = E("MISSING_OR_INVALID", `${n8}, ${t8} should be an object with data`);
  return r7;
}
function Be(e11, n8) {
  let t8 = null;
  if (e11 && G(e11)) {
    const r7 = Y(e11, n8);
    r7 && (t8 = r7);
    const o11 = He(e11, n8);
    o11 && (t8 = o11);
  } else
    t8 = E("MISSING_OR_INVALID", `${n8}, namespaces should be an object with data`);
  return t8;
}
function Ge(e11) {
  return d(e11.protocol, true);
}
function it(e11, n8) {
  let t8 = false;
  return n8 && !e11 ? t8 = true : e11 && I(e11) && e11.length && e11.forEach((r7) => {
    t8 = Ge(r7);
  }), t8;
}
function ct(e11) {
  return typeof e11 == "number";
}
function at(e11) {
  return typeof e11 < "u" && typeof e11 !== null;
}
function ut(e11) {
  return !(!e11 || typeof e11 != "object" || !e11.code || !w(e11.code, false) || !e11.message || !d(e11.message, false));
}
function dt(e11) {
  return !(h(e11) || !d(e11.method, false));
}
function lt(e11) {
  return !(h(e11) || h(e11.result) && h(e11.error) || !w(e11.id, false) || !d(e11.jsonrpc, false));
}
function ft(e11) {
  return !(h(e11) || !d(e11.name, false));
}
function pt(e11, n8) {
  return !(!$(n8) || !Ve(e11).includes(n8));
}
function mt(e11, n8, t8) {
  return d(t8, false) ? Me(e11, n8).includes(t8) : false;
}
function yt(e11, n8, t8) {
  return d(t8, false) ? Ke(e11, n8).includes(t8) : false;
}
function Et(e11, n8, t8) {
  let r7 = null;
  const o11 = gt(e11), s11 = ht(n8), i10 = Object.keys(o11), a9 = Object.keys(s11), p10 = ze(Object.keys(e11)), y10 = ze(Object.keys(n8)), m11 = p10.filter((c8) => !y10.includes(c8));
  return m11.length && (r7 = E("NON_CONFORMING_NAMESPACES", `${t8} namespaces keys don't satisfy requiredNamespaces.
      Required: ${m11.toString()}
      Received: ${Object.keys(n8).toString()}`)), g(i10, a9) || (r7 = E("NON_CONFORMING_NAMESPACES", `${t8} namespaces chains don't satisfy required namespaces.
      Required: ${i10.toString()}
      Approved: ${a9.toString()}`)), Object.keys(n8).forEach((c8) => {
    if (!c8.includes(":") || r7)
      return;
    const W5 = N(n8[c8].accounts);
    W5.includes(c8) || (r7 = E("NON_CONFORMING_NAMESPACES", `${t8} namespaces accounts don't satisfy namespace accounts for ${c8}
        Required: ${c8}
        Approved: ${W5.toString()}`));
  }), i10.forEach((c8) => {
    r7 || (g(o11[c8].methods, s11[c8].methods) ? g(o11[c8].events, s11[c8].events) || (r7 = E("NON_CONFORMING_NAMESPACES", `${t8} namespaces events don't satisfy namespace events for ${c8}`)) : r7 = E("NON_CONFORMING_NAMESPACES", `${t8} namespaces methods don't satisfy namespace methods for ${c8}`));
  }), r7;
}
function gt(e11) {
  const n8 = {};
  return Object.keys(e11).forEach((t8) => {
    var r7;
    t8.includes(":") ? n8[t8] = e11[t8] : (r7 = e11[t8].chains) == null || r7.forEach((o11) => {
      n8[o11] = { methods: e11[t8].methods, events: e11[t8].events };
    });
  }), n8;
}
function ze(e11) {
  return [...new Set(e11.map((n8) => n8.includes(":") ? n8.split(":")[0] : n8))];
}
function ht(e11) {
  const n8 = {};
  return Object.keys(e11).forEach((t8) => {
    if (t8.includes(":"))
      n8[t8] = e11[t8];
    else {
      const r7 = N(e11[t8].accounts);
      r7?.forEach((o11) => {
        n8[o11] = { accounts: e11[t8].accounts.filter((s11) => s11.includes(`${o11}:`)), methods: e11[t8].methods, events: e11[t8].events };
      });
    }
  }), n8;
}
function Nt(e11, n8) {
  return w(e11, false) && e11 <= n8.max && e11 >= n8.min;
}
var import_chacha20poly1305, import_hkdf, import_random3, import_sha256, X, import_time, import_window_getters, import_window_metadata, P, M, u, A, _, K, b, un, fe, k, L, Nn, Ee, vn, bn, ge, he, Ne, O, be, Ce, Bn, we, Gn, zn, $e, Yn, Zn, Xn;
var init_index_es = __esm({
  "node_modules/@walletconnect/utils/dist/index.es.js"() {
    import_chacha20poly1305 = __toESM(require_chacha20poly1305());
    import_hkdf = __toESM(require_hkdf());
    import_random3 = __toESM(require_random());
    import_sha256 = __toESM(require_sha256());
    X = __toESM(require_x25519());
    init_src2();
    init_es();
    import_time = __toESM(require_cjs());
    import_window_getters = __toESM(require_cjs2());
    import_window_metadata = __toESM(require_cjs3());
    P = __toESM(require_query_string());
    init_esm();
    M = "base10";
    u = "base16";
    A = "base64pad";
    _ = "utf8";
    K = 0;
    b = 1;
    un = 0;
    fe = 1;
    k = 12;
    L = 32;
    Nn = Object.defineProperty;
    Ee = Object.getOwnPropertySymbols;
    vn = Object.prototype.hasOwnProperty;
    bn = Object.prototype.propertyIsEnumerable;
    ge = (e11, n8, t8) => n8 in e11 ? Nn(e11, n8, { enumerable: true, configurable: true, writable: true, value: t8 }) : e11[n8] = t8;
    he = (e11, n8) => {
      for (var t8 in n8 || (n8 = {}))
        vn.call(n8, t8) && ge(e11, t8, n8[t8]);
      if (Ee)
        for (var t8 of Ee(n8))
          bn.call(n8, t8) && ge(e11, t8, n8[t8]);
      return e11;
    };
    Ne = "ReactNative";
    O = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
    be = "js";
    Ce = "irn";
    Bn = Object.defineProperty;
    we = Object.getOwnPropertySymbols;
    Gn = Object.prototype.hasOwnProperty;
    zn = Object.prototype.propertyIsEnumerable;
    $e = (e11, n8, t8) => n8 in e11 ? Bn(e11, n8, { enumerable: true, configurable: true, writable: true, value: t8 }) : e11[n8] = t8;
    Yn = (e11, n8) => {
      for (var t8 in n8 || (n8 = {}))
        Gn.call(n8, t8) && $e(e11, t8, n8[t8]);
      if (we)
        for (var t8 of we(n8))
          zn.call(n8, t8) && $e(e11, t8, n8[t8]);
      return e11;
    };
    Zn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
    Xn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o11) {
      try {
        return JSON.stringify(o11);
      } catch (e11) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f7, args, opts) {
      var ss3 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f7 === "object" && f7 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f7;
        var objects = new Array(len);
        objects[0] = ss3(f7);
        for (var index = 1; index < len; index++) {
          objects[index] = ss3(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f7 !== "string") {
        return f7;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f7;
      var str = "";
      var a9 = 1 - offset;
      var lastPos = -1;
      var flen = f7 && f7.length || 0;
      for (var i10 = 0; i10 < flen; ) {
        if (f7.charCodeAt(i10) === 37 && i10 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f7.charCodeAt(i10 + 1)) {
            case 100:
            case 102:
              if (a9 >= argLen)
                break;
              if (args[a9] == null)
                break;
              if (lastPos < i10)
                str += f7.slice(lastPos, i10);
              str += Number(args[a9]);
              lastPos = i10 + 2;
              i10++;
              break;
            case 105:
              if (a9 >= argLen)
                break;
              if (args[a9] == null)
                break;
              if (lastPos < i10)
                str += f7.slice(lastPos, i10);
              str += Math.floor(Number(args[a9]));
              lastPos = i10 + 2;
              i10++;
              break;
            case 79:
            case 111:
            case 106:
              if (a9 >= argLen)
                break;
              if (args[a9] === void 0)
                break;
              if (lastPos < i10)
                str += f7.slice(lastPos, i10);
              var type = typeof args[a9];
              if (type === "string") {
                str += "'" + args[a9] + "'";
                lastPos = i10 + 2;
                i10++;
                break;
              }
              if (type === "function") {
                str += args[a9].name || "<anonymous>";
                lastPos = i10 + 2;
                i10++;
                break;
              }
              str += ss3(args[a9]);
              lastPos = i10 + 2;
              i10++;
              break;
            case 115:
              if (a9 >= argLen)
                break;
              if (lastPos < i10)
                str += f7.slice(lastPos, i10);
              str += String(args[a9]);
              lastPos = i10 + 2;
              i10++;
              break;
            case 37:
              if (lastPos < i10)
                str += f7.slice(lastPos, i10);
              str += "%";
              lastPos = i10 + 2;
              i10++;
              a9--;
              break;
          }
          ++a9;
        }
        ++i10;
      }
      if (lastPos === -1)
        return f7;
      else if (lastPos < flen) {
        str += f7.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize3, serializers) {
      if (Array.isArray(serialize3)) {
        const hasToFilter = serialize3.filter(function(k8) {
          return k8 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize3 === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize3 = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger19 = Object.create(proto);
      if (!logger19.log)
        logger19.log = noop2;
      Object.defineProperty(logger19, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger19, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize: serialize3,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger19.levels = pino.levels;
      logger19.level = level;
      logger19.setMaxListeners = logger19.getMaxListeners = logger19.emit = logger19.addListener = logger19.on = logger19.prependListener = logger19.once = logger19.prependOnceListener = logger19.removeListener = logger19.removeAllListeners = logger19.listeners = logger19.listenerCount = logger19.eventNames = logger19.write = logger19.flush = noop2;
      logger19.serializers = serializers;
      logger19._serialize = serialize3;
      logger19._stdErrSerialize = stdErrSerialize;
      logger19.child = child;
      if (transmit2)
        logger19._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(setOpts, logger19, "error", "log");
        set(setOpts, logger19, "fatal", "error");
        set(setOpts, logger19, "warn", "error");
        set(setOpts, logger19, "info", "log");
        set(setOpts, logger19, "debug", "log");
        set(setOpts, logger19, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize3 && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize3 && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize3;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger19;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set(opts, logger19, level, fallback) {
      const proto = Object.getPrototypeOf(logger19);
      logger19[level] = logger19.levelVal > logger19.levels.values[level] ? noop2 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop2;
      wrap2(opts, logger19, level);
    }
    function wrap2(opts, logger19, level) {
      if (!opts.transmit && logger19[level] === noop2)
        return;
      logger19[level] = function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i10 = 0; i10 < args.length; i10++)
            args[i10] = arguments[i10];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts2));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger19.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger19.level],
              send: opts.transmit.send,
              val: logger19.levelVal
            }, args);
          }
        };
      }(logger19[level]);
    }
    function asObject(logger19, level, args, ts2) {
      if (logger19._serialize)
        applySerializers(args, logger19._serialize, logger19.serializers, logger19._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o11 = {};
      if (ts2) {
        o11.time = ts2;
      }
      o11.level = pino.levels.values[level];
      let lvl = (logger19._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o11, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o11.msg = msg;
      return o11;
    }
    function applySerializers(args, serialize3, serializers, stdErrSerialize) {
      for (const i10 in args) {
        if (stdErrSerialize && args[i10] instanceof Error) {
          args[i10] = pino.stdSerializers.err(args[i10]);
        } else if (typeof args[i10] === "object" && !Array.isArray(args[i10])) {
          for (const k8 in args[i10]) {
            if (serialize3 && serialize3.indexOf(k8) > -1 && k8 in serializers) {
              args[i10][k8] = serializers[k8](args[i10][k8]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i10 = 1; i10 < args.length; i10++) {
          args[i10] = arguments[i10 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger19, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger19._logEvent.bindings;
      applySerializers(
        args,
        logger19._serialize || Object.keys(logger19.serializers),
        logger19.serializers,
        logger19._stdErrSerialize === void 0 ? true : logger19._stdErrSerialize
      );
      logger19._logEvent.ts = ts2;
      logger19._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger19._logEvent.level.label = methodLevel;
      logger19._logEvent.level.value = methodValue;
      send(methodLevel, logger19._logEvent, val);
      logger19._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a9) {
      return a9;
    }
    function noop2() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o11) {
        return typeof o11 !== "undefined" && o11;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e11) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/safe-json-utils/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/safe-json-utils/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function safeJsonParse3(value) {
      if (typeof value !== "string") {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
      }
      try {
        return JSON.parse(value);
      } catch (_a2) {
        return value;
      }
    }
    exports.safeJsonParse = safeJsonParse3;
    function safeJsonStringify3(value) {
      return typeof value === "string" ? value : JSON.stringify(value, (key, value2) => typeof value2 === "undefined" ? null : value2);
    }
    exports.safeJsonStringify = safeJsonStringify3;
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/cjs/browser/lib/localStorage.js
var require_localStorage = __commonJS({
  "node_modules/@walletconnect/keyvaluestorage/dist/cjs/browser/lib/localStorage.js"(exports, module) {
    "use strict";
    (function() {
      "use strict";
      let db;
      function LocalStorage() {
      }
      db = LocalStorage;
      db.prototype.getItem = function(key) {
        if (this.hasOwnProperty(key)) {
          return String(this[key]);
        }
        return null;
      };
      db.prototype.setItem = function(key, val) {
        this[key] = String(val);
      };
      db.prototype.removeItem = function(key) {
        delete this[key];
      };
      db.prototype.clear = function() {
        const self2 = this;
        Object.keys(self2).forEach(function(key) {
          self2[key] = void 0;
          delete self2[key];
        });
      };
      db.prototype.key = function(i10) {
        i10 = i10 || 0;
        return Object.keys(this)[i10];
      };
      db.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length;
      });
      if (typeof global !== "undefined" && global.localStorage) {
        module.exports = global.localStorage;
      } else if (typeof window !== "undefined" && window.localStorage) {
        module.exports = window.localStorage;
      } else {
        module.exports = new LocalStorage();
      }
    })();
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/types.js
var require_types3 = __commonJS({
  "node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IKeyValueStorage = void 0;
    var IKeyValueStorage = class {
    };
    exports.IKeyValueStorage = IKeyValueStorage;
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/utils.js
var require_utils7 = __commonJS({
  "node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEntry = void 0;
    var safe_json_utils_1 = require_cjs4();
    function parseEntry(entry) {
      var _a2;
      return [entry[0], safe_json_utils_1.safeJsonParse((_a2 = entry[1]) !== null && _a2 !== void 0 ? _a2 : "")];
    }
    exports.parseEntry = parseEntry;
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/index.js
var require_shared = __commonJS({
  "node_modules/@walletconnect/keyvaluestorage/dist/cjs/shared/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_types3(), exports);
    tslib_1.__exportStar(require_utils7(), exports);
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/cjs/browser/index.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/keyvaluestorage/dist/cjs/browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyValueStorage = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var safe_json_utils_1 = require_cjs4();
    var localStorage_1 = tslib_1.__importDefault(require_localStorage());
    var shared_1 = require_shared();
    var KeyValueStorage = class {
      constructor() {
        this.localStorage = localStorage_1.default;
      }
      getKeys() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return Object.keys(this.localStorage);
        });
      }
      getEntries() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return Object.entries(this.localStorage).map(shared_1.parseEntry);
        });
      }
      getItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const item = this.localStorage.getItem(key);
          if (item === null) {
            return void 0;
          }
          return safe_json_utils_1.safeJsonParse(item);
        });
      }
      setItem(key, value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.localStorage.setItem(key, safe_json_utils_1.safeJsonStringify(value));
        });
      }
      removeItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.localStorage.removeItem(key);
        });
      }
    };
    exports.KeyValueStorage = KeyValueStorage;
    exports.default = KeyValueStorage;
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  IEvents: () => IEvents
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    init_events();
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm2(), __toCommonJS(esm_exports));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types4 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types4();
    var constants_1 = require_constants2();
    var HeartBeat = class extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types4(), exports);
    tslib_1.__exportStar(require_constants2(), exports);
  }
});

// node_modules/@walletconnect/logger/dist/cjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PINO_CUSTOM_CONTEXT_KEY = exports.PINO_LOGGER_DEFAULTS = void 0;
    exports.PINO_LOGGER_DEFAULTS = {
      level: "info"
    };
    exports.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
  }
});

// node_modules/@walletconnect/logger/dist/cjs/utils.js
var require_utils8 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateChildLogger = exports.formatChildLoggerContext = exports.getLoggerContext = exports.setBrowserLoggerContext = exports.getBrowserLoggerContext = exports.getDefaultLoggerOptions = void 0;
    var constants_1 = require_constants3();
    function getDefaultLoggerOptions(opts) {
      return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
    }
    exports.getDefaultLoggerOptions = getDefaultLoggerOptions;
    function getBrowserLoggerContext(logger19, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      return logger19[customContextKey] || "";
    }
    exports.getBrowserLoggerContext = getBrowserLoggerContext;
    function setBrowserLoggerContext(logger19, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      logger19[customContextKey] = context;
      return logger19;
    }
    exports.setBrowserLoggerContext = setBrowserLoggerContext;
    function getLoggerContext(logger19, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      let context = "";
      if (typeof logger19.bindings === "undefined") {
        context = getBrowserLoggerContext(logger19, customContextKey);
      } else {
        context = logger19.bindings().context || "";
      }
      return context;
    }
    exports.getLoggerContext = getLoggerContext;
    function formatChildLoggerContext(logger19, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const parentContext = getLoggerContext(logger19, customContextKey);
      const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;
      return context;
    }
    exports.formatChildLoggerContext = formatChildLoggerContext;
    function generateChildLogger(logger19, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const context = formatChildLoggerContext(logger19, childContext, customContextKey);
      const child = logger19.child({ context });
      return setBrowserLoggerContext(child, context, customContextKey);
    }
    exports.generateChildLogger = generateChildLogger;
  }
});

// node_modules/@walletconnect/logger/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pino = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pino_1 = tslib_1.__importDefault(require_browser2());
    Object.defineProperty(exports, "pino", { enumerable: true, get: function() {
      return pino_1.default;
    } });
    tslib_1.__exportStar(require_constants3(), exports);
    tslib_1.__exportStar(require_utils8(), exports);
  }
});

// node_modules/@walletconnect/types/dist/index.es.js
var import_events2, n, h2, a, u2, g2, p, x, E2, y, C;
var init_index_es2 = __esm({
  "node_modules/@walletconnect/types/dist/index.es.js"() {
    init_esm2();
    import_events2 = __toESM(require_events());
    n = class extends IEvents {
      constructor(s11) {
        super(), this.opts = s11, this.protocol = "wc", this.version = 2;
      }
    };
    h2 = class extends IEvents {
      constructor(s11, t8) {
        super(), this.core = s11, this.logger = t8, this.records = /* @__PURE__ */ new Map();
      }
    };
    a = class {
      constructor(s11, t8) {
        this.logger = s11, this.core = t8;
      }
    };
    u2 = class extends IEvents {
      constructor(s11, t8) {
        super(), this.relayer = s11, this.logger = t8;
      }
    };
    g2 = class extends IEvents {
      constructor(s11) {
        super();
      }
    };
    p = class {
      constructor(s11, t8, o11, S7) {
        this.core = s11, this.logger = t8, this.name = o11;
      }
    };
    x = class extends IEvents {
      constructor(s11, t8) {
        super(), this.relayer = s11, this.logger = t8;
      }
    };
    E2 = class extends IEvents {
      constructor(s11, t8) {
        super(), this.core = s11, this.logger = t8;
      }
    };
    y = class {
      constructor(s11) {
        this.opts = s11, this.protocol = "wc", this.version = 2;
      }
    };
    C = class {
      constructor(s11) {
        this.client = s11;
      }
    };
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm3 = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data2, dataLength) {
          if (dataLength === void 0) {
            dataLength = data2.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i10 = left + 1; i10 < padLength - 8; i10++) {
              this._buffer[i10] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i10 = 0; i10 < this.digestLength / 8; i10++) {
            binary_1.writeUint32BE(this._stateHi[i10], out, i10 * 8);
            binary_1.writeUint32BE(this._stateLo[i10], out, i10 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K6 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m11, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h11, l9;
      var th, tl;
      var a9, b10, c8, d9;
      while (len >= 128) {
        for (var i10 = 0; i10 < 16; i10++) {
          var j8 = 8 * i10 + pos;
          wh[i10] = binary_1.readUint32BE(m11, j8);
          wl[i10] = binary_1.readUint32BE(m11, j8 + 4);
        }
        for (var i10 = 0; i10 < 80; i10++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h11 = ah7;
          l9 = al7;
          a9 = l9 & 65535;
          b10 = l9 >>> 16;
          c8 = h11 & 65535;
          d9 = h11 >>> 16;
          h11 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l9 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          h11 = ah4 & ah5 ^ ~ah4 & ah6;
          l9 = al4 & al5 ^ ~al4 & al6;
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          h11 = K6[i10 * 2];
          l9 = K6[i10 * 2 + 1];
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          h11 = wh[i10 % 16];
          l9 = wl[i10 % 16];
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          b10 += a9 >>> 16;
          c8 += b10 >>> 16;
          d9 += c8 >>> 16;
          th = c8 & 65535 | d9 << 16;
          tl = a9 & 65535 | b10 << 16;
          h11 = th;
          l9 = tl;
          a9 = l9 & 65535;
          b10 = l9 >>> 16;
          c8 = h11 & 65535;
          d9 = h11 >>> 16;
          h11 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l9 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          h11 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l9 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          b10 += a9 >>> 16;
          c8 += b10 >>> 16;
          d9 += c8 >>> 16;
          bh7 = c8 & 65535 | d9 << 16;
          bl7 = a9 & 65535 | b10 << 16;
          h11 = bh3;
          l9 = bl3;
          a9 = l9 & 65535;
          b10 = l9 >>> 16;
          c8 = h11 & 65535;
          d9 = h11 >>> 16;
          h11 = th;
          l9 = tl;
          a9 += l9 & 65535;
          b10 += l9 >>> 16;
          c8 += h11 & 65535;
          d9 += h11 >>> 16;
          b10 += a9 >>> 16;
          c8 += b10 >>> 16;
          d9 += c8 >>> 16;
          bh3 = c8 & 65535 | d9 << 16;
          bl3 = a9 & 65535 | b10 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i10 % 16 === 15) {
            for (var j8 = 0; j8 < 16; j8++) {
              h11 = wh[j8];
              l9 = wl[j8];
              a9 = l9 & 65535;
              b10 = l9 >>> 16;
              c8 = h11 & 65535;
              d9 = h11 >>> 16;
              h11 = wh[(j8 + 9) % 16];
              l9 = wl[(j8 + 9) % 16];
              a9 += l9 & 65535;
              b10 += l9 >>> 16;
              c8 += h11 & 65535;
              d9 += h11 >>> 16;
              th = wh[(j8 + 1) % 16];
              tl = wl[(j8 + 1) % 16];
              h11 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l9 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a9 += l9 & 65535;
              b10 += l9 >>> 16;
              c8 += h11 & 65535;
              d9 += h11 >>> 16;
              th = wh[(j8 + 14) % 16];
              tl = wl[(j8 + 14) % 16];
              h11 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l9 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a9 += l9 & 65535;
              b10 += l9 >>> 16;
              c8 += h11 & 65535;
              d9 += h11 >>> 16;
              b10 += a9 >>> 16;
              c8 += b10 >>> 16;
              d9 += c8 >>> 16;
              wh[j8] = c8 & 65535 | d9 << 16;
              wl[j8] = a9 & 65535 | b10 << 16;
            }
          }
        }
        h11 = ah0;
        l9 = al0;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[0];
        l9 = hl[0];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[0] = ah0 = c8 & 65535 | d9 << 16;
        hl[0] = al0 = a9 & 65535 | b10 << 16;
        h11 = ah1;
        l9 = al1;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[1];
        l9 = hl[1];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[1] = ah1 = c8 & 65535 | d9 << 16;
        hl[1] = al1 = a9 & 65535 | b10 << 16;
        h11 = ah2;
        l9 = al2;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[2];
        l9 = hl[2];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[2] = ah2 = c8 & 65535 | d9 << 16;
        hl[2] = al2 = a9 & 65535 | b10 << 16;
        h11 = ah3;
        l9 = al3;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[3];
        l9 = hl[3];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[3] = ah3 = c8 & 65535 | d9 << 16;
        hl[3] = al3 = a9 & 65535 | b10 << 16;
        h11 = ah4;
        l9 = al4;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[4];
        l9 = hl[4];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[4] = ah4 = c8 & 65535 | d9 << 16;
        hl[4] = al4 = a9 & 65535 | b10 << 16;
        h11 = ah5;
        l9 = al5;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[5];
        l9 = hl[5];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[5] = ah5 = c8 & 65535 | d9 << 16;
        hl[5] = al5 = a9 & 65535 | b10 << 16;
        h11 = ah6;
        l9 = al6;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[6];
        l9 = hl[6];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[6] = ah6 = c8 & 65535 | d9 << 16;
        hl[6] = al6 = a9 & 65535 | b10 << 16;
        h11 = ah7;
        l9 = al7;
        a9 = l9 & 65535;
        b10 = l9 >>> 16;
        c8 = h11 & 65535;
        d9 = h11 >>> 16;
        h11 = hh[7];
        l9 = hl[7];
        a9 += l9 & 65535;
        b10 += l9 >>> 16;
        c8 += h11 & 65535;
        d9 += h11 >>> 16;
        b10 += a9 >>> 16;
        c8 += b10 >>> 16;
        d9 += c8 >>> 16;
        hh[7] = ah7 = c8 & 65535 | d9 << 16;
        hl[7] = al7 = a9 & 65535 | b10 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data2) {
      var h11 = new SHA512();
      h11.update(data2);
      var digest2 = h11.digest();
      h11.clean();
      return digest2;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r7 = new Float64Array(16);
      if (init) {
        for (let i10 = 0; i10 < init.length; i10++) {
          r7[i10] = init[i10];
        }
      }
      return r7;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D7 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X6 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y7 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I9 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r7, a9) {
      for (let i10 = 0; i10 < 16; i10++) {
        r7[i10] = a9[i10] | 0;
      }
    }
    function car25519(o11) {
      let c8 = 1;
      for (let i10 = 0; i10 < 16; i10++) {
        let v7 = o11[i10] + c8 + 65535;
        c8 = Math.floor(v7 / 65536);
        o11[i10] = v7 - c8 * 65536;
      }
      o11[0] += c8 - 1 + 37 * (c8 - 1);
    }
    function sel25519(p10, q8, b10) {
      const c8 = ~(b10 - 1);
      for (let i10 = 0; i10 < 16; i10++) {
        const t8 = c8 & (p10[i10] ^ q8[i10]);
        p10[i10] ^= t8;
        q8[i10] ^= t8;
      }
    }
    function pack25519(o11, n8) {
      const m11 = gf();
      const t8 = gf();
      for (let i10 = 0; i10 < 16; i10++) {
        t8[i10] = n8[i10];
      }
      car25519(t8);
      car25519(t8);
      car25519(t8);
      for (let j8 = 0; j8 < 2; j8++) {
        m11[0] = t8[0] - 65517;
        for (let i10 = 1; i10 < 15; i10++) {
          m11[i10] = t8[i10] - 65535 - (m11[i10 - 1] >> 16 & 1);
          m11[i10 - 1] &= 65535;
        }
        m11[15] = t8[15] - 32767 - (m11[14] >> 16 & 1);
        const b10 = m11[15] >> 16 & 1;
        m11[14] &= 65535;
        sel25519(t8, m11, 1 - b10);
      }
      for (let i10 = 0; i10 < 16; i10++) {
        o11[2 * i10] = t8[i10] & 255;
        o11[2 * i10 + 1] = t8[i10] >> 8;
      }
    }
    function verify32(x8, y10) {
      let d9 = 0;
      for (let i10 = 0; i10 < 32; i10++) {
        d9 |= x8[i10] ^ y10[i10];
      }
      return (1 & d9 - 1 >>> 8) - 1;
    }
    function neq25519(a9, b10) {
      const c8 = new Uint8Array(32);
      const d9 = new Uint8Array(32);
      pack25519(c8, a9);
      pack25519(d9, b10);
      return verify32(c8, d9);
    }
    function par25519(a9) {
      const d9 = new Uint8Array(32);
      pack25519(d9, a9);
      return d9[0] & 1;
    }
    function unpack25519(o11, n8) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = n8[2 * i10] + (n8[2 * i10 + 1] << 8);
      }
      o11[15] &= 32767;
    }
    function add(o11, a9, b10) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = a9[i10] + b10[i10];
      }
    }
    function sub(o11, a9, b10) {
      for (let i10 = 0; i10 < 16; i10++) {
        o11[i10] = a9[i10] - b10[i10];
      }
    }
    function mul(o11, a9, b10) {
      let v7, c8, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b10[0], b1 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8], b92 = b10[9], b102 = b10[10], b11 = b10[11], b12 = b10[12], b13 = b10[13], b14 = b10[14], b15 = b10[15];
      v7 = a9[0];
      t0 += v7 * b0;
      t1 += v7 * b1;
      t22 += v7 * b22;
      t32 += v7 * b32;
      t42 += v7 * b42;
      t52 += v7 * b52;
      t62 += v7 * b62;
      t72 += v7 * b72;
      t8 += v7 * b82;
      t9 += v7 * b92;
      t10 += v7 * b102;
      t11 += v7 * b11;
      t12 += v7 * b12;
      t13 += v7 * b13;
      t14 += v7 * b14;
      t15 += v7 * b15;
      v7 = a9[1];
      t1 += v7 * b0;
      t22 += v7 * b1;
      t32 += v7 * b22;
      t42 += v7 * b32;
      t52 += v7 * b42;
      t62 += v7 * b52;
      t72 += v7 * b62;
      t8 += v7 * b72;
      t9 += v7 * b82;
      t10 += v7 * b92;
      t11 += v7 * b102;
      t12 += v7 * b11;
      t13 += v7 * b12;
      t14 += v7 * b13;
      t15 += v7 * b14;
      t16 += v7 * b15;
      v7 = a9[2];
      t22 += v7 * b0;
      t32 += v7 * b1;
      t42 += v7 * b22;
      t52 += v7 * b32;
      t62 += v7 * b42;
      t72 += v7 * b52;
      t8 += v7 * b62;
      t9 += v7 * b72;
      t10 += v7 * b82;
      t11 += v7 * b92;
      t12 += v7 * b102;
      t13 += v7 * b11;
      t14 += v7 * b12;
      t15 += v7 * b13;
      t16 += v7 * b14;
      t17 += v7 * b15;
      v7 = a9[3];
      t32 += v7 * b0;
      t42 += v7 * b1;
      t52 += v7 * b22;
      t62 += v7 * b32;
      t72 += v7 * b42;
      t8 += v7 * b52;
      t9 += v7 * b62;
      t10 += v7 * b72;
      t11 += v7 * b82;
      t12 += v7 * b92;
      t13 += v7 * b102;
      t14 += v7 * b11;
      t15 += v7 * b12;
      t16 += v7 * b13;
      t17 += v7 * b14;
      t18 += v7 * b15;
      v7 = a9[4];
      t42 += v7 * b0;
      t52 += v7 * b1;
      t62 += v7 * b22;
      t72 += v7 * b32;
      t8 += v7 * b42;
      t9 += v7 * b52;
      t10 += v7 * b62;
      t11 += v7 * b72;
      t12 += v7 * b82;
      t13 += v7 * b92;
      t14 += v7 * b102;
      t15 += v7 * b11;
      t16 += v7 * b12;
      t17 += v7 * b13;
      t18 += v7 * b14;
      t19 += v7 * b15;
      v7 = a9[5];
      t52 += v7 * b0;
      t62 += v7 * b1;
      t72 += v7 * b22;
      t8 += v7 * b32;
      t9 += v7 * b42;
      t10 += v7 * b52;
      t11 += v7 * b62;
      t12 += v7 * b72;
      t13 += v7 * b82;
      t14 += v7 * b92;
      t15 += v7 * b102;
      t16 += v7 * b11;
      t17 += v7 * b12;
      t18 += v7 * b13;
      t19 += v7 * b14;
      t20 += v7 * b15;
      v7 = a9[6];
      t62 += v7 * b0;
      t72 += v7 * b1;
      t8 += v7 * b22;
      t9 += v7 * b32;
      t10 += v7 * b42;
      t11 += v7 * b52;
      t12 += v7 * b62;
      t13 += v7 * b72;
      t14 += v7 * b82;
      t15 += v7 * b92;
      t16 += v7 * b102;
      t17 += v7 * b11;
      t18 += v7 * b12;
      t19 += v7 * b13;
      t20 += v7 * b14;
      t21 += v7 * b15;
      v7 = a9[7];
      t72 += v7 * b0;
      t8 += v7 * b1;
      t9 += v7 * b22;
      t10 += v7 * b32;
      t11 += v7 * b42;
      t12 += v7 * b52;
      t13 += v7 * b62;
      t14 += v7 * b72;
      t15 += v7 * b82;
      t16 += v7 * b92;
      t17 += v7 * b102;
      t18 += v7 * b11;
      t19 += v7 * b12;
      t20 += v7 * b13;
      t21 += v7 * b14;
      t222 += v7 * b15;
      v7 = a9[8];
      t8 += v7 * b0;
      t9 += v7 * b1;
      t10 += v7 * b22;
      t11 += v7 * b32;
      t12 += v7 * b42;
      t13 += v7 * b52;
      t14 += v7 * b62;
      t15 += v7 * b72;
      t16 += v7 * b82;
      t17 += v7 * b92;
      t18 += v7 * b102;
      t19 += v7 * b11;
      t20 += v7 * b12;
      t21 += v7 * b13;
      t222 += v7 * b14;
      t23 += v7 * b15;
      v7 = a9[9];
      t9 += v7 * b0;
      t10 += v7 * b1;
      t11 += v7 * b22;
      t12 += v7 * b32;
      t13 += v7 * b42;
      t14 += v7 * b52;
      t15 += v7 * b62;
      t16 += v7 * b72;
      t17 += v7 * b82;
      t18 += v7 * b92;
      t19 += v7 * b102;
      t20 += v7 * b11;
      t21 += v7 * b12;
      t222 += v7 * b13;
      t23 += v7 * b14;
      t24 += v7 * b15;
      v7 = a9[10];
      t10 += v7 * b0;
      t11 += v7 * b1;
      t12 += v7 * b22;
      t13 += v7 * b32;
      t14 += v7 * b42;
      t15 += v7 * b52;
      t16 += v7 * b62;
      t17 += v7 * b72;
      t18 += v7 * b82;
      t19 += v7 * b92;
      t20 += v7 * b102;
      t21 += v7 * b11;
      t222 += v7 * b12;
      t23 += v7 * b13;
      t24 += v7 * b14;
      t25 += v7 * b15;
      v7 = a9[11];
      t11 += v7 * b0;
      t12 += v7 * b1;
      t13 += v7 * b22;
      t14 += v7 * b32;
      t15 += v7 * b42;
      t16 += v7 * b52;
      t17 += v7 * b62;
      t18 += v7 * b72;
      t19 += v7 * b82;
      t20 += v7 * b92;
      t21 += v7 * b102;
      t222 += v7 * b11;
      t23 += v7 * b12;
      t24 += v7 * b13;
      t25 += v7 * b14;
      t26 += v7 * b15;
      v7 = a9[12];
      t12 += v7 * b0;
      t13 += v7 * b1;
      t14 += v7 * b22;
      t15 += v7 * b32;
      t16 += v7 * b42;
      t17 += v7 * b52;
      t18 += v7 * b62;
      t19 += v7 * b72;
      t20 += v7 * b82;
      t21 += v7 * b92;
      t222 += v7 * b102;
      t23 += v7 * b11;
      t24 += v7 * b12;
      t25 += v7 * b13;
      t26 += v7 * b14;
      t27 += v7 * b15;
      v7 = a9[13];
      t13 += v7 * b0;
      t14 += v7 * b1;
      t15 += v7 * b22;
      t16 += v7 * b32;
      t17 += v7 * b42;
      t18 += v7 * b52;
      t19 += v7 * b62;
      t20 += v7 * b72;
      t21 += v7 * b82;
      t222 += v7 * b92;
      t23 += v7 * b102;
      t24 += v7 * b11;
      t25 += v7 * b12;
      t26 += v7 * b13;
      t27 += v7 * b14;
      t28 += v7 * b15;
      v7 = a9[14];
      t14 += v7 * b0;
      t15 += v7 * b1;
      t16 += v7 * b22;
      t17 += v7 * b32;
      t18 += v7 * b42;
      t19 += v7 * b52;
      t20 += v7 * b62;
      t21 += v7 * b72;
      t222 += v7 * b82;
      t23 += v7 * b92;
      t24 += v7 * b102;
      t25 += v7 * b11;
      t26 += v7 * b12;
      t27 += v7 * b13;
      t28 += v7 * b14;
      t29 += v7 * b15;
      v7 = a9[15];
      t15 += v7 * b0;
      t16 += v7 * b1;
      t17 += v7 * b22;
      t18 += v7 * b32;
      t19 += v7 * b42;
      t20 += v7 * b52;
      t21 += v7 * b62;
      t222 += v7 * b72;
      t23 += v7 * b82;
      t24 += v7 * b92;
      t25 += v7 * b102;
      t26 += v7 * b11;
      t27 += v7 * b12;
      t28 += v7 * b13;
      t29 += v7 * b14;
      t30 += v7 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t22 += 38 * t18;
      t32 += 38 * t19;
      t42 += 38 * t20;
      t52 += 38 * t21;
      t62 += 38 * t222;
      t72 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c8 = 1;
      v7 = t0 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t0 = v7 - c8 * 65536;
      v7 = t1 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t1 = v7 - c8 * 65536;
      v7 = t22 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t22 = v7 - c8 * 65536;
      v7 = t32 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t32 = v7 - c8 * 65536;
      v7 = t42 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t42 = v7 - c8 * 65536;
      v7 = t52 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t52 = v7 - c8 * 65536;
      v7 = t62 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t62 = v7 - c8 * 65536;
      v7 = t72 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t72 = v7 - c8 * 65536;
      v7 = t8 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t8 = v7 - c8 * 65536;
      v7 = t9 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t9 = v7 - c8 * 65536;
      v7 = t10 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t10 = v7 - c8 * 65536;
      v7 = t11 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t11 = v7 - c8 * 65536;
      v7 = t12 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t12 = v7 - c8 * 65536;
      v7 = t13 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t13 = v7 - c8 * 65536;
      v7 = t14 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t14 = v7 - c8 * 65536;
      v7 = t15 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t15 = v7 - c8 * 65536;
      t0 += c8 - 1 + 37 * (c8 - 1);
      c8 = 1;
      v7 = t0 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t0 = v7 - c8 * 65536;
      v7 = t1 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t1 = v7 - c8 * 65536;
      v7 = t22 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t22 = v7 - c8 * 65536;
      v7 = t32 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t32 = v7 - c8 * 65536;
      v7 = t42 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t42 = v7 - c8 * 65536;
      v7 = t52 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t52 = v7 - c8 * 65536;
      v7 = t62 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t62 = v7 - c8 * 65536;
      v7 = t72 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t72 = v7 - c8 * 65536;
      v7 = t8 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t8 = v7 - c8 * 65536;
      v7 = t9 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t9 = v7 - c8 * 65536;
      v7 = t10 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t10 = v7 - c8 * 65536;
      v7 = t11 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t11 = v7 - c8 * 65536;
      v7 = t12 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t12 = v7 - c8 * 65536;
      v7 = t13 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t13 = v7 - c8 * 65536;
      v7 = t14 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t14 = v7 - c8 * 65536;
      v7 = t15 + c8 + 65535;
      c8 = Math.floor(v7 / 65536);
      t15 = v7 - c8 * 65536;
      t0 += c8 - 1 + 37 * (c8 - 1);
      o11[0] = t0;
      o11[1] = t1;
      o11[2] = t22;
      o11[3] = t32;
      o11[4] = t42;
      o11[5] = t52;
      o11[6] = t62;
      o11[7] = t72;
      o11[8] = t8;
      o11[9] = t9;
      o11[10] = t10;
      o11[11] = t11;
      o11[12] = t12;
      o11[13] = t13;
      o11[14] = t14;
      o11[15] = t15;
    }
    function square(o11, a9) {
      mul(o11, a9, a9);
    }
    function inv25519(o11, i10) {
      const c8 = gf();
      let a9;
      for (a9 = 0; a9 < 16; a9++) {
        c8[a9] = i10[a9];
      }
      for (a9 = 253; a9 >= 0; a9--) {
        square(c8, c8);
        if (a9 !== 2 && a9 !== 4) {
          mul(c8, c8, i10);
        }
      }
      for (a9 = 0; a9 < 16; a9++) {
        o11[a9] = c8[a9];
      }
    }
    function pow2523(o11, i10) {
      const c8 = gf();
      let a9;
      for (a9 = 0; a9 < 16; a9++) {
        c8[a9] = i10[a9];
      }
      for (a9 = 250; a9 >= 0; a9--) {
        square(c8, c8);
        if (a9 !== 1) {
          mul(c8, c8, i10);
        }
      }
      for (a9 = 0; a9 < 16; a9++) {
        o11[a9] = c8[a9];
      }
    }
    function edadd(p10, q8) {
      const a9 = gf(), b10 = gf(), c8 = gf(), d9 = gf(), e11 = gf(), f7 = gf(), g9 = gf(), h11 = gf(), t8 = gf();
      sub(a9, p10[1], p10[0]);
      sub(t8, q8[1], q8[0]);
      mul(a9, a9, t8);
      add(b10, p10[0], p10[1]);
      add(t8, q8[0], q8[1]);
      mul(b10, b10, t8);
      mul(c8, p10[3], q8[3]);
      mul(c8, c8, D22);
      mul(d9, p10[2], q8[2]);
      add(d9, d9, d9);
      sub(e11, b10, a9);
      sub(f7, d9, c8);
      add(g9, d9, c8);
      add(h11, b10, a9);
      mul(p10[0], e11, f7);
      mul(p10[1], h11, g9);
      mul(p10[2], g9, f7);
      mul(p10[3], e11, h11);
    }
    function cswap(p10, q8, b10) {
      for (let i10 = 0; i10 < 4; i10++) {
        sel25519(p10[i10], q8[i10], b10);
      }
    }
    function pack(r7, p10) {
      const tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p10[2]);
      mul(tx, p10[0], zi2);
      mul(ty, p10[1], zi2);
      pack25519(r7, ty);
      r7[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p10, q8, s11) {
      set25519(p10[0], gf0);
      set25519(p10[1], gf1);
      set25519(p10[2], gf1);
      set25519(p10[3], gf0);
      for (let i10 = 255; i10 >= 0; --i10) {
        const b10 = s11[i10 / 8 | 0] >> (i10 & 7) & 1;
        cswap(p10, q8, b10);
        edadd(q8, p10);
        edadd(p10, p10);
        cswap(p10, q8, b10);
      }
    }
    function scalarbase(p10, s11) {
      const q8 = [gf(), gf(), gf(), gf()];
      set25519(q8[0], X6);
      set25519(q8[1], Y7);
      set25519(q8[2], gf1);
      mul(q8[3], X6, Y7);
      scalarmult(p10, q8, s11);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d9 = (0, sha512_1.hash)(seed);
      d9[0] &= 248;
      d9[31] &= 127;
      d9[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p10 = [gf(), gf(), gf(), gf()];
      scalarbase(p10, d9);
      pack(publicKey, p10);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L7 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r7, x8) {
      let carry;
      let i10;
      let j8;
      let k8;
      for (i10 = 63; i10 >= 32; --i10) {
        carry = 0;
        for (j8 = i10 - 32, k8 = i10 - 12; j8 < k8; ++j8) {
          x8[j8] += carry - 16 * x8[i10] * L7[j8 - (i10 - 32)];
          carry = Math.floor((x8[j8] + 128) / 256);
          x8[j8] -= carry * 256;
        }
        x8[j8] += carry;
        x8[i10] = 0;
      }
      carry = 0;
      for (j8 = 0; j8 < 32; j8++) {
        x8[j8] += carry - (x8[31] >> 4) * L7[j8];
        carry = x8[j8] >> 8;
        x8[j8] &= 255;
      }
      for (j8 = 0; j8 < 32; j8++) {
        x8[j8] -= carry * L7[j8];
      }
      for (i10 = 0; i10 < 32; i10++) {
        x8[i10 + 1] += x8[i10] >> 8;
        r7[i10] = x8[i10] & 255;
      }
    }
    function reduce(r7) {
      const x8 = new Float64Array(64);
      for (let i10 = 0; i10 < 64; i10++) {
        x8[i10] = r7[i10];
      }
      for (let i10 = 0; i10 < 64; i10++) {
        r7[i10] = 0;
      }
      modL(r7, x8);
    }
    function sign2(secretKey, message) {
      const x8 = new Float64Array(64);
      const p10 = [gf(), gf(), gf(), gf()];
      const d9 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d9[0] &= 248;
      d9[31] &= 127;
      d9[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d9.subarray(32), 32);
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(32));
      hs2.update(message);
      const r7 = hs2.digest();
      hs2.clean();
      reduce(r7);
      scalarbase(p10, r7);
      pack(signature, p10);
      hs2.reset();
      hs2.update(signature.subarray(0, 32));
      hs2.update(secretKey.subarray(32));
      hs2.update(message);
      const h11 = hs2.digest();
      reduce(h11);
      for (let i10 = 0; i10 < 32; i10++) {
        x8[i10] = r7[i10];
      }
      for (let i10 = 0; i10 < 32; i10++) {
        for (let j8 = 0; j8 < 32; j8++) {
          x8[i10 + j8] += h11[i10] * d9[j8];
        }
      }
      modL(signature.subarray(32), x8);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r7, p10) {
      const t8 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r7[2], gf1);
      unpack25519(r7[1], p10);
      square(num, r7[1]);
      mul(den, num, D7);
      sub(num, num, r7[2]);
      add(den, r7[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t8, den6, num);
      mul(t8, t8, den);
      pow2523(t8, t8);
      mul(t8, t8, num);
      mul(t8, t8, den);
      mul(t8, t8, den);
      mul(r7[0], t8, den);
      square(chk, r7[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r7[0], r7[0], I9);
      }
      square(chk, r7[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r7[0]) === p10[31] >> 7) {
        sub(r7[0], gf0, r7[0]);
      }
      mul(r7[3], r7[0], r7[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t8 = new Uint8Array(32);
      const p10 = [gf(), gf(), gf(), gf()];
      const q8 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q8, publicKey)) {
        return false;
      }
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(0, 32));
      hs2.update(publicKey);
      hs2.update(message);
      const h11 = hs2.digest();
      reduce(h11);
      scalarmult(p10, q8, h11);
      scalarbase(q8, signature.subarray(32));
      edadd(p10, q8);
      pack(t8, p10);
      if (verify32(signature, t8)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q8 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q8, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a9 = gf();
      let b10 = gf();
      let y10 = q8[1];
      add(a9, gf1, y10);
      sub(b10, gf1, y10);
      inv25519(b10, b10);
      mul(a9, a9, b10);
      let z8 = new Uint8Array(32);
      pack25519(z8, a9);
      return z8;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d9 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d9[0] &= 248;
      d9[31] &= 127;
      d9[31] |= 64;
      const o11 = new Uint8Array(d9.subarray(0, 32));
      (0, wipe_1.wipe)(d9);
      return o11;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, JWT_DELIMITER, JWT_ENCODING, JSON_ENCODING, DATA_ENCODING, DID_DELIMITER, DID_PREFIX, DID_METHOD, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_HEADER, KEY_PAIR_SEED_LENGTH;
var init_constants = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/constants.js"() {
    JWT_IRIDIUM_ALG = "EdDSA";
    JWT_IRIDIUM_TYP = "JWT";
    JWT_DELIMITER = ".";
    JWT_ENCODING = "base64url";
    JSON_ENCODING = "utf8";
    DATA_ENCODING = "utf8";
    DID_DELIMITER = ":";
    DID_PREFIX = "did";
    DID_METHOD = "key";
    MULTICODEC_ED25519_ENCODING = "base58btc";
    MULTICODEC_ED25519_BASE = "z";
    MULTICODEC_ED25519_HEADER = "K36";
    KEY_PAIR_SEED_LENGTH = 32;
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/utils.js
function encodeJSON(val) {
  return toString2(fromString2(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString2(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString2(concat4([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString2(bytes, JWT_ENCODING);
}
function encodeData(params) {
  return fromString2([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
var init_utils = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/utils.js"() {
    init_concat();
    init_to_string();
    init_from_string();
    init_esm3();
    init_constants();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair2(seed = (0, import_random4.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time2.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data2 = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data2);
  return encodeJWT({ header, payload, signature });
}
var ed25519, import_random4, import_time2;
var init_api = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/api.js"() {
    ed25519 = __toESM(require_ed25519());
    import_random4 = __toESM(require_random());
    import_time2 = __toESM(require_cjs());
    init_constants();
    init_utils();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/types.js
var init_types2 = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/types.js"() {
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/index.js"() {
    init_api();
    init_constants();
    init_types2();
    init_utils();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
var init_constants2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
    PARSE_ERROR = "PARSE_ERROR";
    INVALID_REQUEST = "INVALID_REQUEST";
    METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    INVALID_PARAMS = "INVALID_PARAMS";
    INTERNAL_ERROR = "INTERNAL_ERROR";
    SERVER_ERROR = "SERVER_ERROR";
    RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    STANDARD_ERROR_MAP = {
      [PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
    DEFAULT_ERROR = SERVER_ERROR;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e11) => e11.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e11, url, type) {
  return e11.message.includes("getaddrinfo ENOTFOUND") || e11.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e11;
}
var init_error = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
    init_constants2();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative2() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative2;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser3() {
      return !isReactNative2() && !isNode3();
    }
    exports.isBrowser = isBrowser3;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment, isNodeJs;
var init_env = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
    import_environment = __toESM(require_cjs7());
    __reExport(env_exports, __toESM(require_cjs7()));
    isNodeJs = import_environment.isNode;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error, data2) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data2)
  };
}
function formatErrorMessage(error, data2) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data2 !== "undefined") {
    error.data = data2;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
var init_format = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
    init_error();
    init_constants2();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x8) => x8.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}
var init_routing = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
var init_jsonrpc2 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents2;
var init_misc2 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js"() {
    IEvents2 = class {
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection, IBaseJsonRpcProvider, IJsonRpcProvider;
var init_provider = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js"() {
    init_misc2();
    IJsonRpcConnection = class extends IEvents2 {
      constructor(opts) {
        super();
      }
    };
    IBaseJsonRpcProvider = class extends IEvents2 {
      constructor() {
        super();
      }
    };
    IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
var init_validator = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
var init_esm5 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js"() {
    init_jsonrpc2();
    init_misc2();
    init_provider();
    init_validator();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var init_types3 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
    init_esm5();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
var HTTP_REGEX, WS_REGEX;
var init_url = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
    HTTP_REGEX = "^https?:";
    WS_REGEX = "^wss?:";
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}
var init_validators2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents2,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var init_esm6 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
    init_constants2();
    init_error();
    init_env();
    __reExport(esm_exports2, env_exports);
    init_format();
    init_routing();
    init_types3();
    init_url();
    init_validators2();
  }
});

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_events3, JsonRpcProvider2;
var init_provider2 = __esm({
  "node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js"() {
    import_events3 = __toESM(require_events());
    init_esm6();
    JsonRpcProvider2 = class extends IJsonRpcProvider {
      constructor(connection) {
        super(connection);
        this.events = new import_events3.EventEmitter();
        this.hasRegisteredEventListeners = false;
        this.connection = this.setConnection(connection);
        if (this.connection.connected) {
          this.registerEventListeners();
        }
      }
      async connect(connection = this.connection) {
        await this.open(connection);
      }
      async disconnect() {
        await this.close();
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      async request(request, context) {
        return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
      }
      async requestStrict(request, context) {
        return new Promise(async (resolve, reject) => {
          if (!this.connection.connected) {
            try {
              await this.open();
            } catch (e11) {
              reject(e11);
            }
          }
          this.events.on(`${request.id}`, (response) => {
            if (isJsonRpcError(response)) {
              reject(response.error);
            } else {
              resolve(response.result);
            }
          });
          try {
            await this.connection.send(request, context);
          } catch (e11) {
            reject(e11);
          }
        });
      }
      setConnection(connection = this.connection) {
        return connection;
      }
      onPayload(payload) {
        this.events.emit("payload", payload);
        if (isJsonRpcResponse(payload)) {
          this.events.emit(`${payload.id}`, payload);
        } else {
          this.events.emit("message", {
            type: payload.method,
            data: payload.params
          });
        }
      }
      onClose(event) {
        if (event && event.code === 3e3) {
          this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
        }
        this.events.emit("disconnect");
      }
      async open(connection = this.connection) {
        if (this.connection === connection && this.connection.connected)
          return;
        if (this.connection.connected)
          this.close();
        if (typeof connection === "string") {
          await this.connection.open(connection);
          connection = this.connection;
        }
        this.connection = this.setConnection(connection);
        await this.connection.open();
        this.registerEventListeners();
        this.events.emit("connect");
      }
      async close() {
        await this.connection.close();
      }
      registerEventListeners() {
        if (this.hasRegisteredEventListeners)
          return;
        this.connection.on("payload", (payload) => this.onPayload(payload));
        this.connection.on("close", (event) => this.onClose(event));
        this.connection.on("error", (error) => this.events.emit("error", error));
        this.connection.on("register_error", (error) => this.onClose());
        this.hasRegisteredEventListeners = true;
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js
var init_esm7 = __esm({
  "node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js"() {
    init_provider2();
    init_provider2();
  }
});

// node_modules/ws/browser.js
var require_browser4 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
var import_events4, EVENT_EMITTER_MAX_LISTENERS_DEFAULT, resolveWebSocketImplementation, isBrowser, WS2, WsConnection, ws_default;
var init_ws = __esm({
  "node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js"() {
    import_events4 = __toESM(require_events());
    init_esm3();
    init_esm6();
    EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
    resolveWebSocketImplementation = () => {
      if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
        return global.WebSocket;
      }
      if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
        return window.WebSocket;
      }
      return require_browser4();
    };
    isBrowser = () => typeof window !== "undefined";
    WS2 = resolveWebSocketImplementation();
    WsConnection = class {
      constructor(url) {
        this.url = url;
        this.events = new import_events4.EventEmitter();
        this.registering = false;
        if (!isWsUrl(url)) {
          throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        this.url = url;
      }
      get connected() {
        return typeof this.socket !== "undefined";
      }
      get connecting() {
        return this.registering;
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      async open(url = this.url) {
        await this.register(url);
      }
      async close() {
        return new Promise((resolve, reject) => {
          if (typeof this.socket === "undefined") {
            reject(new Error("Connection already closed"));
            return;
          }
          this.socket.onclose = (event) => {
            this.onClose(event);
            resolve();
          };
          this.socket.close();
        });
      }
      async send(payload, context) {
        if (typeof this.socket === "undefined") {
          this.socket = await this.register();
        }
        try {
          this.socket.send(safeJsonStringify(payload));
        } catch (e11) {
          this.onError(payload.id, e11);
        }
      }
      register(url = this.url) {
        if (!isWsUrl(url)) {
          throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        if (this.registering) {
          const currentMaxListeners = this.events.getMaxListeners();
          if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
            this.events.setMaxListeners(currentMaxListeners + 1);
          }
          return new Promise((resolve, reject) => {
            this.events.once("register_error", (error) => {
              this.resetMaxListeners();
              reject(error);
            });
            this.events.once("open", () => {
              this.resetMaxListeners();
              if (typeof this.socket === "undefined") {
                return reject(new Error("WebSocket connection is missing or invalid"));
              }
              resolve(this.socket);
            });
          });
        }
        this.url = url;
        this.registering = true;
        return new Promise((resolve, reject) => {
          const opts = !(0, esm_exports2.isReactNative)() ? { rejectUnauthorized: !isLocalhostUrl(url) } : void 0;
          const socket = new WS2(url, [], opts);
          if (isBrowser()) {
            socket.onerror = (event) => {
              const errorEvent = event;
              reject(this.emitError(errorEvent.error));
            };
          } else {
            socket.on("error", (errorEvent) => {
              reject(this.emitError(errorEvent));
            });
          }
          socket.onopen = () => {
            this.onOpen(socket);
            resolve(socket);
          };
        });
      }
      onOpen(socket) {
        socket.onmessage = (event) => this.onPayload(event);
        socket.onclose = (event) => this.onClose(event);
        this.socket = socket;
        this.registering = false;
        this.events.emit("open");
      }
      onClose(event) {
        this.socket = void 0;
        this.registering = false;
        this.events.emit("close", event);
      }
      onPayload(e11) {
        if (typeof e11.data === "undefined")
          return;
        const payload = typeof e11.data === "string" ? safeJsonParse(e11.data) : e11.data;
        this.events.emit("payload", payload);
      }
      onError(id2, e11) {
        const error = this.parseError(e11);
        const message = error.message || error.toString();
        const payload = formatJsonRpcError(id2, message);
        this.events.emit("payload", payload);
      }
      parseError(e11, url = this.url) {
        return parseConnectionError(e11, url, "WS");
      }
      resetMaxListeners() {
        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
          this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
        }
      }
      emitError(errorEvent) {
        const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for URL: ${this.url}`));
        this.events.emit("register_error", error);
        return error;
      }
    };
    ws_default = WsConnection;
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var esm_default;
var init_esm8 = __esm({
  "node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js"() {
    init_ws();
    init_ws();
    esm_default = ws_default;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e11) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n8, iteratee) {
      var index = -1, result = Array(n8);
      while (++index < n8) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer3(object)) {
        if (!isBuffer3(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray3(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e11) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e11) {
        }
        try {
          return func + "";
        } catch (e11) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer3 = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray3 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
function vi(r7, e11) {
  if (r7.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t8 = new Uint8Array(256), i10 = 0; i10 < t8.length; i10++)
    t8[i10] = 255;
  for (var s11 = 0; s11 < r7.length; s11++) {
    var n8 = r7.charAt(s11), a9 = n8.charCodeAt(0);
    if (t8[a9] !== 255)
      throw new TypeError(n8 + " is ambiguous");
    t8[a9] = s11;
  }
  var o11 = r7.length, h11 = r7.charAt(0), d9 = Math.log(o11) / Math.log(256), l9 = Math.log(256) / Math.log(o11);
  function g9(u9) {
    if (u9 instanceof Uint8Array || (ArrayBuffer.isView(u9) ? u9 = new Uint8Array(u9.buffer, u9.byteOffset, u9.byteLength) : Array.isArray(u9) && (u9 = Uint8Array.from(u9))), !(u9 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u9.length === 0)
      return "";
    for (var y10 = 0, O8 = 0, E8 = 0, _8 = u9.length; E8 !== _8 && u9[E8] === 0; )
      E8++, y10++;
    for (var R5 = (_8 - E8) * l9 + 1 >>> 0, b10 = new Uint8Array(R5); E8 !== _8; ) {
      for (var S7 = u9[E8], x8 = 0, f7 = R5 - 1; (S7 !== 0 || x8 < O8) && f7 !== -1; f7--, x8++)
        S7 += 256 * b10[f7] >>> 0, b10[f7] = S7 % o11 >>> 0, S7 = S7 / o11 >>> 0;
      if (S7 !== 0)
        throw new Error("Non-zero carry");
      O8 = x8, E8++;
    }
    for (var T6 = R5 - O8; T6 !== R5 && b10[T6] === 0; )
      T6++;
    for (var K6 = h11.repeat(y10); T6 < R5; ++T6)
      K6 += r7.charAt(b10[T6]);
    return K6;
  }
  function U5(u9) {
    if (typeof u9 != "string")
      throw new TypeError("Expected String");
    if (u9.length === 0)
      return new Uint8Array();
    var y10 = 0;
    if (u9[y10] !== " ") {
      for (var O8 = 0, E8 = 0; u9[y10] === h11; )
        O8++, y10++;
      for (var _8 = (u9.length - y10) * d9 + 1 >>> 0, R5 = new Uint8Array(_8); u9[y10]; ) {
        var b10 = t8[u9.charCodeAt(y10)];
        if (b10 === 255)
          return;
        for (var S7 = 0, x8 = _8 - 1; (b10 !== 0 || S7 < E8) && x8 !== -1; x8--, S7++)
          b10 += o11 * R5[x8] >>> 0, R5[x8] = b10 % 256 >>> 0, b10 = b10 / 256 >>> 0;
        if (b10 !== 0)
          throw new Error("Non-zero carry");
        E8 = S7, y10++;
      }
      if (u9[y10] !== " ") {
        for (var f7 = _8 - E8; f7 !== _8 && R5[f7] === 0; )
          f7++;
        for (var T6 = new Uint8Array(O8 + (_8 - f7)), K6 = O8; f7 !== _8; )
          T6[K6++] = R5[f7++];
        return T6;
      }
    }
  }
  function J6(u9) {
    var y10 = U5(u9);
    if (y10)
      return y10;
    throw new Error(`Non-${e11} character`);
  }
  return { encode: g9, decodeUnsafe: U5, decode: J6 };
}
function gs(r7) {
  return r7.reduce((e11, t8) => (e11 += ls[t8], e11), "");
}
function ps(r7) {
  const e11 = [];
  for (const t8 of r7) {
    const i10 = ds[t8.codePointAt(0)];
    if (i10 === void 0)
      throw new Error(`Non-base256emoji character: ${t8}`);
    e11.push(i10);
  }
  return new Uint8Array(e11);
}
function Se2(r7, e11, t8) {
  e11 = e11 || [], t8 = t8 || 0;
  for (var i10 = t8; r7 >= fs; )
    e11[t8++] = r7 & 255 | Re2, r7 /= 128;
  for (; r7 & Es; )
    e11[t8++] = r7 & 255 | Re2, r7 >>>= 7;
  return e11[t8] = r7 | 0, Se2.bytes = t8 - i10 + 1, e11;
}
function se(r7, i10) {
  var t8 = 0, i10 = i10 || 0, s11 = 0, n8 = i10, a9, o11 = r7.length;
  do {
    if (n8 >= o11)
      throw se.bytes = 0, new RangeError("Could not decode varint");
    a9 = r7[n8++], t8 += s11 < 28 ? (a9 & Te2) << s11 : (a9 & Te2) * Math.pow(2, s11), s11 += 7;
  } while (a9 >= vs);
  return se.bytes = n8 - i10, t8;
}
function js(r7 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r7) : new Uint8Array(r7);
}
function Fe2(r7, e11, t8, i10) {
  return { name: r7, prefix: e11, encoder: { name: r7, prefix: e11, encode: t8 }, decoder: { decode: i10 } };
}
function qs(r7, e11 = "utf8") {
  const t8 = Vs[e11];
  if (!t8)
    throw new Error(`Unsupported encoding "${e11}"`);
  return (e11 === "utf8" || e11 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r7, "utf8") : t8.decoder.decode(`${t8.prefix}${r7}`);
}
var import_events5, import_pino, import_keyvaluestorage, import_heartbeat, import_logger21, import_time3, import_lodash, Ii, Ci, Ie2, _i, Ri, Si, Ti, Pi, Ce2, xi, q2, F2, Oi, Ai, p2, zi, Ni, Ui, Li, Fi, Mi, $i, Ki, ki, Bi, ji, Vi, qi, Gi, Yi, Ji, Hi, Xi, Wi, Zi, Qi, es, ts, is, ss, rs, ns, as, os, hs, cs, us, _e, ls, ds, Ds, ys, bs, Re2, ms, Es, fs, ws, vs, Te2, Is, Cs, _s, Rs, Ss, Ts, Ps, xs, Os, As, zs, Pe2, xe2, Oe2, re2, Ns, Ae, Us, ze2, Ls, Fs, Ms, Ne2, $s, Ue, Ks, ks, Bs, Le2, Me2, ne2, Vs, ae, $e2, G2, P2, Ke2, ke2, Be2, oe, je2, Ve2, qe2, Ge2, Ye2, Je, He2, Xe2, We2, he2, Ze2, D2, Qe2, M2, et2, tt2, it2, I2, st2, rt2, nt2, at2, ot2, N10, C2, ht2, ct2, ut2, m, lt2, dt2, gt2, pt2, Xs, Ws, Zs, Qs, er, Dt, tr, ir, yt2, $2, ce, bt, sr, mt2, rr, nr, Et2, ar, ft2, or2, wt, hr, cr, vt, It, Ct, _t, Rt, St, ur, Tt, lr, dr, Pt, xt, Y2, gr;
var init_index_es3 = __esm({
  "node_modules/@walletconnect/core/dist/index.es.js"() {
    import_events5 = __toESM(require_events());
    import_pino = __toESM(require_browser2());
    import_keyvaluestorage = __toESM(require_browser3());
    import_heartbeat = __toESM(require_cjs5());
    import_logger21 = __toESM(require_cjs6());
    init_index_es2();
    init_esm3();
    init_esm4();
    init_index_es();
    import_time3 = __toESM(require_cjs());
    init_esm7();
    init_esm6();
    init_esm8();
    import_lodash = __toESM(require_lodash());
    Ii = vi;
    Ci = Ii;
    Ie2 = (r7) => {
      if (r7 instanceof Uint8Array && r7.constructor.name === "Uint8Array")
        return r7;
      if (r7 instanceof ArrayBuffer)
        return new Uint8Array(r7);
      if (ArrayBuffer.isView(r7))
        return new Uint8Array(r7.buffer, r7.byteOffset, r7.byteLength);
      throw new Error("Unknown type, must be binary type");
    };
    _i = (r7) => new TextEncoder().encode(r7);
    Ri = (r7) => new TextDecoder().decode(r7);
    Si = class {
      constructor(e11, t8, i10) {
        this.name = e11, this.prefix = t8, this.baseEncode = i10;
      }
      encode(e11) {
        if (e11 instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e11)}`;
        throw Error("Unknown type, must be binary type");
      }
    };
    Ti = class {
      constructor(e11, t8, i10) {
        if (this.name = e11, this.prefix = t8, t8.codePointAt(0) === void 0)
          throw new Error("Invalid prefix character");
        this.prefixCodePoint = t8.codePointAt(0), this.baseDecode = i10;
      }
      decode(e11) {
        if (typeof e11 == "string") {
          if (e11.codePointAt(0) !== this.prefixCodePoint)
            throw Error(`Unable to decode multibase string ${JSON.stringify(e11)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(e11.slice(this.prefix.length));
        } else
          throw Error("Can only multibase decode strings");
      }
      or(e11) {
        return Ce2(this, e11);
      }
    };
    Pi = class {
      constructor(e11) {
        this.decoders = e11;
      }
      or(e11) {
        return Ce2(this, e11);
      }
      decode(e11) {
        const t8 = e11[0], i10 = this.decoders[t8];
        if (i10)
          return i10.decode(e11);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e11)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    };
    Ce2 = (r7, e11) => new Pi({ ...r7.decoders || { [r7.prefix]: r7 }, ...e11.decoders || { [e11.prefix]: e11 } });
    xi = class {
      constructor(e11, t8, i10, s11) {
        this.name = e11, this.prefix = t8, this.baseEncode = i10, this.baseDecode = s11, this.encoder = new Si(e11, t8, i10), this.decoder = new Ti(e11, t8, s11);
      }
      encode(e11) {
        return this.encoder.encode(e11);
      }
      decode(e11) {
        return this.decoder.decode(e11);
      }
    };
    q2 = ({ name: r7, prefix: e11, encode: t8, decode: i10 }) => new xi(r7, e11, t8, i10);
    F2 = ({ prefix: r7, name: e11, alphabet: t8 }) => {
      const { encode: i10, decode: s11 } = Ci(t8, e11);
      return q2({ prefix: r7, name: e11, encode: i10, decode: (n8) => Ie2(s11(n8)) });
    };
    Oi = (r7, e11, t8, i10) => {
      const s11 = {};
      for (let l9 = 0; l9 < e11.length; ++l9)
        s11[e11[l9]] = l9;
      let n8 = r7.length;
      for (; r7[n8 - 1] === "="; )
        --n8;
      const a9 = new Uint8Array(n8 * t8 / 8 | 0);
      let o11 = 0, h11 = 0, d9 = 0;
      for (let l9 = 0; l9 < n8; ++l9) {
        const g9 = s11[r7[l9]];
        if (g9 === void 0)
          throw new SyntaxError(`Non-${i10} character`);
        h11 = h11 << t8 | g9, o11 += t8, o11 >= 8 && (o11 -= 8, a9[d9++] = 255 & h11 >> o11);
      }
      if (o11 >= t8 || 255 & h11 << 8 - o11)
        throw new SyntaxError("Unexpected end of data");
      return a9;
    };
    Ai = (r7, e11, t8) => {
      const i10 = e11[e11.length - 1] === "=", s11 = (1 << t8) - 1;
      let n8 = "", a9 = 0, o11 = 0;
      for (let h11 = 0; h11 < r7.length; ++h11)
        for (o11 = o11 << 8 | r7[h11], a9 += 8; a9 > t8; )
          a9 -= t8, n8 += e11[s11 & o11 >> a9];
      if (a9 && (n8 += e11[s11 & o11 << t8 - a9]), i10)
        for (; n8.length * t8 & 7; )
          n8 += "=";
      return n8;
    };
    p2 = ({ name: r7, prefix: e11, bitsPerChar: t8, alphabet: i10 }) => q2({ prefix: e11, name: r7, encode(s11) {
      return Ai(s11, i10, t8);
    }, decode(s11) {
      return Oi(s11, i10, t8, r7);
    } });
    zi = q2({ prefix: "\0", name: "identity", encode: (r7) => Ri(r7), decode: (r7) => _i(r7) });
    Ni = Object.freeze({ __proto__: null, identity: zi });
    Ui = p2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
    Li = Object.freeze({ __proto__: null, base2: Ui });
    Fi = p2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
    Mi = Object.freeze({ __proto__: null, base8: Fi });
    $i = F2({ prefix: "9", name: "base10", alphabet: "0123456789" });
    Ki = Object.freeze({ __proto__: null, base10: $i });
    ki = p2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
    Bi = p2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
    ji = Object.freeze({ __proto__: null, base16: ki, base16upper: Bi });
    Vi = p2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
    qi = p2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
    Gi = p2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
    Yi = p2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
    Ji = p2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
    Hi = p2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
    Xi = p2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
    Wi = p2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
    Zi = p2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
    Qi = Object.freeze({ __proto__: null, base32: Vi, base32upper: qi, base32pad: Gi, base32padupper: Yi, base32hex: Ji, base32hexupper: Hi, base32hexpad: Xi, base32hexpadupper: Wi, base32z: Zi });
    es = F2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
    ts = F2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
    is = Object.freeze({ __proto__: null, base36: es, base36upper: ts });
    ss = F2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
    rs = F2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
    ns = Object.freeze({ __proto__: null, base58btc: ss, base58flickr: rs });
    as = p2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
    os = p2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
    hs = p2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
    cs = p2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
    us = Object.freeze({ __proto__: null, base64: as, base64pad: os, base64url: hs, base64urlpad: cs });
    _e = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    ls = _e.reduce((r7, e11, t8) => (r7[t8] = e11, r7), []);
    ds = _e.reduce((r7, e11, t8) => (r7[e11.codePointAt(0)] = t8, r7), []);
    Ds = q2({ prefix: "\u{1F680}", name: "base256emoji", encode: gs, decode: ps });
    ys = Object.freeze({ __proto__: null, base256emoji: Ds });
    bs = Se2;
    Re2 = 128;
    ms = 127;
    Es = ~ms;
    fs = Math.pow(2, 31);
    ws = se;
    vs = 128;
    Te2 = 127;
    Is = Math.pow(2, 7);
    Cs = Math.pow(2, 14);
    _s = Math.pow(2, 21);
    Rs = Math.pow(2, 28);
    Ss = Math.pow(2, 35);
    Ts = Math.pow(2, 42);
    Ps = Math.pow(2, 49);
    xs = Math.pow(2, 56);
    Os = Math.pow(2, 63);
    As = function(r7) {
      return r7 < Is ? 1 : r7 < Cs ? 2 : r7 < _s ? 3 : r7 < Rs ? 4 : r7 < Ss ? 5 : r7 < Ts ? 6 : r7 < Ps ? 7 : r7 < xs ? 8 : r7 < Os ? 9 : 10;
    };
    zs = { encode: bs, decode: ws, encodingLength: As };
    Pe2 = zs;
    xe2 = (r7, e11, t8 = 0) => (Pe2.encode(r7, e11, t8), e11);
    Oe2 = (r7) => Pe2.encodingLength(r7);
    re2 = (r7, e11) => {
      const t8 = e11.byteLength, i10 = Oe2(r7), s11 = i10 + Oe2(t8), n8 = new Uint8Array(s11 + t8);
      return xe2(r7, n8, 0), xe2(t8, n8, i10), n8.set(e11, s11), new Ns(r7, t8, e11, n8);
    };
    Ns = class {
      constructor(e11, t8, i10, s11) {
        this.code = e11, this.size = t8, this.digest = i10, this.bytes = s11;
      }
    };
    Ae = ({ name: r7, code: e11, encode: t8 }) => new Us(r7, e11, t8);
    Us = class {
      constructor(e11, t8, i10) {
        this.name = e11, this.code = t8, this.encode = i10;
      }
      digest(e11) {
        if (e11 instanceof Uint8Array) {
          const t8 = this.encode(e11);
          return t8 instanceof Uint8Array ? re2(this.code, t8) : t8.then((i10) => re2(this.code, i10));
        } else
          throw Error("Unknown type, must be binary type");
      }
    };
    ze2 = (r7) => async (e11) => new Uint8Array(await crypto.subtle.digest(r7, e11));
    Ls = Ae({ name: "sha2-256", code: 18, encode: ze2("SHA-256") });
    Fs = Ae({ name: "sha2-512", code: 19, encode: ze2("SHA-512") });
    Ms = Object.freeze({ __proto__: null, sha256: Ls, sha512: Fs });
    Ne2 = 0;
    $s = "identity";
    Ue = Ie2;
    Ks = (r7) => re2(Ne2, Ue(r7));
    ks = { code: Ne2, name: $s, encode: Ue, digest: Ks };
    Bs = Object.freeze({ __proto__: null, identity: ks });
    new TextEncoder(), new TextDecoder();
    Le2 = { ...Ni, ...Li, ...Mi, ...Ki, ...ji, ...Qi, ...is, ...ns, ...us, ...ys };
    ({ ...Ms, ...Bs });
    Me2 = Fe2("utf8", "u", (r7) => "u" + new TextDecoder("utf8").decode(r7), (r7) => new TextEncoder().encode(r7.substring(1)));
    ne2 = Fe2("ascii", "a", (r7) => {
      let e11 = "a";
      for (let t8 = 0; t8 < r7.length; t8++)
        e11 += String.fromCharCode(r7[t8]);
      return e11;
    }, (r7) => {
      r7 = r7.substring(1);
      const e11 = js(r7.length);
      for (let t8 = 0; t8 < r7.length; t8++)
        e11[t8] = r7.charCodeAt(t8);
      return e11;
    });
    Vs = { utf8: Me2, "utf-8": Me2, hex: Le2.base16, latin1: ne2, ascii: ne2, binary: ne2, ...Le2 };
    ae = "wc";
    $e2 = 2;
    G2 = "core";
    P2 = `${ae}@${2}:${G2}:`;
    Ke2 = { name: G2, logger: "error" };
    ke2 = { database: ":memory:" };
    Be2 = "crypto";
    oe = "client_ed25519_seed";
    je2 = import_time3.ONE_DAY;
    Ve2 = "keychain";
    qe2 = "0.3";
    Ge2 = "messages";
    Ye2 = "0.3";
    Je = import_time3.SIX_HOURS;
    He2 = "publisher";
    Xe2 = "irn";
    We2 = "error";
    he2 = "wss://relay.walletconnect.com";
    Ze2 = "relayer";
    D2 = { message: "relayer_message", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
    Qe2 = "_subscription";
    M2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
    et2 = import_time3.ONE_SECOND;
    tt2 = "2.5.2";
    it2 = "0.3";
    I2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
    st2 = "subscription";
    rt2 = "0.3";
    nt2 = import_time3.FIVE_SECONDS * 1e3;
    at2 = "pairing";
    ot2 = "0.3";
    N10 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
    C2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
    ht2 = "history";
    ct2 = "0.3";
    ut2 = "expirer";
    m = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
    lt2 = "0.3";
    dt2 = class {
      constructor(e11, t8) {
        this.core = e11, this.logger = t8, this.keychain = /* @__PURE__ */ new Map(), this.name = Ve2, this.version = qe2, this.initialized = false, this.storagePrefix = P2, this.init = async () => {
          if (!this.initialized) {
            const i10 = await this.getKeyChain();
            typeof i10 < "u" && (this.keychain = i10), this.initialized = true;
          }
        }, this.has = (i10) => (this.isInitialized(), this.keychain.has(i10)), this.set = async (i10, s11) => {
          this.isInitialized(), this.keychain.set(i10, s11), await this.persist();
        }, this.get = (i10) => {
          this.isInitialized();
          const s11 = this.keychain.get(i10);
          if (typeof s11 > "u") {
            const { message: n8 } = E("NO_MATCHING_KEY", `${this.name}: ${i10}`);
            throw new Error(n8);
          }
          return s11;
        }, this.del = async (i10) => {
          this.isInitialized(), this.keychain.delete(i10), await this.persist();
        }, this.core = e11, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name);
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      async setKeyChain(e11) {
        await this.core.storage.setItem(this.storageKey, _n(e11));
      }
      async getKeyChain() {
        const e11 = await this.core.storage.getItem(this.storageKey);
        return typeof e11 < "u" ? Cn(e11) : void 0;
      }
      async persist() {
        await this.setKeyChain(this.keychain);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    gt2 = class {
      constructor(e11, t8, i10) {
        this.core = e11, this.logger = t8, this.name = Be2, this.initialized = false, this.init = async () => {
          this.initialized || (await this.keychain.init(), this.initialized = true);
        }, this.hasKeys = (s11) => (this.isInitialized(), this.keychain.has(s11)), this.getClientId = async () => {
          this.isInitialized();
          const s11 = await this.getClientSeed(), n8 = generateKeyPair2(s11);
          return encodeIss(n8.publicKey);
        }, this.generateKeyPair = () => {
          this.isInitialized();
          const s11 = dn();
          return this.setPrivateKey(s11.publicKey, s11.privateKey);
        }, this.signJWT = async (s11) => {
          this.isInitialized();
          const n8 = await this.getClientSeed(), a9 = generateKeyPair2(n8), o11 = ln(), h11 = je2;
          return await signJWT(o11, s11, h11, a9);
        }, this.generateSharedKey = (s11, n8, a9) => {
          this.isInitialized();
          const o11 = this.getPrivateKey(s11), h11 = fn(o11, n8);
          return this.setSymKey(h11, a9);
        }, this.setSymKey = async (s11, n8) => {
          this.isInitialized();
          const a9 = n8 || pn(s11);
          return await this.keychain.set(a9, s11), a9;
        }, this.deleteKeyPair = async (s11) => {
          this.isInitialized(), await this.keychain.del(s11);
        }, this.deleteSymKey = async (s11) => {
          this.isInitialized(), await this.keychain.del(s11);
        }, this.encode = async (s11, n8, a9) => {
          this.isInitialized();
          const o11 = ye(a9), h11 = safeJsonStringify(n8);
          if (hn(o11)) {
            const U5 = o11.senderPublicKey, J6 = o11.receiverPublicKey;
            s11 = await this.generateSharedKey(U5, J6);
          }
          const d9 = this.getSymKey(s11), { type: l9, senderPublicKey: g9 } = o11;
          return yn({ type: l9, symKey: d9, message: h11, senderPublicKey: g9 });
        }, this.decode = async (s11, n8, a9) => {
          this.isInitialized();
          const o11 = gn(n8, a9);
          if (hn(o11)) {
            const l9 = o11.receiverPublicKey, g9 = o11.senderPublicKey;
            s11 = await this.generateSharedKey(l9, g9);
          }
          const h11 = this.getSymKey(s11), d9 = En({ symKey: h11, encoded: n8 });
          return safeJsonParse(d9);
        }, this.core = e11, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.keychain = i10 || new dt2(this.core, this.logger);
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      getPayloadType(e11) {
        const t8 = F(e11);
        return S(t8.type);
      }
      async setPrivateKey(e11, t8) {
        return await this.keychain.set(e11, t8), e11;
      }
      getPrivateKey(e11) {
        return this.keychain.get(e11);
      }
      async getClientSeed() {
        let e11 = "";
        try {
          e11 = this.keychain.get(oe);
        } catch {
          e11 = ln(), await this.keychain.set(oe, e11);
        }
        return qs(e11, "base16");
      }
      getSymKey(e11) {
        return this.keychain.get(e11);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    pt2 = class extends a {
      constructor(e11, t8) {
        super(e11, t8), this.logger = e11, this.core = t8, this.messages = /* @__PURE__ */ new Map(), this.name = Ge2, this.version = Ye2, this.initialized = false, this.storagePrefix = P2, this.init = async () => {
          if (!this.initialized) {
            this.logger.trace("Initialized");
            try {
              const i10 = await this.getRelayerMessages();
              typeof i10 < "u" && (this.messages = i10), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
            } catch (i10) {
              this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i10);
            } finally {
              this.initialized = true;
            }
          }
        }, this.set = async (i10, s11) => {
          this.isInitialized();
          const n8 = mn(s11);
          let a9 = this.messages.get(i10);
          return typeof a9 > "u" && (a9 = {}), typeof a9[n8] < "u" || (a9[n8] = s11, this.messages.set(i10, a9), await this.persist()), n8;
        }, this.get = (i10) => {
          this.isInitialized();
          let s11 = this.messages.get(i10);
          return typeof s11 > "u" && (s11 = {}), s11;
        }, this.has = (i10, s11) => {
          this.isInitialized();
          const n8 = this.get(i10), a9 = mn(s11);
          return typeof n8[a9] < "u";
        }, this.del = async (i10) => {
          this.isInitialized(), this.messages.delete(i10), await this.persist();
        }, this.logger = (0, import_logger21.generateChildLogger)(e11, this.name), this.core = t8;
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      async setRelayerMessages(e11) {
        await this.core.storage.setItem(this.storageKey, _n(e11));
      }
      async getRelayerMessages() {
        const e11 = await this.core.storage.getItem(this.storageKey);
        return typeof e11 < "u" ? Cn(e11) : void 0;
      }
      async persist() {
        await this.setRelayerMessages(this.messages);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    Xs = class extends u2 {
      constructor(e11, t8) {
        super(e11, t8), this.relayer = e11, this.logger = t8, this.events = new import_events5.EventEmitter(), this.name = He2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (i10, s11, n8) => {
          this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i10, message: s11, opts: n8 } });
          try {
            const a9 = n8?.ttl || Je, o11 = Hn(n8), h11 = n8?.prompt || false, d9 = n8?.tag || 0, l9 = { topic: i10, message: s11, opts: { ttl: a9, relay: o11, prompt: h11, tag: d9 } }, g9 = mn(s11);
            this.queue.set(g9, l9);
            try {
              await await Vn(this.rpcPublish(i10, s11, a9, o11, h11, d9), this.publishTimeout), this.relayer.events.emit(D2.publish, l9);
            } catch {
              this.logger.debug("Publishing Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
              return;
            }
            this.onPublish(g9, l9), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i10, message: s11, opts: n8 } });
          } catch (a9) {
            throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a9), a9;
          }
        }, this.on = (i10, s11) => {
          this.events.on(i10, s11);
        }, this.once = (i10, s11) => {
          this.events.once(i10, s11);
        }, this.off = (i10, s11) => {
          this.events.off(i10, s11);
        }, this.removeListener = (i10, s11) => {
          this.events.removeListener(i10, s11);
        }, this.relayer = e11, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.registerEventListeners();
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      rpcPublish(e11, t8, i10, s11, n8, a9) {
        var o11, h11, d9, l9;
        const g9 = { method: qn(s11.protocol).publish, params: { topic: e11, message: t8, ttl: i10, prompt: n8, tag: a9 } };
        return h((o11 = g9.params) == null ? void 0 : o11.prompt) && ((h11 = g9.params) == null || delete h11.prompt), h((d9 = g9.params) == null ? void 0 : d9.tag) && ((l9 = g9.params) == null || delete l9.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g9 }), this.relayer.request(g9);
      }
      onPublish(e11, t8) {
        this.queue.delete(e11);
      }
      checkQueue() {
        this.queue.forEach(async (e11) => {
          const { topic: t8, message: i10, opts: s11 } = e11;
          await this.publish(t8, i10, s11);
        });
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
          this.checkQueue();
        });
      }
    };
    Ws = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map(), this.set = (e11, t8) => {
          const i10 = this.get(e11);
          this.exists(e11, t8) || this.map.set(e11, [...i10, t8]);
        }, this.get = (e11) => this.map.get(e11) || [], this.exists = (e11, t8) => this.get(e11).includes(t8), this.delete = (e11, t8) => {
          if (typeof t8 > "u") {
            this.map.delete(e11);
            return;
          }
          if (!this.map.has(e11))
            return;
          const i10 = this.get(e11);
          if (!this.exists(e11, t8))
            return;
          const s11 = i10.filter((n8) => n8 !== t8);
          if (!s11.length) {
            this.map.delete(e11);
            return;
          }
          this.map.set(e11, s11);
        }, this.clear = () => {
          this.map.clear();
        };
      }
      get topics() {
        return Array.from(this.map.keys());
      }
    };
    Zs = Object.defineProperty;
    Qs = Object.defineProperties;
    er = Object.getOwnPropertyDescriptors;
    Dt = Object.getOwnPropertySymbols;
    tr = Object.prototype.hasOwnProperty;
    ir = Object.prototype.propertyIsEnumerable;
    yt2 = (r7, e11, t8) => e11 in r7 ? Zs(r7, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : r7[e11] = t8;
    $2 = (r7, e11) => {
      for (var t8 in e11 || (e11 = {}))
        tr.call(e11, t8) && yt2(r7, t8, e11[t8]);
      if (Dt)
        for (var t8 of Dt(e11))
          ir.call(e11, t8) && yt2(r7, t8, e11[t8]);
      return r7;
    };
    ce = (r7, e11) => Qs(r7, er(e11));
    bt = class extends x {
      constructor(e11, t8) {
        super(e11, t8), this.relayer = e11, this.logger = t8, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ws(), this.events = new import_events5.EventEmitter(), this.name = st2, this.version = rt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = P2, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
        }, this.subscribe = async (i10, s11) => {
          await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i10, opts: s11 } });
          try {
            const n8 = Hn(s11), a9 = { topic: i10, relay: n8 };
            this.pending.set(i10, a9);
            const o11 = await this.rpcSubscribe(i10, n8);
            return this.onSubscribe(o11, a9), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i10, opts: s11 } }), o11;
          } catch (n8) {
            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n8), n8;
          }
        }, this.unsubscribe = async (i10, s11) => {
          await this.restartToComplete(), this.isInitialized(), typeof s11?.id < "u" ? await this.unsubscribeById(i10, s11.id, s11) : await this.unsubscribeByTopic(i10, s11);
        }, this.isSubscribed = async (i10) => this.topics.includes(i10) ? true : await new Promise((s11, n8) => {
          const a9 = new import_time3.Watch();
          a9.start(this.pendingSubscriptionWatchLabel);
          const o11 = setInterval(() => {
            !this.pending.has(i10) && this.topics.includes(i10) && (clearInterval(o11), a9.stop(this.pendingSubscriptionWatchLabel), s11(true)), a9.elapsed(this.pendingSubscriptionWatchLabel) >= nt2 && (clearInterval(o11), a9.stop(this.pendingSubscriptionWatchLabel), n8(false));
          }, this.pollingInterval);
        }), this.on = (i10, s11) => {
          this.events.on(i10, s11);
        }, this.once = (i10, s11) => {
          this.events.once(i10, s11);
        }, this.off = (i10, s11) => {
          this.events.off(i10, s11);
        }, this.removeListener = (i10, s11) => {
          this.events.removeListener(i10, s11);
        }, this.restart = async () => {
          this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
        }, this.relayer = e11, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.clientId = "";
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      get length() {
        return this.subscriptions.size;
      }
      get ids() {
        return Array.from(this.subscriptions.keys());
      }
      get values() {
        return Array.from(this.subscriptions.values());
      }
      get topics() {
        return this.topicMap.topics;
      }
      hasSubscription(e11, t8) {
        let i10 = false;
        try {
          i10 = this.getSubscription(e11).topic === t8;
        } catch {
        }
        return i10;
      }
      onEnable() {
        this.cached = [], this.initialized = true;
      }
      onDisable() {
        this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
      }
      async unsubscribeByTopic(e11, t8) {
        const i10 = this.topicMap.get(e11);
        await Promise.all(i10.map(async (s11) => await this.unsubscribeById(e11, s11, t8)));
      }
      async unsubscribeById(e11, t8, i10) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e11, id: t8, opts: i10 } });
        try {
          const s11 = Hn(i10);
          await this.rpcUnsubscribe(e11, t8, s11);
          const n8 = v("USER_DISCONNECTED", `${this.name}, ${e11}`);
          await this.onUnsubscribe(e11, t8, n8), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e11, id: t8, opts: i10 } });
        } catch (s11) {
          throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s11), s11;
        }
      }
      async rpcSubscribe(e11, t8) {
        const i10 = { method: qn(t8.protocol).subscribe, params: { topic: e11 } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i10 });
        try {
          await await Vn(this.relayer.request(i10), this.subscribeTimeout);
        } catch {
          this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
        }
        return mn(e11 + this.clientId);
      }
      async rpcBatchSubscribe(e11) {
        if (!e11.length)
          return;
        const t8 = e11[0].relay, i10 = { method: qn(t8.protocol).batchSubscribe, params: { topics: e11.map((s11) => s11.topic) } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i10 });
        try {
          return await await Vn(this.relayer.request(i10), this.subscribeTimeout);
        } catch {
          this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
        }
      }
      rpcUnsubscribe(e11, t8, i10) {
        const s11 = { method: qn(i10.protocol).unsubscribe, params: { topic: e11, id: t8 } };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s11 }), this.relayer.request(s11);
      }
      onSubscribe(e11, t8) {
        this.setSubscription(e11, ce($2({}, t8), { id: e11 })), this.pending.delete(t8.topic);
      }
      onBatchSubscribe(e11) {
        e11.length && e11.forEach((t8) => {
          this.setSubscription(t8.id, $2({}, t8)), this.pending.delete(t8.topic);
        });
      }
      async onUnsubscribe(e11, t8, i10) {
        this.events.removeAllListeners(t8), this.hasSubscription(t8, e11) && this.deleteSubscription(t8, i10), await this.relayer.messages.del(e11);
      }
      async setRelayerSubscriptions(e11) {
        await this.relayer.core.storage.setItem(this.storageKey, e11);
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
      }
      setSubscription(e11, t8) {
        this.subscriptions.has(e11) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e11, subscription: t8 }), this.addSubscription(e11, t8));
      }
      addSubscription(e11, t8) {
        this.subscriptions.set(e11, $2({}, t8)), this.topicMap.set(t8.topic, e11), this.events.emit(I2.created, t8);
      }
      getSubscription(e11) {
        this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e11 });
        const t8 = this.subscriptions.get(e11);
        if (!t8) {
          const { message: i10 } = E("NO_MATCHING_KEY", `${this.name}: ${e11}`);
          throw new Error(i10);
        }
        return t8;
      }
      deleteSubscription(e11, t8) {
        this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e11, reason: t8 });
        const i10 = this.getSubscription(e11);
        this.subscriptions.delete(e11), this.topicMap.delete(i10.topic, e11), this.events.emit(I2.deleted, ce($2({}, i10), { reason: t8 }));
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(I2.sync);
      }
      async reset() {
        if (!this.cached.length)
          return;
        const e11 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
        for (let t8 = 0; t8 < e11; t8++) {
          const i10 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
          await this.batchSubscribe(i10);
        }
        this.events.emit(I2.resubscribed);
      }
      async restore() {
        try {
          const e11 = await this.getRelayerSubscriptions();
          if (typeof e11 > "u" || !e11.length)
            return;
          if (this.subscriptions.size) {
            const { message: t8 } = E("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t8), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t8);
          }
          this.cached = e11, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
        } catch (e11) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e11);
        }
      }
      async batchSubscribe(e11) {
        if (!e11.length)
          return;
        const t8 = await this.rpcBatchSubscribe(e11);
        I(t8) && this.onBatchSubscribe(t8.map((i10, s11) => ce($2({}, e11[s11]), { id: i10 })));
      }
      async onConnect() {
        this.restartInProgress || (await this.restart(), this.onEnable());
      }
      onDisconnect() {
        this.onDisable();
      }
      async checkPending() {
        if (this.relayer.transportExplicitlyClosed)
          return;
        const e11 = [];
        this.pending.forEach((t8) => {
          e11.push(t8);
        }), await this.batchSubscribe(e11);
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
          await this.checkPending();
        }), this.relayer.on(D2.connect, async () => {
          await this.onConnect();
        }), this.relayer.on(D2.disconnect, () => {
          this.onDisconnect();
        }), this.events.on(I2.created, async (e11) => {
          const t8 = I2.created;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, data: e11 }), await this.persist();
        }), this.events.on(I2.deleted, async (e11) => {
          const t8 = I2.deleted;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, data: e11 }), await this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
      async restartToComplete() {
        this.restartInProgress && await new Promise((e11) => {
          const t8 = setInterval(() => {
            this.restartInProgress || (clearInterval(t8), e11());
          }, this.pollingInterval);
        });
      }
    };
    sr = Object.defineProperty;
    mt2 = Object.getOwnPropertySymbols;
    rr = Object.prototype.hasOwnProperty;
    nr = Object.prototype.propertyIsEnumerable;
    Et2 = (r7, e11, t8) => e11 in r7 ? sr(r7, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : r7[e11] = t8;
    ar = (r7, e11) => {
      for (var t8 in e11 || (e11 = {}))
        rr.call(e11, t8) && Et2(r7, t8, e11[t8]);
      if (mt2)
        for (var t8 of mt2(e11))
          nr.call(e11, t8) && Et2(r7, t8, e11[t8]);
      return r7;
    };
    ft2 = class extends g2 {
      constructor(e11) {
        super(e11), this.protocol = "wc", this.version = 2, this.events = new import_events5.EventEmitter(), this.name = Ze2, this.transportExplicitlyClosed = false, this.initialized = false, this.reconnecting = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (t8) => {
          this.logger.debug("Publishing Request Payload");
          try {
            return await this.toEstablishConnection(), await this.provider.request(t8);
          } catch (i10) {
            throw this.logger.debug("Failed to Publish Request"), this.logger.error(i10), i10;
          }
        }, this.core = e11.core, this.logger = typeof e11.logger < "u" && typeof e11.logger != "string" ? (0, import_logger21.generateChildLogger)(e11.logger, this.name) : (0, import_pino.default)((0, import_logger21.getDefaultLoggerOptions)({ level: e11.logger || We2 })), this.messages = new pt2(this.logger, e11.core), this.subscriber = new bt(this, this.logger), this.publisher = new Xs(this, this.logger), this.relayUrl = e11?.relayUrl || he2, this.projectId = e11.projectId, this.provider = {};
      }
      async init() {
        this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = true;
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get connected() {
        return this.provider.connection.connected;
      }
      get connecting() {
        return this.provider.connection.connecting;
      }
      async publish(e11, t8, i10) {
        this.isInitialized(), await this.publisher.publish(e11, t8, i10), await this.recordMessageEvent({ topic: e11, message: t8, publishedAt: Date.now() });
      }
      async subscribe(e11, t8) {
        this.isInitialized();
        let i10 = "";
        return await Promise.all([new Promise((s11) => {
          this.subscriber.once(I2.created, (n8) => {
            n8.topic === e11 && s11();
          });
        }), new Promise(async (s11) => {
          i10 = await this.subscriber.subscribe(e11, t8), s11();
        })]), i10;
      }
      async unsubscribe(e11, t8) {
        this.isInitialized(), await this.subscriber.unsubscribe(e11, t8);
      }
      on(e11, t8) {
        this.events.on(e11, t8);
      }
      once(e11, t8) {
        this.events.once(e11, t8);
      }
      off(e11, t8) {
        this.events.off(e11, t8);
      }
      removeListener(e11, t8) {
        this.events.removeListener(e11, t8);
      }
      async transportClose() {
        this.transportExplicitlyClosed = true, this.connected && (await this.provider.disconnect(), this.events.emit(D2.transport_closed));
      }
      async transportOpen(e11) {
        if (!this.reconnecting) {
          this.relayUrl = e11 || this.relayUrl, this.transportExplicitlyClosed = false, this.reconnecting = true;
          try {
            await Promise.all([new Promise((t8) => {
              this.initialized || t8(), this.subscriber.once(I2.resubscribed, () => {
                t8();
              });
            }), await Promise.race([new Promise(async (t8, i10) => {
              await Vn(this.provider.connect(), 5e3, "socket stalled").catch((s11) => i10(s11)).then(() => t8()).finally(() => this.removeListener(D2.transport_closed, this.rejectTransportOpen));
            }), new Promise((t8) => this.once(D2.transport_closed, this.rejectTransportOpen))])]);
          } catch (t8) {
            this.logger.error(t8);
            const i10 = t8;
            if (!this.isConnectionStalled(i10.message))
              throw t8;
            this.events.emit(D2.transport_closed);
          } finally {
            this.reconnecting = false;
          }
        }
      }
      async restartTransport(e11) {
        this.transportExplicitlyClosed || (this.relayUrl = e11 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
      }
      isConnectionStalled(e11) {
        return this.staleConnectionErrors.some((t8) => e11.includes(t8));
      }
      rejectTransportOpen() {
        throw new Error("closeTransport called before connection was established");
      }
      async createProvider() {
        const e11 = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new JsonRpcProvider2(new esm_default(Tn({ sdkVersion: tt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e11, useOnCloseEvent: true }))), this.registerProviderListeners();
      }
      async recordMessageEvent(e11) {
        const { topic: t8, message: i10 } = e11;
        await this.messages.set(t8, i10);
      }
      async shouldIgnoreMessageEvent(e11) {
        const { topic: t8, message: i10 } = e11;
        return await this.subscriber.isSubscribed(t8) ? this.messages.has(t8, i10) : true;
      }
      async onProviderPayload(e11) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e11 }), isJsonRpcRequest(e11)) {
          if (!e11.method.endsWith(Qe2))
            return;
          const t8 = e11.params, { topic: i10, message: s11, publishedAt: n8 } = t8.data, a9 = { topic: i10, message: s11, publishedAt: n8 };
          this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ar({ type: "event", event: t8.id }, a9)), this.events.emit(t8.id, a9), await this.acknowledgePayload(e11), await this.onMessageEvent(a9);
        }
      }
      async onMessageEvent(e11) {
        await this.shouldIgnoreMessageEvent(e11) || (this.events.emit(D2.message, e11), await this.recordMessageEvent(e11));
      }
      async acknowledgePayload(e11) {
        const t8 = formatJsonRpcResult(e11.id, true);
        await this.provider.connection.send(t8);
      }
      registerProviderListeners() {
        this.provider.on(M2.payload, (e11) => this.onProviderPayload(e11)), this.provider.on(M2.connect, () => {
          this.events.emit(D2.connect);
        }), this.provider.on(M2.disconnect, () => {
          this.onProviderDisconnect();
        }), this.provider.on(M2.error, (e11) => {
          this.logger.error(e11), this.events.emit(D2.error, e11);
        });
      }
      registerEventListeners() {
        this.events.on(D2.connection_stalled, async () => {
          await this.restartTransport();
        });
      }
      onProviderDisconnect() {
        this.events.emit(D2.disconnect), this.attemptToReconnect();
      }
      attemptToReconnect() {
        this.transportExplicitlyClosed || setTimeout(async () => {
          await this.restartTransport();
        }, (0, import_time3.toMiliseconds)(et2));
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
      async toEstablishConnection() {
        if (!this.connected) {
          if (this.connecting)
            return await new Promise((e11) => {
              const t8 = setInterval(() => {
                this.connected && (clearInterval(t8), e11());
              }, this.connectionStatusPollingInterval);
            });
          await this.restartTransport();
        }
      }
    };
    or2 = Object.defineProperty;
    wt = Object.getOwnPropertySymbols;
    hr = Object.prototype.hasOwnProperty;
    cr = Object.prototype.propertyIsEnumerable;
    vt = (r7, e11, t8) => e11 in r7 ? or2(r7, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : r7[e11] = t8;
    It = (r7, e11) => {
      for (var t8 in e11 || (e11 = {}))
        hr.call(e11, t8) && vt(r7, t8, e11[t8]);
      if (wt)
        for (var t8 of wt(e11))
          cr.call(e11, t8) && vt(r7, t8, e11[t8]);
      return r7;
    };
    Ct = class extends p {
      constructor(e11, t8, i10, s11 = P2, n8 = void 0) {
        super(e11, t8, i10, s11), this.core = e11, this.logger = t8, this.name = i10, this.map = /* @__PURE__ */ new Map(), this.version = it2, this.cached = [], this.initialized = false, this.storagePrefix = P2, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a9) => {
            this.getKey && a9 !== null && !h(a9) ? this.map.set(this.getKey(a9), a9) : tt(a9) ? this.map.set(a9.id, a9) : rt(a9) && this.map.set(a9.topic, a9);
          }), this.cached = [], this.initialized = true);
        }, this.set = async (a9, o11) => {
          this.isInitialized(), this.map.has(a9) ? await this.update(a9, o11) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a9, value: o11 }), this.map.set(a9, o11), await this.persist());
        }, this.get = (a9) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a9 }), this.getData(a9)), this.getAll = (a9) => (this.isInitialized(), a9 ? this.values.filter((o11) => Object.keys(a9).every((h11) => (0, import_lodash.default)(o11[h11], a9[h11]))) : this.values), this.update = async (a9, o11) => {
          this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a9, update: o11 });
          const h11 = It(It({}, this.getData(a9)), o11);
          this.map.set(a9, h11), await this.persist();
        }, this.delete = async (a9, o11) => {
          this.isInitialized(), this.map.has(a9) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a9, reason: o11 }), this.map.delete(a9), await this.persist());
        }, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.storagePrefix = s11, this.getKey = n8;
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      get length() {
        return this.map.size;
      }
      get keys() {
        return Array.from(this.map.keys());
      }
      get values() {
        return Array.from(this.map.values());
      }
      async setDataStore(e11) {
        await this.core.storage.setItem(this.storageKey, e11);
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getData(e11) {
        const t8 = this.map.get(e11);
        if (!t8) {
          const { message: i10 } = E("NO_MATCHING_KEY", `${this.name}: ${e11}`);
          throw this.logger.error(i10), new Error(i10);
        }
        return t8;
      }
      async persist() {
        await this.setDataStore(this.values);
      }
      async restore() {
        try {
          const e11 = await this.getDataStore();
          if (typeof e11 > "u" || !e11.length)
            return;
          if (this.map.size) {
            const { message: t8 } = E("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t8), new Error(t8);
          }
          this.cached = e11, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
        } catch (e11) {
          this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e11);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    _t = class {
      constructor(e11, t8) {
        this.core = e11, this.logger = t8, this.name = at2, this.version = ot2, this.events = new import_events5.default(), this.initialized = false, this.storagePrefix = P2, this.ignoredPayloadTypes = [b], this.registeredMethods = [], this.init = async () => {
          this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
        }, this.register = ({ methods: i10 }) => {
          this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i10])];
        }, this.create = async () => {
          this.isInitialized();
          const i10 = ln(), s11 = await this.core.crypto.setSymKey(i10), n8 = Ln(import_time3.FIVE_MINUTES), a9 = { protocol: Xe2 }, o11 = { topic: s11, expiry: n8, relay: a9, active: false }, h11 = Jn({ protocol: this.core.protocol, version: this.core.version, topic: s11, symKey: i10, relay: a9 });
          return await this.pairings.set(s11, o11), await this.core.relayer.subscribe(s11), this.core.expirer.set(s11, n8), { topic: s11, uri: h11 };
        }, this.pair = async (i10) => {
          this.isInitialized(), this.isValidPair(i10);
          const { topic: s11, symKey: n8, relay: a9 } = Wn(i10.uri);
          if (this.pairings.keys.includes(s11))
            throw new Error(`Pairing already exists: ${s11}`);
          if (this.core.crypto.hasKeys(s11))
            throw new Error(`Keychain already exists: ${s11}`);
          const o11 = Ln(import_time3.FIVE_MINUTES), h11 = { topic: s11, relay: a9, expiry: o11, active: false };
          return await this.pairings.set(s11, h11), await this.core.crypto.setSymKey(n8, s11), await this.core.relayer.subscribe(s11, { relay: a9 }), this.core.expirer.set(s11, o11), i10.activatePairing && await this.activate({ topic: s11 }), h11;
        }, this.activate = async ({ topic: i10 }) => {
          this.isInitialized();
          const s11 = Ln(import_time3.THIRTY_DAYS);
          await this.pairings.update(i10, { active: true, expiry: s11 }), this.core.expirer.set(i10, s11);
        }, this.ping = async (i10) => {
          this.isInitialized(), await this.isValidPing(i10);
          const { topic: s11 } = i10;
          if (this.pairings.keys.includes(s11)) {
            const n8 = await this.sendRequest(s11, "wc_pairingPing", {}), { done: a9, resolve: o11, reject: h11 } = jn();
            this.events.once(xn("pairing_ping", n8), ({ error: d9 }) => {
              d9 ? h11(d9) : o11();
            }), await a9();
          }
        }, this.updateExpiry = async ({ topic: i10, expiry: s11 }) => {
          this.isInitialized(), await this.pairings.update(i10, { expiry: s11 });
        }, this.updateMetadata = async ({ topic: i10, metadata: s11 }) => {
          this.isInitialized(), await this.pairings.update(i10, { peerMetadata: s11 });
        }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i10) => {
          this.isInitialized(), await this.isValidDisconnect(i10);
          const { topic: s11 } = i10;
          this.pairings.keys.includes(s11) && (await this.sendRequest(s11, "wc_pairingDelete", v("USER_DISCONNECTED")), await this.deletePairing(s11));
        }, this.sendRequest = async (i10, s11, n8) => {
          const a9 = formatJsonRpcRequest(s11, n8), o11 = await this.core.crypto.encode(i10, a9), h11 = N10[s11].req;
          return this.core.history.set(i10, a9), await this.core.relayer.publish(i10, o11, h11), a9.id;
        }, this.sendResult = async (i10, s11, n8) => {
          const a9 = formatJsonRpcResult(i10, n8), o11 = await this.core.crypto.encode(s11, a9), h11 = await this.core.history.get(s11, i10), d9 = N10[h11.request.method].res;
          await this.core.relayer.publish(s11, o11, d9), await this.core.history.resolve(a9);
        }, this.sendError = async (i10, s11, n8) => {
          const a9 = formatJsonRpcError(i10, n8), o11 = await this.core.crypto.encode(s11, a9), h11 = await this.core.history.get(s11, i10), d9 = N10[h11.request.method] ? N10[h11.request.method].res : N10.unregistered_method.res;
          await this.core.relayer.publish(s11, o11, d9), await this.core.history.resolve(a9);
        }, this.deletePairing = async (i10, s11) => {
          await this.core.relayer.unsubscribe(i10), await Promise.all([this.pairings.delete(i10, v("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i10), s11 ? Promise.resolve() : this.core.expirer.del(i10)]);
        }, this.cleanup = async () => {
          const i10 = this.pairings.getAll().filter((s11) => Fn(s11.expiry));
          await Promise.all(i10.map((s11) => this.deletePairing(s11.topic)));
        }, this.onRelayEventRequest = (i10) => {
          const { topic: s11, payload: n8 } = i10, a9 = n8.method;
          if (this.pairings.keys.includes(s11))
            switch (a9) {
              case "wc_pairingPing":
                return this.onPairingPingRequest(s11, n8);
              case "wc_pairingDelete":
                return this.onPairingDeleteRequest(s11, n8);
              default:
                return this.onUnknownRpcMethodRequest(s11, n8);
            }
        }, this.onRelayEventResponse = async (i10) => {
          const { topic: s11, payload: n8 } = i10, a9 = (await this.core.history.get(s11, n8.id)).request.method;
          if (this.pairings.keys.includes(s11))
            switch (a9) {
              case "wc_pairingPing":
                return this.onPairingPingResponse(s11, n8);
              default:
                return this.onUnknownRpcMethodResponse(a9);
            }
        }, this.onPairingPingRequest = async (i10, s11) => {
          const { id: n8 } = s11;
          try {
            this.isValidPing({ topic: i10 }), await this.sendResult(n8, i10, true), this.events.emit("pairing_ping", { id: n8, topic: i10 });
          } catch (a9) {
            await this.sendError(n8, i10, a9), this.logger.error(a9);
          }
        }, this.onPairingPingResponse = (i10, s11) => {
          const { id: n8 } = s11;
          setTimeout(() => {
            isJsonRpcResult(s11) ? this.events.emit(xn("pairing_ping", n8), {}) : isJsonRpcError(s11) && this.events.emit(xn("pairing_ping", n8), { error: s11.error });
          }, 500);
        }, this.onPairingDeleteRequest = async (i10, s11) => {
          const { id: n8 } = s11;
          try {
            this.isValidDisconnect({ topic: i10 }), await this.deletePairing(i10), this.events.emit("pairing_delete", { id: n8, topic: i10 });
          } catch (a9) {
            await this.sendError(n8, i10, a9), this.logger.error(a9);
          }
        }, this.onUnknownRpcMethodRequest = async (i10, s11) => {
          const { id: n8, method: a9 } = s11;
          try {
            if (this.registeredMethods.includes(a9))
              return;
            const o11 = v("WC_METHOD_UNSUPPORTED", a9);
            await this.sendError(n8, i10, o11), this.logger.error(o11);
          } catch (o11) {
            await this.sendError(n8, i10, o11), this.logger.error(o11);
          }
        }, this.onUnknownRpcMethodResponse = (i10) => {
          this.registeredMethods.includes(i10) || this.logger.error(v("WC_METHOD_UNSUPPORTED", i10));
        }, this.isValidPair = (i10) => {
          if (!at(i10)) {
            const { message: s11 } = E("MISSING_OR_INVALID", `pair() params: ${i10}`);
            throw new Error(s11);
          }
          if (!nt(i10.uri)) {
            const { message: s11 } = E("MISSING_OR_INVALID", `pair() uri: ${i10.uri}`);
            throw new Error(s11);
          }
        }, this.isValidPing = async (i10) => {
          if (!at(i10)) {
            const { message: n8 } = E("MISSING_OR_INVALID", `ping() params: ${i10}`);
            throw new Error(n8);
          }
          const { topic: s11 } = i10;
          await this.isValidPairingTopic(s11);
        }, this.isValidDisconnect = async (i10) => {
          if (!at(i10)) {
            const { message: n8 } = E("MISSING_OR_INVALID", `disconnect() params: ${i10}`);
            throw new Error(n8);
          }
          const { topic: s11 } = i10;
          await this.isValidPairingTopic(s11);
        }, this.isValidPairingTopic = async (i10) => {
          if (!d(i10, false)) {
            const { message: s11 } = E("MISSING_OR_INVALID", `pairing topic should be a string: ${i10}`);
            throw new Error(s11);
          }
          if (!this.pairings.keys.includes(i10)) {
            const { message: s11 } = E("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i10}`);
            throw new Error(s11);
          }
          if (Fn(this.pairings.get(i10).expiry)) {
            await this.deletePairing(i10);
            const { message: s11 } = E("EXPIRED", `pairing topic: ${i10}`);
            throw new Error(s11);
          }
        }, this.core = e11, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.pairings = new Ct(this.core, this.logger, this.name, this.storagePrefix);
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(D2.message, async (e11) => {
          const { topic: t8, message: i10 } = e11;
          if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i10)))
            return;
          const s11 = await this.core.crypto.decode(t8, i10);
          isJsonRpcRequest(s11) ? (this.core.history.set(t8, s11), this.onRelayEventRequest({ topic: t8, payload: s11 })) : isJsonRpcResponse(s11) && (await this.core.history.resolve(s11), this.onRelayEventResponse({ topic: t8, payload: s11 }));
        });
      }
      registerExpirerEvents() {
        this.core.expirer.on(m.expired, async (e11) => {
          const { topic: t8 } = kn(e11.target);
          t8 && this.pairings.keys.includes(t8) && (await this.deletePairing(t8, true), this.events.emit("pairing_expire", { topic: t8 }));
        });
      }
    };
    Rt = class extends h2 {
      constructor(e11, t8) {
        super(e11, t8), this.core = e11, this.logger = t8, this.records = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = ht2, this.version = ct2, this.cached = [], this.initialized = false, this.storagePrefix = P2, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i10) => this.records.set(i10.id, i10)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }, this.set = (i10, s11, n8) => {
          if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i10, request: s11, chainId: n8 }), this.records.has(s11.id))
            return;
          const a9 = { id: s11.id, topic: i10, request: { method: s11.method, params: s11.params || null }, chainId: n8 };
          this.records.set(a9.id, a9), this.events.emit(C2.created, a9);
        }, this.resolve = async (i10) => {
          if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i10 }), !this.records.has(i10.id))
            return;
          const s11 = await this.getRecord(i10.id);
          typeof s11.response > "u" && (s11.response = isJsonRpcError(i10) ? { error: i10.error } : { result: i10.result }, this.records.set(s11.id, s11), this.events.emit(C2.updated, s11));
        }, this.get = async (i10, s11) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i10, id: s11 }), await this.getRecord(s11)), this.delete = (i10, s11) => {
          this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s11 }), this.values.forEach((n8) => {
            if (n8.topic === i10) {
              if (typeof s11 < "u" && n8.id !== s11)
                return;
              this.records.delete(n8.id), this.events.emit(C2.deleted, n8);
            }
          });
        }, this.exists = async (i10, s11) => (this.isInitialized(), this.records.has(s11) ? (await this.getRecord(s11)).topic === i10 : false), this.on = (i10, s11) => {
          this.events.on(i10, s11);
        }, this.once = (i10, s11) => {
          this.events.once(i10, s11);
        }, this.off = (i10, s11) => {
          this.events.off(i10, s11);
        }, this.removeListener = (i10, s11) => {
          this.events.removeListener(i10, s11);
        }, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name);
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      get size() {
        return this.records.size;
      }
      get keys() {
        return Array.from(this.records.keys());
      }
      get values() {
        return Array.from(this.records.values());
      }
      get pending() {
        const e11 = [];
        return this.values.forEach((t8) => {
          if (typeof t8.response < "u")
            return;
          const i10 = { topic: t8.topic, request: formatJsonRpcRequest(t8.request.method, t8.request.params, t8.id), chainId: t8.chainId };
          return e11.push(i10);
        }), e11;
      }
      async setJsonRpcRecords(e11) {
        await this.core.storage.setItem(this.storageKey, e11);
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getRecord(e11) {
        this.isInitialized();
        const t8 = this.records.get(e11);
        if (!t8) {
          const { message: i10 } = E("NO_MATCHING_KEY", `${this.name}: ${e11}`);
          throw new Error(i10);
        }
        return t8;
      }
      async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(C2.sync);
      }
      async restore() {
        try {
          const e11 = await this.getJsonRpcRecords();
          if (typeof e11 > "u" || !e11.length)
            return;
          if (this.records.size) {
            const { message: t8 } = E("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t8), new Error(t8);
          }
          this.cached = e11, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
        } catch (e11) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e11);
        }
      }
      registerEventListeners() {
        this.events.on(C2.created, (e11) => {
          const t8 = C2.created;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, record: e11 }), this.persist();
        }), this.events.on(C2.updated, (e11) => {
          const t8 = C2.updated;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, record: e11 }), this.persist();
        }), this.events.on(C2.deleted, (e11) => {
          const t8 = C2.deleted;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, record: e11 }), this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    St = class extends E2 {
      constructor(e11, t8) {
        super(e11, t8), this.core = e11, this.logger = t8, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = ut2, this.version = lt2, this.cached = [], this.initialized = false, this.storagePrefix = P2, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i10) => this.expirations.set(i10.target, i10)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }, this.has = (i10) => {
          try {
            const s11 = this.formatTarget(i10);
            return typeof this.getExpiration(s11) < "u";
          } catch {
            return false;
          }
        }, this.set = (i10, s11) => {
          this.isInitialized();
          const n8 = this.formatTarget(i10), a9 = { target: n8, expiry: s11 };
          this.expirations.set(n8, a9), this.checkExpiry(n8, a9), this.events.emit(m.created, { target: n8, expiration: a9 });
        }, this.get = (i10) => {
          this.isInitialized();
          const s11 = this.formatTarget(i10);
          return this.getExpiration(s11);
        }, this.del = (i10) => {
          if (this.isInitialized(), this.has(i10)) {
            const s11 = this.formatTarget(i10), n8 = this.getExpiration(s11);
            this.expirations.delete(s11), this.events.emit(m.deleted, { target: s11, expiration: n8 });
          }
        }, this.on = (i10, s11) => {
          this.events.on(i10, s11);
        }, this.once = (i10, s11) => {
          this.events.once(i10, s11);
        }, this.off = (i10, s11) => {
          this.events.off(i10, s11);
        }, this.removeListener = (i10, s11) => {
          this.events.removeListener(i10, s11);
        }, this.logger = (0, import_logger21.generateChildLogger)(t8, this.name);
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
      get length() {
        return this.expirations.size;
      }
      get keys() {
        return Array.from(this.expirations.keys());
      }
      get values() {
        return Array.from(this.expirations.values());
      }
      formatTarget(e11) {
        if (typeof e11 == "string")
          return Mn(e11);
        if (typeof e11 == "number")
          return Kn(e11);
        const { message: t8 } = E("UNKNOWN_TYPE", `Target type: ${typeof e11}`);
        throw new Error(t8);
      }
      async setExpirations(e11) {
        await this.core.storage.setItem(this.storageKey, e11);
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
      }
      async persist() {
        await this.setExpirations(this.values), this.events.emit(m.sync);
      }
      async restore() {
        try {
          const e11 = await this.getExpirations();
          if (typeof e11 > "u" || !e11.length)
            return;
          if (this.expirations.size) {
            const { message: t8 } = E("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t8), new Error(t8);
          }
          this.cached = e11, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
        } catch (e11) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e11);
        }
      }
      getExpiration(e11) {
        const t8 = this.expirations.get(e11);
        if (!t8) {
          const { message: i10 } = E("NO_MATCHING_KEY", `${this.name}: ${e11}`);
          throw this.logger.error(i10), new Error(i10);
        }
        return t8;
      }
      checkExpiry(e11, t8) {
        const { expiry: i10 } = t8;
        (0, import_time3.toMiliseconds)(i10) - Date.now() <= 0 && this.expire(e11, t8);
      }
      expire(e11, t8) {
        this.expirations.delete(e11), this.events.emit(m.expired, { target: e11, expiration: t8 });
      }
      checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e11, t8) => this.checkExpiry(t8, e11));
      }
      registerEventListeners() {
        this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(m.created, (e11) => {
          const t8 = m.created;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, data: e11 }), this.persist();
        }), this.events.on(m.expired, (e11) => {
          const t8 = m.expired;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, data: e11 }), this.persist();
        }), this.events.on(m.deleted, (e11) => {
          const t8 = m.deleted;
          this.logger.info(`Emitting ${t8}`), this.logger.debug({ type: "event", event: t8, data: e11 }), this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e11 } = E("NOT_INITIALIZED", this.name);
          throw new Error(e11);
        }
      }
    };
    ur = Object.defineProperty;
    Tt = Object.getOwnPropertySymbols;
    lr = Object.prototype.hasOwnProperty;
    dr = Object.prototype.propertyIsEnumerable;
    Pt = (r7, e11, t8) => e11 in r7 ? ur(r7, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : r7[e11] = t8;
    xt = (r7, e11) => {
      for (var t8 in e11 || (e11 = {}))
        lr.call(e11, t8) && Pt(r7, t8, e11[t8]);
      if (Tt)
        for (var t8 of Tt(e11))
          dr.call(e11, t8) && Pt(r7, t8, e11[t8]);
      return r7;
    };
    Y2 = class extends n {
      constructor(e11) {
        super(e11), this.protocol = ae, this.version = $e2, this.name = G2, this.events = new import_events5.EventEmitter(), this.initialized = false, this.on = (i10, s11) => this.events.on(i10, s11), this.once = (i10, s11) => this.events.once(i10, s11), this.off = (i10, s11) => this.events.off(i10, s11), this.removeListener = (i10, s11) => this.events.removeListener(i10, s11), this.projectId = e11?.projectId, this.relayUrl = e11?.relayUrl || he2;
        const t8 = typeof e11?.logger < "u" && typeof e11?.logger != "string" ? e11.logger : (0, import_pino.default)((0, import_logger21.getDefaultLoggerOptions)({ level: e11?.logger || Ke2.logger }));
        this.logger = (0, import_logger21.generateChildLogger)(t8, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new gt2(this, this.logger, e11?.keychain), this.history = new Rt(this, this.logger), this.expirer = new St(this, this.logger), this.storage = e11 != null && e11.storage ? e11.storage : new import_keyvaluestorage.default(xt(xt({}, ke2), e11?.storageOptions)), this.relayer = new ft2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new _t(this, this.logger);
      }
      static async init(e11) {
        const t8 = new Y2(e11);
        return await t8.initialize(), t8;
      }
      get context() {
        return (0, import_logger21.getLoggerContext)(this.logger);
      }
      async start() {
        this.initialized || await this.initialize();
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
        } catch (e11) {
          throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e11), this.logger.error(e11.message), e11;
        }
      }
    };
    gr = Y2;
  }
});

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_pino2, import_logger22, import_events6, import_time4, k2, X2, J2, C3, G3, ee, se2, te2, b2, ie2, V, $3, ne3, Je2, He3, Fe3, oe2, Be3, Qe3, re3, u3, H3, We3, Ze3, es2, ss2, M3;
var init_index_es4 = __esm({
  "node_modules/@walletconnect/sign-client/dist/index.es.js"() {
    import_pino2 = __toESM(require_browser2());
    init_index_es3();
    import_logger22 = __toESM(require_cjs6());
    init_index_es2();
    init_index_es();
    import_events6 = __toESM(require_events());
    import_time4 = __toESM(require_cjs());
    init_esm6();
    k2 = "wc";
    X2 = 2;
    J2 = "client";
    C3 = `${k2}@${X2}:${J2}:`;
    G3 = { name: J2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
    ee = "proposal";
    se2 = "Proposal expired";
    te2 = "session";
    b2 = import_time4.SEVEN_DAYS;
    ie2 = "engine";
    V = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
    $3 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
    ne3 = "request";
    Je2 = Object.defineProperty;
    He3 = Object.defineProperties;
    Fe3 = Object.getOwnPropertyDescriptors;
    oe2 = Object.getOwnPropertySymbols;
    Be3 = Object.prototype.hasOwnProperty;
    Qe3 = Object.prototype.propertyIsEnumerable;
    re3 = (d9, n8, e11) => n8 in d9 ? Je2(d9, n8, { enumerable: true, configurable: true, writable: true, value: e11 }) : d9[n8] = e11;
    u3 = (d9, n8) => {
      for (var e11 in n8 || (n8 = {}))
        Be3.call(n8, e11) && re3(d9, e11, n8[e11]);
      if (oe2)
        for (var e11 of oe2(n8))
          Qe3.call(n8, e11) && re3(d9, e11, n8[e11]);
      return d9;
    };
    H3 = (d9, n8) => He3(d9, Fe3(n8));
    We3 = class extends C {
      constructor(n8) {
        super(n8), this.name = ie2, this.events = new import_events6.default(), this.initialized = false, this.ignoredPayloadTypes = [b], this.init = async () => {
          this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V) }), this.initialized = true);
        }, this.connect = async (e11) => {
          this.isInitialized();
          const s11 = H3(u3({}, e11), { requiredNamespaces: e11.requiredNamespaces || {}, optionalNamespaces: e11.optionalNamespaces || {} });
          await this.isValidConnect(s11);
          const { pairingTopic: t8, requiredNamespaces: i10, optionalNamespaces: o11, sessionProperties: r7, relays: a9 } = s11;
          let l9 = t8, h11, S7 = false;
          if (l9 && (S7 = this.client.core.pairing.pairings.get(l9).active), !l9 || !S7) {
            const { topic: I9, uri: g9 } = await this.client.core.pairing.create();
            l9 = I9, h11 = g9;
          }
          const m11 = await this.client.core.crypto.generateKeyPair(), P10 = u3({ requiredNamespaces: i10, optionalNamespaces: o11, relays: a9 ?? [{ protocol: Xe2 }], proposer: { publicKey: m11, metadata: this.client.metadata } }, r7 && { sessionProperties: r7 }), { reject: E8, resolve: T6, done: U5 } = jn(import_time4.FIVE_MINUTES, se2);
          if (this.events.once(xn("session_connect"), async ({ error: I9, session: g9 }) => {
            if (I9)
              E8(I9);
            else if (g9) {
              g9.self.publicKey = m11;
              const x8 = H3(u3({}, g9), { requiredNamespaces: g9.requiredNamespaces, optionalNamespaces: g9.optionalNamespaces });
              await this.client.session.set(g9.topic, x8), await this.setExpiry(g9.topic, g9.expiry), l9 && await this.client.core.pairing.updateMetadata({ topic: l9, metadata: g9.peer.metadata }), T6(x8);
            }
          }), !l9) {
            const { message: I9 } = E("NO_MATCHING_KEY", `connect() pairing topic: ${l9}`);
            throw new Error(I9);
          }
          const L7 = await this.sendRequest(l9, "wc_sessionPropose", P10), K6 = Ln(import_time4.FIVE_MINUTES);
          return await this.setProposal(L7, u3({ id: L7, expiry: K6 }, P10)), { uri: h11, approval: U5 };
        }, this.pair = async (e11) => (this.isInitialized(), await this.client.core.pairing.pair(e11)), this.approve = async (e11) => {
          this.isInitialized(), await this.isValidApprove(e11);
          const { id: s11, relayProtocol: t8, namespaces: i10, sessionProperties: o11 } = e11, r7 = this.client.proposal.get(s11);
          let { pairingTopic: a9, proposer: l9, requiredNamespaces: h11, optionalNamespaces: S7 } = r7;
          G(h11) || (h11 = Qn(i10, "approve()"));
          const m11 = await this.client.core.crypto.generateKeyPair(), P10 = l9.publicKey, E8 = await this.client.core.crypto.generateSharedKey(m11, P10);
          a9 && s11 && (await this.client.core.pairing.updateMetadata({ topic: a9, metadata: l9.metadata }), await this.sendResult(s11, a9, { relay: { protocol: t8 ?? "irn" }, responderPublicKey: m11 }), await this.client.proposal.delete(s11, v("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a9 }));
          const T6 = u3({ relay: { protocol: t8 ?? "irn" }, namespaces: i10, requiredNamespaces: h11, optionalNamespaces: S7, controller: { publicKey: m11, metadata: this.client.metadata }, expiry: Ln(b2) }, o11 && { sessionProperties: o11 });
          await this.client.core.relayer.subscribe(E8);
          const U5 = await this.sendRequest(E8, "wc_sessionSettle", T6), { done: L7, resolve: K6, reject: I9 } = jn();
          this.events.once(xn("session_approve", U5), ({ error: x8 }) => {
            x8 ? I9(x8) : K6(this.client.session.get(E8));
          });
          const g9 = H3(u3({}, T6), { topic: E8, acknowledged: false, self: T6.controller, peer: { publicKey: l9.publicKey, metadata: l9.metadata }, controller: m11 });
          return await this.client.session.set(E8, g9), await this.setExpiry(E8, Ln(b2)), { topic: E8, acknowledged: L7 };
        }, this.reject = async (e11) => {
          this.isInitialized(), await this.isValidReject(e11);
          const { id: s11, reason: t8 } = e11, { pairingTopic: i10 } = this.client.proposal.get(s11);
          i10 && (await this.sendError(s11, i10, t8), await this.client.proposal.delete(s11, v("USER_DISCONNECTED")));
        }, this.update = async (e11) => {
          this.isInitialized(), await this.isValidUpdate(e11);
          const { topic: s11, namespaces: t8 } = e11, i10 = await this.sendRequest(s11, "wc_sessionUpdate", { namespaces: t8 }), { done: o11, resolve: r7, reject: a9 } = jn();
          return this.events.once(xn("session_update", i10), ({ error: l9 }) => {
            l9 ? a9(l9) : r7();
          }), await this.client.session.update(s11, { namespaces: t8 }), { acknowledged: o11 };
        }, this.extend = async (e11) => {
          this.isInitialized(), await this.isValidExtend(e11);
          const { topic: s11 } = e11, t8 = await this.sendRequest(s11, "wc_sessionExtend", {}), { done: i10, resolve: o11, reject: r7 } = jn();
          return this.events.once(xn("session_extend", t8), ({ error: a9 }) => {
            a9 ? r7(a9) : o11();
          }), await this.setExpiry(s11, Ln(b2)), { acknowledged: i10 };
        }, this.request = async (e11) => {
          this.isInitialized(), await this.isValidRequest(e11);
          const { chainId: s11, request: t8, topic: i10, expiry: o11 } = e11, r7 = await this.sendRequest(i10, "wc_sessionRequest", { request: t8, chainId: s11 }, o11), { done: a9, resolve: l9, reject: h11 } = jn(o11);
          return this.events.once(xn("session_request", r7), ({ error: S7, result: m11 }) => {
            S7 ? h11(S7) : l9(m11);
          }), this.client.events.emit("session_request_sent", { topic: i10, request: t8, chainId: s11, id: r7 }), await a9();
        }, this.respond = async (e11) => {
          this.isInitialized(), await this.isValidRespond(e11);
          const { topic: s11, response: t8 } = e11, { id: i10 } = t8;
          isJsonRpcResult(t8) ? await this.sendResult(i10, s11, t8.result) : isJsonRpcError(t8) && await this.sendError(i10, s11, t8.error), this.deletePendingSessionRequest(e11.response.id, { message: "fulfilled", code: 0 });
        }, this.ping = async (e11) => {
          this.isInitialized(), await this.isValidPing(e11);
          const { topic: s11 } = e11;
          if (this.client.session.keys.includes(s11)) {
            const t8 = await this.sendRequest(s11, "wc_sessionPing", {}), { done: i10, resolve: o11, reject: r7 } = jn();
            this.events.once(xn("session_ping", t8), ({ error: a9 }) => {
              a9 ? r7(a9) : o11();
            }), await i10();
          } else
            this.client.core.pairing.pairings.keys.includes(s11) && await this.client.core.pairing.ping({ topic: s11 });
        }, this.emit = async (e11) => {
          this.isInitialized(), await this.isValidEmit(e11);
          const { topic: s11, event: t8, chainId: i10 } = e11;
          await this.sendRequest(s11, "wc_sessionEvent", { event: t8, chainId: i10 });
        }, this.disconnect = async (e11) => {
          this.isInitialized(), await this.isValidDisconnect(e11);
          const { topic: s11 } = e11;
          this.client.session.keys.includes(s11) ? (await this.sendRequest(s11, "wc_sessionDelete", v("USER_DISCONNECTED")), await this.deleteSession(s11)) : await this.client.core.pairing.disconnect({ topic: s11 });
        }, this.find = (e11) => (this.isInitialized(), this.client.session.getAll().filter((s11) => et(s11, e11))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.deleteSession = async (e11, s11) => {
          const { self: t8 } = this.client.session.get(e11);
          await this.client.core.relayer.unsubscribe(e11), await Promise.all([this.client.session.delete(e11, v("USER_DISCONNECTED")), this.client.core.crypto.deleteKeyPair(t8.publicKey), this.client.core.crypto.deleteSymKey(e11), s11 ? Promise.resolve() : this.client.core.expirer.del(e11)]);
        }, this.deleteProposal = async (e11, s11) => {
          await Promise.all([this.client.proposal.delete(e11, v("USER_DISCONNECTED")), s11 ? Promise.resolve() : this.client.core.expirer.del(e11)]);
        }, this.deletePendingSessionRequest = async (e11, s11, t8 = false) => {
          await Promise.all([this.client.pendingRequest.delete(e11, s11), t8 ? Promise.resolve() : this.client.core.expirer.del(e11)]);
        }, this.setExpiry = async (e11, s11) => {
          this.client.session.keys.includes(e11) && await this.client.session.update(e11, { expiry: s11 }), this.client.core.expirer.set(e11, s11);
        }, this.setProposal = async (e11, s11) => {
          await this.client.proposal.set(e11, s11), this.client.core.expirer.set(e11, s11.expiry);
        }, this.setPendingSessionRequest = async (e11) => {
          const s11 = V.wc_sessionRequest.req.ttl, { id: t8, topic: i10, params: o11 } = e11;
          await this.client.pendingRequest.set(t8, { id: t8, topic: i10, params: o11 }), s11 && this.client.core.expirer.set(t8, Ln(s11));
        }, this.sendRequest = async (e11, s11, t8, i10) => {
          const o11 = formatJsonRpcRequest(s11, t8), r7 = await this.client.core.crypto.encode(e11, o11), a9 = V[s11].req;
          return i10 && (a9.ttl = i10), this.client.core.history.set(e11, o11), this.client.core.relayer.publish(e11, r7, a9), o11.id;
        }, this.sendResult = async (e11, s11, t8) => {
          const i10 = formatJsonRpcResult(e11, t8), o11 = await this.client.core.crypto.encode(s11, i10), r7 = await this.client.core.history.get(s11, e11), a9 = V[r7.request.method].res;
          this.client.core.relayer.publish(s11, o11, a9), await this.client.core.history.resolve(i10);
        }, this.sendError = async (e11, s11, t8) => {
          const i10 = formatJsonRpcError(e11, t8), o11 = await this.client.core.crypto.encode(s11, i10), r7 = await this.client.core.history.get(s11, e11), a9 = V[r7.request.method].res;
          this.client.core.relayer.publish(s11, o11, a9), await this.client.core.history.resolve(i10);
        }, this.cleanup = async () => {
          const e11 = [], s11 = [];
          this.client.session.getAll().forEach((t8) => {
            Fn(t8.expiry) && e11.push(t8.topic);
          }), this.client.proposal.getAll().forEach((t8) => {
            Fn(t8.expiry) && s11.push(t8.id);
          }), await Promise.all([...e11.map((t8) => this.deleteSession(t8)), ...s11.map((t8) => this.deleteProposal(t8))]);
        }, this.onRelayEventRequest = (e11) => {
          const { topic: s11, payload: t8 } = e11, i10 = t8.method;
          switch (i10) {
            case "wc_sessionPropose":
              return this.onSessionProposeRequest(s11, t8);
            case "wc_sessionSettle":
              return this.onSessionSettleRequest(s11, t8);
            case "wc_sessionUpdate":
              return this.onSessionUpdateRequest(s11, t8);
            case "wc_sessionExtend":
              return this.onSessionExtendRequest(s11, t8);
            case "wc_sessionPing":
              return this.onSessionPingRequest(s11, t8);
            case "wc_sessionDelete":
              return this.onSessionDeleteRequest(s11, t8);
            case "wc_sessionRequest":
              return this.onSessionRequest(s11, t8);
            case "wc_sessionEvent":
              return this.onSessionEventRequest(s11, t8);
            default:
              return this.client.logger.info(`Unsupported request method ${i10}`);
          }
        }, this.onRelayEventResponse = async (e11) => {
          const { topic: s11, payload: t8 } = e11, i10 = (await this.client.core.history.get(s11, t8.id)).request.method;
          switch (i10) {
            case "wc_sessionPropose":
              return this.onSessionProposeResponse(s11, t8);
            case "wc_sessionSettle":
              return this.onSessionSettleResponse(s11, t8);
            case "wc_sessionUpdate":
              return this.onSessionUpdateResponse(s11, t8);
            case "wc_sessionExtend":
              return this.onSessionExtendResponse(s11, t8);
            case "wc_sessionPing":
              return this.onSessionPingResponse(s11, t8);
            case "wc_sessionRequest":
              return this.onSessionRequestResponse(s11, t8);
            default:
              return this.client.logger.info(`Unsupported response method ${i10}`);
          }
        }, this.onSessionProposeRequest = async (e11, s11) => {
          const { params: t8, id: i10 } = s11;
          try {
            this.isValidConnect(u3({}, s11.params));
            const o11 = Ln(import_time4.FIVE_MINUTES), r7 = u3({ id: i10, pairingTopic: e11, expiry: o11 }, t8);
            await this.setProposal(i10, r7), this.client.events.emit("session_proposal", { id: i10, params: r7 });
          } catch (o11) {
            await this.sendError(i10, e11, o11), this.client.logger.error(o11);
          }
        }, this.onSessionProposeResponse = async (e11, s11) => {
          const { id: t8 } = s11;
          if (isJsonRpcResult(s11)) {
            const { result: i10 } = s11;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i10 });
            const o11 = this.client.proposal.get(t8);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o11 });
            const r7 = o11.proposer.publicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: r7 });
            const a9 = i10.responderPublicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a9 });
            const l9 = await this.client.core.crypto.generateSharedKey(r7, a9);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: l9 });
            const h11 = await this.client.core.relayer.subscribe(l9);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h11 }), await this.client.core.pairing.activate({ topic: e11 });
          } else
            isJsonRpcError(s11) && (await this.client.proposal.delete(t8, v("USER_DISCONNECTED")), this.events.emit(xn("session_connect"), { error: s11.error }));
        }, this.onSessionSettleRequest = async (e11, s11) => {
          const { id: t8, params: i10 } = s11;
          try {
            this.isValidSessionSettleRequest(i10);
            const { relay: o11, controller: r7, expiry: a9, namespaces: l9, requiredNamespaces: h11, optionalNamespaces: S7, sessionProperties: m11 } = s11.params, P10 = u3({ topic: e11, relay: o11, expiry: a9, namespaces: l9, acknowledged: true, requiredNamespaces: h11, optionalNamespaces: S7, controller: r7.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: r7.publicKey, metadata: r7.metadata } }, m11 && { sessionProperties: m11 });
            await this.sendResult(s11.id, e11, true), this.events.emit(xn("session_connect"), { session: P10 });
          } catch (o11) {
            await this.sendError(t8, e11, o11), this.client.logger.error(o11);
          }
        }, this.onSessionSettleResponse = async (e11, s11) => {
          const { id: t8 } = s11;
          isJsonRpcResult(s11) ? (await this.client.session.update(e11, { acknowledged: true }), this.events.emit(xn("session_approve", t8), {})) : isJsonRpcError(s11) && (await this.client.session.delete(e11, v("USER_DISCONNECTED")), this.events.emit(xn("session_approve", t8), { error: s11.error }));
        }, this.onSessionUpdateRequest = async (e11, s11) => {
          const { params: t8, id: i10 } = s11;
          try {
            this.isValidUpdate(u3({ topic: e11 }, t8)), await this.client.session.update(e11, { namespaces: t8.namespaces }), await this.sendResult(i10, e11, true), this.client.events.emit("session_update", { id: i10, topic: e11, params: t8 });
          } catch (o11) {
            await this.sendError(i10, e11, o11), this.client.logger.error(o11);
          }
        }, this.onSessionUpdateResponse = (e11, s11) => {
          const { id: t8 } = s11;
          isJsonRpcResult(s11) ? this.events.emit(xn("session_update", t8), {}) : isJsonRpcError(s11) && this.events.emit(xn("session_update", t8), { error: s11.error });
        }, this.onSessionExtendRequest = async (e11, s11) => {
          const { id: t8 } = s11;
          try {
            this.isValidExtend({ topic: e11 }), await this.setExpiry(e11, Ln(b2)), await this.sendResult(t8, e11, true), this.client.events.emit("session_extend", { id: t8, topic: e11 });
          } catch (i10) {
            await this.sendError(t8, e11, i10), this.client.logger.error(i10);
          }
        }, this.onSessionExtendResponse = (e11, s11) => {
          const { id: t8 } = s11;
          isJsonRpcResult(s11) ? this.events.emit(xn("session_extend", t8), {}) : isJsonRpcError(s11) && this.events.emit(xn("session_extend", t8), { error: s11.error });
        }, this.onSessionPingRequest = async (e11, s11) => {
          const { id: t8 } = s11;
          try {
            this.isValidPing({ topic: e11 }), await this.sendResult(t8, e11, true), this.client.events.emit("session_ping", { id: t8, topic: e11 });
          } catch (i10) {
            await this.sendError(t8, e11, i10), this.client.logger.error(i10);
          }
        }, this.onSessionPingResponse = (e11, s11) => {
          const { id: t8 } = s11;
          setTimeout(() => {
            isJsonRpcResult(s11) ? this.events.emit(xn("session_ping", t8), {}) : isJsonRpcError(s11) && this.events.emit(xn("session_ping", t8), { error: s11.error });
          }, 500);
        }, this.onSessionDeleteRequest = async (e11, s11) => {
          const { id: t8 } = s11;
          try {
            this.isValidDisconnect({ topic: e11, reason: s11.params }), this.client.core.relayer.once(D2.publish, async () => {
              await this.deleteSession(e11);
            }), await this.sendResult(t8, e11, true), this.client.events.emit("session_delete", { id: t8, topic: e11 });
          } catch (i10) {
            await this.sendError(t8, e11, i10), this.client.logger.error(i10);
          }
        }, this.onSessionRequest = async (e11, s11) => {
          const { id: t8, params: i10 } = s11;
          try {
            this.isValidRequest(u3({ topic: e11 }, i10)), await this.setPendingSessionRequest({ id: t8, topic: e11, params: i10 }), this.client.events.emit("session_request", { id: t8, topic: e11, params: i10 });
          } catch (o11) {
            await this.sendError(t8, e11, o11), this.client.logger.error(o11);
          }
        }, this.onSessionRequestResponse = (e11, s11) => {
          const { id: t8 } = s11;
          isJsonRpcResult(s11) ? this.events.emit(xn("session_request", t8), { result: s11.result }) : isJsonRpcError(s11) && this.events.emit(xn("session_request", t8), { error: s11.error });
        }, this.onSessionEventRequest = async (e11, s11) => {
          const { id: t8, params: i10 } = s11;
          try {
            this.isValidEmit(u3({ topic: e11 }, i10)), this.client.events.emit("session_event", { id: t8, topic: e11, params: i10 });
          } catch (o11) {
            await this.sendError(t8, e11, o11), this.client.logger.error(o11);
          }
        }, this.isValidConnect = async (e11) => {
          if (!at(e11)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e11)}`);
            throw new Error(a9);
          }
          const { pairingTopic: s11, requiredNamespaces: t8, optionalNamespaces: i10, sessionProperties: o11, relays: r7 } = e11;
          if (h(s11) || await this.isValidPairingTopic(s11), !it(r7, true)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `connect() relays: ${r7}`);
            throw new Error(a9);
          }
          !h(t8) && G(t8) !== 0 && this.validateNamespaces(t8, "requiredNamespaces"), !h(i10) && G(i10) !== 0 && this.validateNamespaces(i10, "optionalNamespaces"), h(o11) || this.validateSessionProps(o11, "sessionProperties");
        }, this.validateNamespaces = (e11, s11) => {
          const t8 = st(e11, "connect()", s11);
          if (t8)
            throw new Error(t8.message);
        }, this.isValidApprove = async (e11) => {
          if (!at(e11))
            throw new Error(E("MISSING_OR_INVALID", `approve() params: ${e11}`).message);
          const { id: s11, namespaces: t8, relayProtocol: i10, sessionProperties: o11 } = e11;
          await this.isValidProposalId(s11);
          const r7 = this.client.proposal.get(s11), a9 = Be(t8, "approve()");
          if (a9)
            throw new Error(a9.message);
          const l9 = Et(r7.requiredNamespaces, t8, "approve()");
          if (l9)
            throw new Error(l9.message);
          if (!d(i10, true)) {
            const { message: h11 } = E("MISSING_OR_INVALID", `approve() relayProtocol: ${i10}`);
            throw new Error(h11);
          }
          h(o11) || this.validateSessionProps(o11, "sessionProperties");
        }, this.isValidReject = async (e11) => {
          if (!at(e11)) {
            const { message: i10 } = E("MISSING_OR_INVALID", `reject() params: ${e11}`);
            throw new Error(i10);
          }
          const { id: s11, reason: t8 } = e11;
          if (await this.isValidProposalId(s11), !ut(t8)) {
            const { message: i10 } = E("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t8)}`);
            throw new Error(i10);
          }
        }, this.isValidSessionSettleRequest = (e11) => {
          if (!at(e11)) {
            const { message: l9 } = E("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e11}`);
            throw new Error(l9);
          }
          const { relay: s11, controller: t8, namespaces: i10, expiry: o11 } = e11;
          if (!Ge(s11)) {
            const { message: l9 } = E("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
            throw new Error(l9);
          }
          const r7 = ot(t8, "onSessionSettleRequest()");
          if (r7)
            throw new Error(r7.message);
          const a9 = Be(i10, "onSessionSettleRequest()");
          if (a9)
            throw new Error(a9.message);
          if (Fn(o11)) {
            const { message: l9 } = E("EXPIRED", "onSessionSettleRequest()");
            throw new Error(l9);
          }
        }, this.isValidUpdate = async (e11) => {
          if (!at(e11)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `update() params: ${e11}`);
            throw new Error(a9);
          }
          const { topic: s11, namespaces: t8 } = e11;
          await this.isValidSessionTopic(s11);
          const i10 = this.client.session.get(s11), o11 = Be(t8, "update()");
          if (o11)
            throw new Error(o11.message);
          const r7 = Et(i10.requiredNamespaces, t8, "update()");
          if (r7)
            throw new Error(r7.message);
        }, this.isValidExtend = async (e11) => {
          if (!at(e11)) {
            const { message: t8 } = E("MISSING_OR_INVALID", `extend() params: ${e11}`);
            throw new Error(t8);
          }
          const { topic: s11 } = e11;
          await this.isValidSessionTopic(s11);
        }, this.isValidRequest = async (e11) => {
          if (!at(e11)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `request() params: ${e11}`);
            throw new Error(a9);
          }
          const { topic: s11, request: t8, chainId: i10, expiry: o11 } = e11;
          await this.isValidSessionTopic(s11);
          const { namespaces: r7 } = this.client.session.get(s11);
          if (!pt(r7, i10)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `request() chainId: ${i10}`);
            throw new Error(a9);
          }
          if (!dt(t8)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `request() ${JSON.stringify(t8)}`);
            throw new Error(a9);
          }
          if (!mt(r7, i10, t8.method)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `request() method: ${t8.method}`);
            throw new Error(a9);
          }
          if (o11 && !Nt(o11, $3)) {
            const { message: a9 } = E("MISSING_OR_INVALID", `request() expiry: ${o11}. Expiry must be a number (in seconds) between ${$3.min} and ${$3.max}`);
            throw new Error(a9);
          }
        }, this.isValidRespond = async (e11) => {
          if (!at(e11)) {
            const { message: i10 } = E("MISSING_OR_INVALID", `respond() params: ${e11}`);
            throw new Error(i10);
          }
          const { topic: s11, response: t8 } = e11;
          if (await this.isValidSessionTopic(s11), !lt(t8)) {
            const { message: i10 } = E("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t8)}`);
            throw new Error(i10);
          }
        }, this.isValidPing = async (e11) => {
          if (!at(e11)) {
            const { message: t8 } = E("MISSING_OR_INVALID", `ping() params: ${e11}`);
            throw new Error(t8);
          }
          const { topic: s11 } = e11;
          await this.isValidSessionOrPairingTopic(s11);
        }, this.isValidEmit = async (e11) => {
          if (!at(e11)) {
            const { message: r7 } = E("MISSING_OR_INVALID", `emit() params: ${e11}`);
            throw new Error(r7);
          }
          const { topic: s11, event: t8, chainId: i10 } = e11;
          await this.isValidSessionTopic(s11);
          const { namespaces: o11 } = this.client.session.get(s11);
          if (!pt(o11, i10)) {
            const { message: r7 } = E("MISSING_OR_INVALID", `emit() chainId: ${i10}`);
            throw new Error(r7);
          }
          if (!ft(t8)) {
            const { message: r7 } = E("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t8)}`);
            throw new Error(r7);
          }
          if (!yt(o11, i10, t8.name)) {
            const { message: r7 } = E("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t8)}`);
            throw new Error(r7);
          }
        }, this.isValidDisconnect = async (e11) => {
          if (!at(e11)) {
            const { message: t8 } = E("MISSING_OR_INVALID", `disconnect() params: ${e11}`);
            throw new Error(t8);
          }
          const { topic: s11 } = e11;
          await this.isValidSessionOrPairingTopic(s11);
        }, this.validateSessionProps = (e11, s11) => {
          Object.values(e11).forEach((t8) => {
            if (!d(t8, false)) {
              const { message: i10 } = E("MISSING_OR_INVALID", `${s11} must be in Record<string, string> format. Received: ${JSON.stringify(t8)}`);
              throw new Error(i10);
            }
          });
        };
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: n8 } = E("NOT_INITIALIZED", this.name);
          throw new Error(n8);
        }
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(D2.message, async (n8) => {
          const { topic: e11, message: s11 } = n8;
          if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s11)))
            return;
          const t8 = await this.client.core.crypto.decode(e11, s11);
          isJsonRpcRequest(t8) ? (this.client.core.history.set(e11, t8), this.onRelayEventRequest({ topic: e11, payload: t8 })) : isJsonRpcResponse(t8) && (await this.client.core.history.resolve(t8), this.onRelayEventResponse({ topic: e11, payload: t8 }));
        });
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(m.expired, async (n8) => {
          const { topic: e11, id: s11 } = kn(n8.target);
          if (s11 && this.client.pendingRequest.keys.includes(s11))
            return await this.deletePendingSessionRequest(s11, E("EXPIRED"), true);
          e11 ? this.client.session.keys.includes(e11) && (await this.deleteSession(e11, true), this.client.events.emit("session_expire", { topic: e11 })) : s11 && (await this.deleteProposal(s11, true), this.client.events.emit("proposal_expire", { id: s11 }));
        });
      }
      isValidPairingTopic(n8) {
        if (!d(n8, false)) {
          const { message: e11 } = E("MISSING_OR_INVALID", `pairing topic should be a string: ${n8}`);
          throw new Error(e11);
        }
        if (!this.client.core.pairing.pairings.keys.includes(n8)) {
          const { message: e11 } = E("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n8}`);
          throw new Error(e11);
        }
        if (Fn(this.client.core.pairing.pairings.get(n8).expiry)) {
          const { message: e11 } = E("EXPIRED", `pairing topic: ${n8}`);
          throw new Error(e11);
        }
      }
      async isValidSessionTopic(n8) {
        if (!d(n8, false)) {
          const { message: e11 } = E("MISSING_OR_INVALID", `session topic should be a string: ${n8}`);
          throw new Error(e11);
        }
        if (!this.client.session.keys.includes(n8)) {
          const { message: e11 } = E("NO_MATCHING_KEY", `session topic doesn't exist: ${n8}`);
          throw new Error(e11);
        }
        if (Fn(this.client.session.get(n8).expiry)) {
          await this.deleteSession(n8);
          const { message: e11 } = E("EXPIRED", `session topic: ${n8}`);
          throw new Error(e11);
        }
      }
      async isValidSessionOrPairingTopic(n8) {
        if (this.client.session.keys.includes(n8))
          await this.isValidSessionTopic(n8);
        else if (this.client.core.pairing.pairings.keys.includes(n8))
          this.isValidPairingTopic(n8);
        else if (d(n8, false)) {
          const { message: e11 } = E("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n8}`);
          throw new Error(e11);
        } else {
          const { message: e11 } = E("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n8}`);
          throw new Error(e11);
        }
      }
      async isValidProposalId(n8) {
        if (!ct(n8)) {
          const { message: e11 } = E("MISSING_OR_INVALID", `proposal id should be a number: ${n8}`);
          throw new Error(e11);
        }
        if (!this.client.proposal.keys.includes(n8)) {
          const { message: e11 } = E("NO_MATCHING_KEY", `proposal id doesn't exist: ${n8}`);
          throw new Error(e11);
        }
        if (Fn(this.client.proposal.get(n8).expiry)) {
          await this.deleteProposal(n8);
          const { message: e11 } = E("EXPIRED", `proposal id: ${n8}`);
          throw new Error(e11);
        }
      }
    };
    Ze3 = class extends Ct {
      constructor(n8, e11) {
        super(n8, e11, ee, C3), this.core = n8, this.logger = e11;
      }
    };
    es2 = class extends Ct {
      constructor(n8, e11) {
        super(n8, e11, te2, C3), this.core = n8, this.logger = e11;
      }
    };
    ss2 = class extends Ct {
      constructor(n8, e11) {
        super(n8, e11, ne3, C3, (s11) => s11.id), this.core = n8, this.logger = e11;
      }
    };
    M3 = class extends y {
      constructor(n8) {
        super(n8), this.protocol = k2, this.version = X2, this.name = G3.name, this.events = new import_events6.EventEmitter(), this.on = (s11, t8) => this.events.on(s11, t8), this.once = (s11, t8) => this.events.once(s11, t8), this.off = (s11, t8) => this.events.off(s11, t8), this.removeListener = (s11, t8) => this.events.removeListener(s11, t8), this.removeAllListeners = (s11) => this.events.removeAllListeners(s11), this.connect = async (s11) => {
          try {
            return await this.engine.connect(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.pair = async (s11) => {
          try {
            return await this.engine.pair(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.approve = async (s11) => {
          try {
            return await this.engine.approve(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.reject = async (s11) => {
          try {
            return await this.engine.reject(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.update = async (s11) => {
          try {
            return await this.engine.update(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.extend = async (s11) => {
          try {
            return await this.engine.extend(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.request = async (s11) => {
          try {
            return await this.engine.request(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.respond = async (s11) => {
          try {
            return await this.engine.respond(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.ping = async (s11) => {
          try {
            return await this.engine.ping(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.emit = async (s11) => {
          try {
            return await this.engine.emit(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.disconnect = async (s11) => {
          try {
            return await this.engine.disconnect(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.find = (s11) => {
          try {
            return this.engine.find(s11);
          } catch (t8) {
            throw this.logger.error(t8.message), t8;
          }
        }, this.getPendingSessionRequests = () => {
          try {
            return this.engine.getPendingSessionRequests();
          } catch (s11) {
            throw this.logger.error(s11.message), s11;
          }
        }, this.name = n8?.name || G3.name, this.metadata = n8?.metadata || In();
        const e11 = typeof n8?.logger < "u" && typeof n8?.logger != "string" ? n8.logger : (0, import_pino2.default)((0, import_logger22.getDefaultLoggerOptions)({ level: n8?.logger || G3.logger }));
        this.core = n8?.core || new gr(n8), this.logger = (0, import_logger22.generateChildLogger)(e11, this.name), this.session = new es2(this.core, this.logger), this.proposal = new Ze3(this.core, this.logger), this.pendingRequest = new ss2(this.core, this.logger), this.engine = new We3(this);
      }
      static async init(n8) {
        const e11 = new M3(n8);
        return await e11.initialize(), e11;
      }
      get context() {
        return (0, import_logger22.getLoggerContext)(this.logger);
      }
      get pairing() {
        return this.core.pairing.pairings;
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
        } catch (n8) {
          throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n8.message), n8;
        }
      }
    };
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F8() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F8.prototype = global2;
      return new F8();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e11) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i10 = 0; i10 < view.length; i10++) {
            chars[i10] = String.fromCharCode(view[i10]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode6);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode6(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name2) {
              xhr.setRequestHeader(name2, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
var import_events7, import_cross_fetch, DEFAULT_HTTP_HEADERS, DEFAULT_HTTP_METHOD, DEFAULT_FETCH_OPTS, EVENT_EMITTER_MAX_LISTENERS_DEFAULT2, HttpConnection, http_default;
var init_http = __esm({
  "node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js"() {
    import_events7 = __toESM(require_events());
    import_cross_fetch = __toESM(require_browser_ponyfill());
    init_esm3();
    init_esm6();
    DEFAULT_HTTP_HEADERS = {
      Accept: "application/json",
      "Content-Type": "application/json"
    };
    DEFAULT_HTTP_METHOD = "POST";
    DEFAULT_FETCH_OPTS = {
      headers: DEFAULT_HTTP_HEADERS,
      method: DEFAULT_HTTP_METHOD
    };
    EVENT_EMITTER_MAX_LISTENERS_DEFAULT2 = 10;
    HttpConnection = class {
      constructor(url) {
        this.url = url;
        this.events = new import_events7.EventEmitter();
        this.isAvailable = false;
        this.registering = false;
        if (!isHttpUrl(url)) {
          throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
        }
        this.url = url;
      }
      get connected() {
        return this.isAvailable;
      }
      get connecting() {
        return this.registering;
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      async open(url = this.url) {
        await this.register(url);
      }
      async close() {
        if (!this.isAvailable) {
          throw new Error("Connection already closed");
        }
        this.onClose();
      }
      async send(payload, context) {
        if (!this.isAvailable) {
          await this.register();
        }
        try {
          const body = safeJsonStringify(payload);
          const res = await (0, import_cross_fetch.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
          const data2 = await res.json();
          this.onPayload({ data: data2 });
        } catch (e11) {
          this.onError(payload.id, e11);
        }
      }
      async register(url = this.url) {
        if (!isHttpUrl(url)) {
          throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
        }
        if (this.registering) {
          const currentMaxListeners = this.events.getMaxListeners();
          if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
            this.events.setMaxListeners(currentMaxListeners + 1);
          }
          return new Promise((resolve, reject) => {
            this.events.once("register_error", (error) => {
              this.resetMaxListeners();
              reject(error);
            });
            this.events.once("open", () => {
              this.resetMaxListeners();
              if (typeof this.isAvailable === "undefined") {
                return reject(new Error("HTTP connection is missing or invalid"));
              }
              resolve();
            });
          });
        }
        this.url = url;
        this.registering = true;
        try {
          const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
          await (0, import_cross_fetch.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
          this.onOpen();
        } catch (e11) {
          const error = this.parseError(e11);
          this.events.emit("register_error", error);
          this.onClose();
          throw error;
        }
      }
      onOpen() {
        this.isAvailable = true;
        this.registering = false;
        this.events.emit("open");
      }
      onClose() {
        this.isAvailable = false;
        this.registering = false;
        this.events.emit("close");
      }
      onPayload(e11) {
        if (typeof e11.data === "undefined")
          return;
        const payload = typeof e11.data === "string" ? safeJsonParse(e11.data) : e11.data;
        this.events.emit("payload", payload);
      }
      onError(id2, e11) {
        const error = this.parseError(e11);
        const message = error.message || error.toString();
        const payload = formatJsonRpcError(id2, message);
        this.events.emit("payload", payload);
      }
      parseError(e11, url = this.url) {
        return parseConnectionError(e11, url, "HTTP");
      }
      resetMaxListeners() {
        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT2) {
          this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT2);
        }
      }
    };
    http_default = HttpConnection;
  }
});

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js
var esm_default2;
var init_esm9 = __esm({
  "node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js"() {
    init_http();
    init_http();
    esm_default2 = http_default;
  }
});

// node_modules/@walletconnect/universal-provider/dist/index.es.js
function a2(i10, e11, t8) {
  let s11;
  const n8 = g3(i10);
  return e11.rpcMap && (s11 = e11.rpcMap[n8]), s11 || (s11 = `${x2}?chainId=eip155:${n8}&projectId=${t8}`), s11;
}
function g3(i10) {
  return i10.includes("eip155") ? Number(i10.split(":")[1]) : Number(i10);
}
function K2(i10, e11) {
  if (!e11.includes(i10))
    throw new Error(`Chain '${i10}' not approved. Please use one of the following: ${e11.toString()}`);
}
function X3(i10) {
  return i10.map((e11) => `${e11.split(":")[0]}:${e11.split(":")[1]}`);
}
function Y3(i10, e11) {
  const t8 = Object.keys(e11.namespaces).filter((n8) => n8.includes(i10));
  if (!t8.length)
    return [];
  const s11 = [];
  return t8.forEach((n8) => {
    const r7 = e11.namespaces[n8].accounts;
    s11.push(...r7);
  }), s11;
}
function B2(i10, e11 = {}) {
  const t8 = A3(i10), s11 = A3(e11);
  return f({}, Object.assign(t8, s11));
}
function A3(i10) {
  var e11, t8, s11, n8;
  const r7 = {};
  if (!G(i10))
    return r7;
  for (const [v7, l9] of Object.entries(i10)) {
    const q8 = y2(v7) ? [v7] : l9.chains, S7 = l9.methods || [], D7 = l9.events || [], p10 = N11(v7);
    r7[p10] = { chains: P3(q8, (e11 = r7[p10]) == null ? void 0 : e11.chains), methods: P3(S7, (t8 = r7[p10]) == null ? void 0 : t8.methods), events: P3(D7, (s11 = r7[p10]) == null ? void 0 : s11.events), rpcMap: f(f({}, (n8 = r7[p10]) == null ? void 0 : n8.rpcMap), l9.rpcMap) };
  }
  return r7;
}
function y2(i10) {
  return i10.includes(":");
}
function N11(i10) {
  return y2(i10) ? i10.split(":")[0] : i10;
}
function P3(i10 = [], e11 = []) {
  return [.../* @__PURE__ */ new Set([...i10, ...e11])];
}
function Q2(i10) {
  if (typeof window < "u")
    try {
      const e11 = window.localStorage.getItem("WALLETCONNECT_DEEPLINK_CHOICE");
      if (e11) {
        const t8 = JSON.parse(e11), s11 = t8?.href;
        if (typeof s11 == "string") {
          s11.endsWith("/") && s11.slice(0, -1);
          const n8 = `${s11}/wc?requestId=${i10.id}&sessionTopic=${i10.topic}`;
          window.open(n8, "_self", "noreferrer noopener");
        }
      }
    } catch (e11) {
      console.error(e11);
    }
}
var import_pino3, import_logger23, import_events8, I3, M4, G4, z3, E3, x2, o, J3, $4, V2, W2, H4, f, h3, Z3, ee2, te3, se3, ie3, ne4, re4, ae3, oe3, O3, ce2, he4, b3, u4, w4, m2, pe2;
var init_index_es5 = __esm({
  "node_modules/@walletconnect/universal-provider/dist/index.es.js"() {
    import_pino3 = __toESM(require_browser2());
    init_index_es4();
    init_index_es();
    import_logger23 = __toESM(require_cjs6());
    init_esm7();
    init_esm9();
    import_events8 = __toESM(require_events());
    I3 = "error";
    M4 = "wss://relay.walletconnect.com";
    G4 = "wc";
    z3 = "universal_provider";
    E3 = `${G4}@${2}:${z3}:`;
    x2 = "https://rpc.walletconnect.com/v1";
    o = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
    J3 = Object.defineProperty;
    $4 = Object.getOwnPropertySymbols;
    V2 = Object.prototype.hasOwnProperty;
    W2 = Object.prototype.propertyIsEnumerable;
    H4 = (i10, e11, t8) => e11 in i10 ? J3(i10, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : i10[e11] = t8;
    f = (i10, e11) => {
      for (var t8 in e11 || (e11 = {}))
        V2.call(e11, t8) && H4(i10, t8, e11[t8]);
      if ($4)
        for (var t8 of $4(e11))
          W2.call(e11, t8) && H4(i10, t8, e11[t8]);
      return i10;
    };
    h3 = (i10, e11) => {
      const t8 = (s11) => {
        s11.request !== e11.request || s11.topic !== e11.topic || (i10.events.removeListener("session_request_sent", t8), Q2(e11));
      };
      i10.on("session_request_sent", t8);
    };
    Z3 = class {
      constructor(e11) {
        this.name = "eip155", this.namespace = e11.namespace, this.client = e11.client, this.events = e11.events, this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
      }
      async request(e11) {
        var t8;
        switch (e11.request.method) {
          case "eth_requestAccounts":
            return this.getAccounts();
          case "eth_accounts":
            return this.getAccounts();
          case "wallet_switchEthereumChain":
            return this.handleSwitchChain(e11.request.params ? (t8 = e11.request.params[0]) == null ? void 0 : t8.chainId : "0x0"), null;
          case "eth_chainId":
            return parseInt(this.getDefaultChain());
        }
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), await this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      setDefaultChain(e11, t8) {
        const s11 = g3(e11);
        if (!this.httpProviders[s11]) {
          const n8 = t8 || a2(`${this.name}:${s11}`, this.namespace, this.client.core.projectId);
          if (!n8)
            throw new Error(`No RPC url provided for chainId: ${s11}`);
          this.setHttpProvider(s11, n8);
        }
        this.chainId = s11, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${s11}`);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId.toString();
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || a2(`${this.name}:${e11}`, this.namespace, this.client.core.projectId);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new HttpConnection(s11));
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          var s11;
          const n8 = g3(t8);
          e11[n8] = this.createHttpProvider(n8, (s11 = this.namespace.rpcMap) == null ? void 0 : s11[t8]);
        }), e11;
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      getHttpProvider() {
        const e11 = this.chainId, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      handleSwitchChain(e11) {
        const t8 = parseInt(e11, 16), s11 = `${this.name}:${t8}`;
        K2(s11, this.namespace.chains), this.setDefaultChain(`${t8}`);
      }
    };
    ee2 = class {
      constructor(e11) {
        this.name = "solana", this.namespace = e11.namespace, this.events = e11.events, this.client = e11.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e11) {
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      setDefaultChain(e11, t8) {
        if (!this.httpProviders[e11]) {
          const s11 = t8 || a2(`${this.name}:${e11}`, this.namespace, this.client.core.projectId);
          if (!s11)
            throw new Error(`No RPC url provided for chainId: ${e11}`);
          this.setHttpProvider(e11, s11);
        }
        this.chainId = e11, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          var s11;
          e11[t8] = this.createHttpProvider(t8, (s11 = this.namespace.rpcMap) == null ? void 0 : s11[t8]);
        }), e11;
      }
      getHttpProvider() {
        const e11 = `${this.name}:${this.chainId}`, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || a2(e11, this.namespace, this.client.core.projectId);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new esm_default2(s11));
      }
    };
    te3 = class {
      constructor(e11) {
        this.name = "cosmos", this.namespace = e11.namespace, this.events = e11.events, this.client = e11.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      request(e11) {
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      setDefaultChain(e11, t8) {
        if (this.chainId = e11, !this.httpProviders[e11]) {
          const s11 = t8 || a2(`${this.name}:${e11}`, this.namespace, this.client.core.projectId);
          if (!s11)
            throw new Error(`No RPC url provided for chainId: ${e11}`);
          this.setHttpProvider(e11, s11);
        }
        this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          var s11;
          e11[t8] = this.createHttpProvider(t8, (s11 = this.namespace.rpcMap) == null ? void 0 : s11[t8]);
        }), e11;
      }
      getHttpProvider() {
        const e11 = `${this.name}:${this.chainId}`, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || a2(e11, this.namespace, this.client.core.projectId);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new esm_default2(s11));
      }
    };
    se3 = class {
      constructor(e11) {
        this.name = "cip34", this.namespace = e11.namespace, this.events = e11.events, this.client = e11.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      request(e11) {
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      setDefaultChain(e11, t8) {
        if (this.chainId = e11, !this.httpProviders[e11]) {
          const s11 = t8 || this.getCardanoRPCUrl(e11);
          if (!s11)
            throw new Error(`No RPC url provided for chainId: ${e11}`);
          this.setHttpProvider(e11, s11);
        }
        this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          const s11 = this.getCardanoRPCUrl(t8);
          e11[t8] = this.createHttpProvider(t8, s11);
        }), e11;
      }
      getHttpProvider() {
        const e11 = `${this.name}:${this.chainId}`, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      getCardanoRPCUrl(e11) {
        const t8 = this.namespace.rpcMap;
        if (t8)
          return t8[e11];
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || this.getCardanoRPCUrl(e11);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new esm_default2(s11));
      }
    };
    ie3 = class {
      constructor(e11) {
        this.name = "elrond", this.namespace = e11.namespace, this.events = e11.events, this.client = e11.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e11) {
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      setDefaultChain(e11, t8) {
        if (!this.httpProviders[e11]) {
          const s11 = t8 || a2(`${this.name}:${e11}`, this.namespace, this.client.core.projectId);
          if (!s11)
            throw new Error(`No RPC url provided for chainId: ${e11}`);
          this.setHttpProvider(e11, s11);
        }
        this.chainId = e11, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          var s11;
          e11[t8] = this.createHttpProvider(t8, (s11 = this.namespace.rpcMap) == null ? void 0 : s11[t8]);
        }), e11;
      }
      getHttpProvider() {
        const e11 = `${this.name}:${this.chainId}`, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || a2(e11, this.namespace, this.client.core.projectId);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new esm_default2(s11));
      }
    };
    ne4 = class {
      constructor(e11) {
        this.name = "multiversx", this.namespace = e11.namespace, this.events = e11.events, this.client = e11.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(e11) {
        this.namespace = Object.assign(this.namespace, e11);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e11) {
        return this.namespace.methods.includes(e11.request.method) ? (h3(this.client, e11), this.client.request(e11)) : this.getHttpProvider().request(e11.request);
      }
      setDefaultChain(e11, t8) {
        if (!this.httpProviders[e11]) {
          const s11 = t8 || a2(`${this.name}:${e11}`, this.namespace, this.client.core.projectId);
          if (!s11)
            throw new Error(`No RPC url provided for chainId: ${e11}`);
          this.setHttpProvider(e11, s11);
        }
        this.chainId = e11, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        const e11 = this.namespace.chains[0];
        if (!e11)
          throw new Error("ChainId not found");
        return e11.split(":")[1];
      }
      getAccounts() {
        const e11 = this.namespace.accounts;
        return e11 ? [...new Set(e11.filter((t8) => t8.split(":")[1] === this.chainId.toString()).map((t8) => t8.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const e11 = {};
        return this.namespace.chains.forEach((t8) => {
          var s11;
          e11[t8] = this.createHttpProvider(t8, (s11 = this.namespace.rpcMap) == null ? void 0 : s11[t8]);
        }), e11;
      }
      getHttpProvider() {
        const e11 = `${this.name}:${this.chainId}`, t8 = this.httpProviders[e11];
        if (typeof t8 > "u")
          throw new Error(`JSON-RPC provider for ${e11} not found`);
        return t8;
      }
      setHttpProvider(e11, t8) {
        const s11 = this.createHttpProvider(e11, t8);
        s11 && (this.httpProviders[e11] = s11);
      }
      createHttpProvider(e11, t8) {
        const s11 = t8 || a2(e11, this.namespace, this.client.core.projectId);
        return typeof s11 > "u" ? void 0 : new JsonRpcProvider2(new esm_default2(s11));
      }
    };
    re4 = Object.defineProperty;
    ae3 = Object.defineProperties;
    oe3 = Object.getOwnPropertyDescriptors;
    O3 = Object.getOwnPropertySymbols;
    ce2 = Object.prototype.hasOwnProperty;
    he4 = Object.prototype.propertyIsEnumerable;
    b3 = (i10, e11, t8) => e11 in i10 ? re4(i10, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : i10[e11] = t8;
    u4 = (i10, e11) => {
      for (var t8 in e11 || (e11 = {}))
        ce2.call(e11, t8) && b3(i10, t8, e11[t8]);
      if (O3)
        for (var t8 of O3(e11))
          he4.call(e11, t8) && b3(i10, t8, e11[t8]);
      return i10;
    };
    w4 = (i10, e11) => ae3(i10, oe3(e11));
    m2 = class {
      constructor(e11) {
        this.events = new import_events8.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.providerOpts = e11, this.logger = typeof e11?.logger < "u" && typeof e11?.logger != "string" ? e11.logger : (0, import_pino3.default)((0, import_logger23.getDefaultLoggerOptions)({ level: e11?.logger || I3 }));
      }
      static async init(e11) {
        const t8 = new m2(e11);
        return await t8.initialize(), t8;
      }
      async request(e11, t8) {
        const [s11, n8] = this.validateChain(t8);
        if (!this.session)
          throw new Error("Please call connect() before request()");
        return await this.getProvider(s11).request({ request: u4({}, e11), chainId: `${s11}:${n8}`, topic: this.session.topic });
      }
      sendAsync(e11, t8, s11) {
        this.request(e11, s11).then((n8) => t8(null, n8)).catch((n8) => t8(n8, void 0));
      }
      async enable() {
        if (!this.client)
          throw new Error("Sign Client not initialized");
        return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
      }
      async disconnect() {
        var e11;
        if (!this.session)
          throw new Error("Please call connect() before enable()");
        await this.client.disconnect({ topic: (e11 = this.session) == null ? void 0 : e11.topic, reason: v("USER_DISCONNECTED") }), await this.cleanup();
      }
      async connect(e11) {
        if (!this.client)
          throw new Error("Sign Client not initialized");
        if (this.setNamespaces(e11), await this.cleanupPendingPairings(), !e11.skipPairing)
          return await this.pair(e11.pairingTopic);
      }
      on(e11, t8) {
        this.events.on(e11, t8);
      }
      once(e11, t8) {
        this.events.once(e11, t8);
      }
      removeListener(e11, t8) {
        this.events.removeListener(e11, t8);
      }
      off(e11, t8) {
        this.events.off(e11, t8);
      }
      get isWalletConnect() {
        return true;
      }
      async pair(e11) {
        this.shouldAbortPairingAttempt = false;
        let t8 = 0;
        do {
          if (this.shouldAbortPairingAttempt)
            throw new Error("Pairing aborted");
          if (t8 >= this.maxPairingAttempts)
            throw new Error("Max auto pairing attempts reached");
          const { uri: s11, approval: n8 } = await this.client.connect({ pairingTopic: e11, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
          s11 && (this.uri = s11, this.events.emit("display_uri", s11)), await n8().then((r7) => {
            this.session = r7;
          }).catch((r7) => {
            if (r7.message !== se2)
              throw r7;
            t8++;
          });
        } while (!this.session);
        return this.onConnect(), this.session;
      }
      setDefaultChain(e11, t8) {
        try {
          const [s11, n8] = this.validateChain(e11);
          this.getProvider(s11).setDefaultChain(n8, t8);
        } catch (s11) {
          if (!/Please call connect/.test(s11.message))
            throw s11;
        }
      }
      async cleanupPendingPairings(e11 = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const t8 = this.client.pairing.getAll();
        if (I(t8)) {
          for (const s11 of t8)
            e11.deletePairings ? this.client.core.expirer.set(s11.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s11.topic);
          this.logger.info(`Inactive pairings cleared: ${t8.length}`);
        }
      }
      abortPairingAttempt() {
        this.shouldAbortPairingAttempt = true;
      }
      async checkStorage() {
        if (this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
          const e11 = this.client.session.keys.length - 1;
          this.session = this.client.session.get(this.client.session.keys[e11]), this.createProviders();
        }
      }
      async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
      }
      async createClient() {
        this.client = this.providerOpts.client || await M3.init({ logger: this.providerOpts.logger || I3, relayUrl: this.providerOpts.relayUrl || M4, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
      }
      createProviders() {
        if (!this.client)
          throw new Error("Sign Client not initialized");
        if (!this.session)
          throw new Error("Session not initialized. Please call connect() before enable()");
        [...new Set(Object.keys(this.session.namespaces).map((e11) => N11(e11)))].forEach((e11) => {
          if (!this.session)
            return;
          const t8 = Y3(e11, this.session), s11 = X3(t8), n8 = B2(this.namespaces, this.optionalNamespaces), r7 = w4(u4({}, n8[e11]), { accounts: t8, chains: s11 });
          switch (e11) {
            case "eip155":
              this.rpcProviders[e11] = new Z3({ client: this.client, namespace: r7, events: this.events });
              break;
            case "solana":
              this.rpcProviders[e11] = new ee2({ client: this.client, namespace: r7, events: this.events });
              break;
            case "cosmos":
              this.rpcProviders[e11] = new te3({ client: this.client, namespace: r7, events: this.events });
              break;
            case "polkadot":
              break;
            case "cip34":
              this.rpcProviders[e11] = new se3({ client: this.client, namespace: r7, events: this.events });
              break;
            case "elrond":
              this.rpcProviders[e11] = new ie3({ client: this.client, namespace: r7, events: this.events });
              break;
            case "multiversx":
              this.rpcProviders[e11] = new ne4({ client: this.client, namespace: r7, events: this.events });
              break;
          }
        });
      }
      registerEventListeners() {
        if (typeof this.client > "u")
          throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (e11) => {
          this.events.emit("session_ping", e11);
        }), this.client.on("session_event", (e11) => {
          const { params: t8 } = e11, { event: s11 } = t8;
          s11.name === "accountsChanged" ? this.events.emit("accountsChanged", s11.data) : s11.name === "chainChanged" ? this.onChainChanged(t8.chainId) : this.events.emit(s11.name, s11.data), this.events.emit("session_event", e11);
        }), this.client.on("session_update", ({ topic: e11, params: t8 }) => {
          var s11;
          const { namespaces: n8 } = t8, r7 = (s11 = this.client) == null ? void 0 : s11.session.get(e11);
          this.session = w4(u4({}, r7), { namespaces: n8 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e11, params: t8 });
        }), this.client.on("session_delete", async (e11) => {
          await this.cleanup(), this.events.emit("session_delete", e11), this.events.emit("disconnect", w4(u4({}, v("USER_DISCONNECTED")), { data: e11.topic }));
        }), this.on(o.DEFAULT_CHAIN_CHANGED, (e11) => {
          this.onChainChanged(e11, true);
        });
      }
      getProvider(e11) {
        if (!this.rpcProviders[e11])
          throw new Error(`Provider not found: ${e11}`);
        return this.rpcProviders[e11];
      }
      onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((e11) => {
          var t8;
          this.getProvider(e11).updateNamespace((t8 = this.session) == null ? void 0 : t8.namespaces[e11]);
        });
      }
      setNamespaces(e11) {
        const { namespaces: t8, optionalNamespaces: s11, sessionProperties: n8 } = e11;
        if (!t8 || !Object.keys(t8).length)
          throw new Error("Namespaces must be not empty");
        this.namespaces = t8, this.optionalNamespaces = s11, this.sessionProperties = n8, this.persist("namespaces", t8), this.persist("optionalNamespaces", s11);
      }
      validateChain(e11) {
        const [t8, s11] = e11?.split(":") || ["", ""];
        if (t8 && !Object.keys(this.namespaces).includes(t8))
          throw new Error(`Namespace '${t8}' is not configured. Please call connect() first with namespace config.`);
        if (t8 && s11)
          return [t8, s11];
        const n8 = Object.keys(this.namespaces)[0], r7 = this.rpcProviders[n8].getDefaultChain();
        return [n8, r7];
      }
      async requestAccounts() {
        const [e11] = this.validateChain();
        return await this.getProvider(e11).requestAccounts();
      }
      onChainChanged(e11, t8 = false) {
        const [s11, n8] = this.validateChain(e11);
        t8 || this.getProvider(s11).setDefaultChain(n8), this.namespaces[s11].defaultChain = n8, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", n8);
      }
      onConnect() {
        this.createProviders(), this.events.emit("connect", { session: this.session });
      }
      async cleanup() {
        this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true });
      }
      persist(e11, t8) {
        this.client.core.storage.setItem(`${E3}/${e11}`, t8);
      }
      async getFromStore(e11) {
        return await this.client.core.storage.getItem(`${E3}/${e11}`);
      }
    };
    pe2 = m2;
  }
});

// node_modules/proxy-compare/dist/index.modern.js
var e, t, s, c2, l, y3, h4;
var init_index_modern = __esm({
  "node_modules/proxy-compare/dist/index.modern.js"() {
    e = Symbol();
    t = Symbol();
    s = Object.getPrototypeOf;
    c2 = /* @__PURE__ */ new WeakMap();
    l = (e11) => e11 && (c2.has(e11) ? c2.get(e11) : s(e11) === Object.prototype || s(e11) === Array.prototype);
    y3 = (e11) => l(e11) && e11[t] || null;
    h4 = (e11, t8 = true) => {
      c2.set(e11, t8);
    };
  }
});

// node_modules/valtio/esm/vanilla.mjs
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
var isObject, proxyStateMap, refSet, buildProxyFunction, defaultProxyFunction;
var init_vanilla = __esm({
  "node_modules/valtio/esm/vanilla.mjs"() {
    init_index_modern();
    isObject = (x8) => typeof x8 === "object" && x8 !== null;
    proxyStateMap = /* @__PURE__ */ new WeakMap();
    refSet = /* @__PURE__ */ new WeakSet();
    buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x8) => isObject(x8) && !refSet.has(x8) && (Array.isArray(x8) || !(Symbol.iterator in x8)) && !(x8 instanceof WeakMap) && !(x8 instanceof WeakSet) && !(x8 instanceof Error) && !(x8 instanceof Number) && !(x8 instanceof Date) && !(x8 instanceof String) && !(x8 instanceof RegExp) && !(x8 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
      switch (promise.status) {
        case "fulfilled":
          return promise.value;
        case "rejected":
          throw promise.reason;
        default:
          throw promise;
      }
    }, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version6, handlePromise = defaultHandlePromise) => {
      const cache = snapCache.get(target);
      if ((cache == null ? void 0 : cache[0]) === version6) {
        return cache[1];
      }
      const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
      h4(snap, true);
      snapCache.set(target, [version6, snap]);
      Reflect.ownKeys(target).forEach((key) => {
        if (Object.getOwnPropertyDescriptor(snap, key)) {
          return;
        }
        const value = Reflect.get(target, key);
        const desc = {
          value,
          enumerable: true,
          // This is intentional to avoid copying with proxy-compare.
          // It's still non-writable, so it avoids assigning a value.
          configurable: true
        };
        if (refSet.has(value)) {
          h4(value, false);
        } else if (value instanceof Promise) {
          delete desc.value;
          desc.get = () => handlePromise(value);
        } else if (proxyStateMap.has(value)) {
          const [target2, ensureVersion] = proxyStateMap.get(
            value
          );
          desc.value = createSnapshot(
            target2,
            ensureVersion(),
            handlePromise
          );
        }
        Object.defineProperty(snap, key, desc);
      });
      return snap;
    }, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
      if (!isObject(initialObject)) {
        throw new Error("object required");
      }
      const found = proxyCache.get(initialObject);
      if (found) {
        return found;
      }
      let version6 = versionHolder[0];
      const listeners = /* @__PURE__ */ new Set();
      const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
        if (version6 !== nextVersion) {
          version6 = nextVersion;
          listeners.forEach((listener) => listener(op, nextVersion));
        }
      };
      let checkVersion = versionHolder[1];
      const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
        if (checkVersion !== nextCheckVersion && !listeners.size) {
          checkVersion = nextCheckVersion;
          propProxyStates.forEach(([propProxyState]) => {
            const propVersion = propProxyState[1](nextCheckVersion);
            if (propVersion > version6) {
              version6 = propVersion;
            }
          });
        }
        return version6;
      };
      const createPropListener = (prop) => (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      const propProxyStates = /* @__PURE__ */ new Map();
      const addPropListener = (prop, propProxyState) => {
        if ((import.meta.env && import.meta.env.MODE) !== "production" && propProxyStates.has(prop)) {
          throw new Error("prop listener already exists");
        }
        if (listeners.size) {
          const remove = propProxyState[3](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        } else {
          propProxyStates.set(prop, [propProxyState]);
        }
      };
      const removePropListener = (prop) => {
        var _a2;
        const entry = propProxyStates.get(prop);
        if (entry) {
          propProxyStates.delete(prop);
          (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
        }
      };
      const addListener = (listener) => {
        listeners.add(listener);
        if (listeners.size === 1) {
          propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
            if ((import.meta.env && import.meta.env.MODE) !== "production" && prevRemove) {
              throw new Error("remove already exists");
            }
            const remove = propProxyState[3](createPropListener(prop));
            propProxyStates.set(prop, [propProxyState, remove]);
          });
        }
        const removeListener = () => {
          listeners.delete(listener);
          if (listeners.size === 0) {
            propProxyStates.forEach(([propProxyState, remove], prop) => {
              if (remove) {
                remove();
                propProxyStates.set(prop, [propProxyState]);
              }
            });
          }
        };
        return removeListener;
      };
      const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
      const handler = {
        deleteProperty(target, prop) {
          const prevValue = Reflect.get(target, prop);
          removePropListener(prop);
          const deleted = Reflect.deleteProperty(target, prop);
          if (deleted) {
            notifyUpdate(["delete", [prop], prevValue]);
          }
          return deleted;
        },
        set(target, prop, value, receiver) {
          const hasPrevValue = Reflect.has(target, prop);
          const prevValue = Reflect.get(target, prop, receiver);
          if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
            return true;
          }
          removePropListener(prop);
          if (isObject(value)) {
            value = y3(value) || value;
          }
          let nextValue = value;
          if (value instanceof Promise) {
            value.then((v7) => {
              value.status = "fulfilled";
              value.value = v7;
              notifyUpdate(["resolve", [prop], v7]);
            }).catch((e11) => {
              value.status = "rejected";
              value.reason = e11;
              notifyUpdate(["reject", [prop], e11]);
            });
          } else {
            if (!proxyStateMap.has(value) && canProxy(value)) {
              nextValue = proxyFunction(value);
            }
            const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
            if (childProxyState) {
              addPropListener(prop, childProxyState);
            }
          }
          Reflect.set(target, prop, nextValue, receiver);
          notifyUpdate(["set", [prop], value, prevValue]);
          return true;
        }
      };
      const proxyObject = newProxy(baseObject, handler);
      proxyCache.set(initialObject, proxyObject);
      const proxyState = [
        baseObject,
        ensureVersion,
        createSnapshot,
        addListener
      ];
      proxyStateMap.set(proxyObject, proxyState);
      Reflect.ownKeys(initialObject).forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(
          initialObject,
          key
        );
        if ("value" in desc) {
          proxyObject[key] = initialObject[key];
          delete desc.value;
          delete desc.writable;
        }
        Object.defineProperty(baseObject, key, desc);
      });
      return proxyObject;
    }) => [
      // public functions
      proxyFunction,
      // shared state
      proxyStateMap,
      refSet,
      // internal things
      objectIs,
      newProxy,
      canProxy,
      defaultHandlePromise,
      snapCache,
      createSnapshot,
      proxyCache,
      versionHolder
    ];
    [defaultProxyFunction] = buildProxyFunction();
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i10 = 0, len = code2.length; i10 < len; ++i10) {
      lookup[i10] = code2[i10];
      revLookup[code2.charCodeAt(i10)] = i10;
    }
    var i10;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i11;
      for (i11 = 0; i11 < len2; i11 += 4) {
        tmp = revLookup[b64.charCodeAt(i11)] << 18 | revLookup[b64.charCodeAt(i11 + 1)] << 12 | revLookup[b64.charCodeAt(i11 + 2)] << 6 | revLookup[b64.charCodeAt(i11 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i11)] << 2 | revLookup[b64.charCodeAt(i11 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i11)] << 10 | revLookup[b64.charCodeAt(i11 + 1)] << 4 | revLookup[b64.charCodeAt(i11 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i11 = start; i11 < end; i11 += 3) {
        tmp = (uint8[i11] << 16 & 16711680) + (uint8[i11 + 1] << 8 & 65280) + (uint8[i11 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i11 = 0, len22 = len2 - extraBytes; i11 < len22; i11 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i11, i11 + maxChunkLength > len22 ? len22 : i11 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e11, m11;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i10 = isLE ? nBytes - 1 : 0;
      var d9 = isLE ? -1 : 1;
      var s11 = buffer[offset + i10];
      i10 += d9;
      e11 = s11 & (1 << -nBits) - 1;
      s11 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e11 = e11 * 256 + buffer[offset + i10], i10 += d9, nBits -= 8) {
      }
      m11 = e11 & (1 << -nBits) - 1;
      e11 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m11 = m11 * 256 + buffer[offset + i10], i10 += d9, nBits -= 8) {
      }
      if (e11 === 0) {
        e11 = 1 - eBias;
      } else if (e11 === eMax) {
        return m11 ? NaN : (s11 ? -1 : 1) * Infinity;
      } else {
        m11 = m11 + Math.pow(2, mLen);
        e11 = e11 - eBias;
      }
      return (s11 ? -1 : 1) * m11 * Math.pow(2, e11 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e11, m11, c8;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt4 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i10 = isLE ? 0 : nBytes - 1;
      var d9 = isLE ? 1 : -1;
      var s11 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m11 = isNaN(value) ? 1 : 0;
        e11 = eMax;
      } else {
        e11 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c8 = Math.pow(2, -e11)) < 1) {
          e11--;
          c8 *= 2;
        }
        if (e11 + eBias >= 1) {
          value += rt4 / c8;
        } else {
          value += rt4 * Math.pow(2, 1 - eBias);
        }
        if (value * c8 >= 2) {
          e11++;
          c8 /= 2;
        }
        if (e11 + eBias >= eMax) {
          m11 = 0;
          e11 = eMax;
        } else if (e11 + eBias >= 1) {
          m11 = (value * c8 - 1) * Math.pow(2, mLen);
          e11 = e11 + eBias;
        } else {
          m11 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e11 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i10] = m11 & 255, i10 += d9, m11 /= 256, mLen -= 8) {
      }
      e11 = e11 << mLen | m11;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i10] = e11 & 255, i10 += d9, e11 /= 256, eLen -= 8) {
      }
      buffer[offset + i10 - d9] |= s11 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base643 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e11) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from3(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from3(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      const b10 = fromObject(value);
      if (b10)
        return b10;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length2) {
      return from3(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString3(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string2, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string2, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length2);
      for (let i10 = 0; i10 < length2; i10 += 1) {
        buf[i10] = array[i10] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer3(b10) {
      return b10 != null && b10._isBuffer === true && b10 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a9, b10) {
      if (isInstance(a9, Uint8Array))
        a9 = Buffer2.from(a9, a9.offset, a9.byteLength);
      if (isInstance(b10, Uint8Array))
        b10 = Buffer2.from(b10, b10.offset, b10.byteLength);
      if (!Buffer2.isBuffer(a9) || !Buffer2.isBuffer(b10)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a9 === b10)
        return 0;
      let x8 = a9.length;
      let y10 = b10.length;
      for (let i10 = 0, len = Math.min(x8, y10); i10 < len; ++i10) {
        if (a9[i10] !== b10[i10]) {
          x8 = a9[i10];
          y10 = b10[i10];
          break;
        }
      }
      if (x8 < y10)
        return -1;
      if (y10 < x8)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat5(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i10;
      if (length2 === void 0) {
        length2 = 0;
        for (i10 = 0; i10 < list.length; ++i10) {
          length2 += list[i10].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length2);
      let pos = 0;
      for (i10 = 0; i10 < list.length; ++i10) {
        let buf = list[i10];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b10, n8, m11) {
      const i10 = b10[n8];
      b10[n8] = b10[m11];
      b10[m11] = i10;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i10 = 0; i10 < len; i10 += 2) {
        swap(this, i10, i10 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i10 = 0; i10 < len; i10 += 4) {
        swap(this, i10, i10 + 3);
        swap(this, i10 + 1, i10 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i10 = 0; i10 < len; i10 += 8) {
        swap(this, i10, i10 + 7);
        swap(this, i10 + 1, i10 + 6);
        swap(this, i10 + 2, i10 + 5);
        swap(this, i10 + 3, i10 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString3() {
      const length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals4(b10) {
      if (!Buffer2.isBuffer(b10))
        throw new TypeError("Argument must be a Buffer");
      if (this === b10)
        return true;
      return Buffer2.compare(this, b10) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x8 = thisEnd - thisStart;
      let y10 = end - start;
      const len = Math.min(x8, y10);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i10 = 0; i10 < len; ++i10) {
        if (thisCopy[i10] !== targetCopy[i10]) {
          x8 = thisCopy[i10];
          y10 = targetCopy[i10];
          break;
        }
      }
      if (x8 < y10)
        return -1;
      if (y10 < x8)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i11) {
        if (indexSize === 1) {
          return buf[i11];
        } else {
          return buf.readUInt16BE(i11 * indexSize);
        }
      }
      let i10;
      if (dir) {
        let foundIndex = -1;
        for (i10 = byteOffset; i10 < arrLength; i10++) {
          if (read2(arr, i10) === read2(val, foundIndex === -1 ? 0 : i10 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i10;
            if (i10 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i10 -= i10 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i10 = byteOffset; i10 >= 0; i10--) {
          let found = true;
          for (let j8 = 0; j8 < valLength; j8++) {
            if (read2(arr, i10 + j8) !== read2(val, j8)) {
              found = false;
              break;
            }
          }
          if (found)
            return i10;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i10;
      for (i10 = 0; i10 < length2; ++i10) {
        const parsed = parseInt(string2.substr(i10 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i10;
        buf[offset + i10] = parsed;
      }
      return i10;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length2);
    }
    function base64Write(buf, string2, offset, length2) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length2);
    }
    function ucs2Write(buf, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base643.fromByteArray(buf);
      } else {
        return base643.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i10 = start;
      while (i10 < end) {
        const firstByte = buf[i10];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i10 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i10 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i10 + 1];
              thirdByte = buf[i10 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i10 + 1];
              thirdByte = buf[i10 + 2];
              fourthByte = buf[i10 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i10 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i10 = 0;
      while (i10 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i10, i10 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i10 = start; i10 < end; ++i10) {
        ret += String.fromCharCode(buf[i10] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i10 = start; i10 < end; ++i10) {
        ret += String.fromCharCode(buf[i10]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i10 = start; i10 < end; ++i10) {
        out += hexSliceLookupTable[buf[i10]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i10 = 0; i10 < bytes.length - 1; i10 += 2) {
        res += String.fromCharCode(bytes[i10] + bytes[i10 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i10 = 0;
      while (++i10 < byteLength2 && (mul *= 256)) {
        val += this[offset + i10] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i10 = 0;
      while (++i10 < byteLength2 && (mul *= 256)) {
        val += this[offset + i10] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i10 = byteLength2;
      let mul = 1;
      let val = this[offset + --i10];
      while (i10 > 0 && (mul *= 256)) {
        val += this[offset + --i10] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i10 = 0;
      this[offset] = value & 255;
      while (++i10 < byteLength2 && (mul *= 256)) {
        this[offset + i10] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i10 = byteLength2 - 1;
      let mul = 1;
      this[offset + i10] = value & 255;
      while (--i10 >= 0 && (mul *= 256)) {
        this[offset + i10] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 6] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 5] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 4] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i10 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i10 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i10 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i10] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i10 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i10] = value & 255;
      while (--i10 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i10 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i10] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i10;
      if (typeof val === "number") {
        for (i10 = start; i10 < end; ++i10) {
          this[i10] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i10 = 0; i10 < end - start; ++i10) {
          this[i10 + start] = bytes[i10 % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E8(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E8(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E8(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E8(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i10 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i10 >= start + 4; i10 -= 3) {
        res = `_${val.slice(i10 - 3, i10)}${res}`;
      }
      return `${val.slice(0, i10)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length2, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length2}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units2) {
      units2 = units2 || Infinity;
      let codePoint;
      const length2 = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i10 = 0; i10 < length2; ++i10) {
        codePoint = string2.charCodeAt(i10);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units2 -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i10 + 1 === length2) {
              if ((units2 -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units2 -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units2 -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units2 -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units2 -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units2 -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i10 = 0; i10 < str.length; ++i10) {
        byteArray.push(str.charCodeAt(i10) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units2) {
      let c8, hi, lo2;
      const byteArray = [];
      for (let i10 = 0; i10 < str.length; ++i10) {
        if ((units2 -= 2) < 0)
          break;
        c8 = str.charCodeAt(i10);
        hi = c8 >> 8;
        lo2 = c8 % 256;
        byteArray.push(lo2);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base643.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      let i10;
      for (i10 = 0; i10 < length2; ++i10) {
        if (i10 + offset >= dst.length || i10 >= src2.length)
          break;
        dst[i10 + offset] = src2[i10];
      }
      return i10;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i10 = 0; i10 < 16; ++i10) {
        const i16 = i10 * 16;
        for (let j8 = 0; j8 < 16; ++j8) {
          table[i16 + j8] = alphabet2[i10] + alphabet2[j8];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn3) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn3;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@web3modal/core/dist/index.js
function D3(e11) {
  const t8 = Object.fromEntries(Object.entries(e11).filter(([n8, a9]) => typeof a9 < "u" && a9 !== null && a9 !== "").map(([n8, a9]) => [n8, a9.toString()]));
  return new URLSearchParams(t8).toString();
}
function y4() {
  const { projectId: e11 } = S2.state;
  if (!e11)
    throw new Error("projectId is required to work with explorer api");
  return e11;
}
function $5() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
var import_buffer, L2, p3, o2, A4, d2, s2, i2, b4, S2, W3, I4, h5, _3, r, g4, m3, x3, P4, E4, j, k3, O4, M5, w5, B3, C4, H5;
var init_dist = __esm({
  "node_modules/@web3modal/core/dist/index.js"() {
    init_vanilla();
    import_buffer = __toESM(require_buffer2(), 1);
    p3 = { ethereumClient: void 0, setEthereumClient(e11) {
      L2 = e11;
    }, client() {
      if (L2)
        return L2;
      throw new Error("ClientCtrl has no client set");
    } };
    o2 = proxy({ address: void 0, profileName: void 0, profileAvatar: void 0, profileLoading: false, balanceLoading: false, balance: void 0, isConnected: false });
    A4 = { state: o2, subscribe(e11) {
      return subscribe(o2, () => e11(o2));
    }, getAccount() {
      const e11 = p3.client().getAccount();
      o2.address = e11.address, o2.isConnected = e11.isConnected;
    }, async fetchProfile(e11, t8) {
      try {
        o2.profileLoading = true;
        const n8 = t8 ?? o2.address, { id: a9 } = p3.client().getDefaultChain();
        if (n8 && a9 === 1) {
          const [l9, c8] = await Promise.all([p3.client().fetchEnsName({ address: n8, chainId: 1 }), p3.client().fetchEnsAvatar({ address: n8, chainId: 1 })]);
          c8 && await e11(c8), o2.profileName = l9, o2.profileAvatar = c8;
        }
      } finally {
        o2.profileLoading = false;
      }
    }, async fetchBalance(e11) {
      try {
        o2.balanceLoading = true;
        const t8 = e11 ?? o2.address;
        if (t8) {
          const n8 = await p3.client().fetchBalance({ address: t8 });
          o2.balance = { amount: n8.formatted, symbol: n8.symbol };
        }
      } finally {
        o2.balanceLoading = false;
      }
    }, setAddress(e11) {
      o2.address = e11;
    }, setIsConnected(e11) {
      o2.isConnected = e11;
    }, resetBalance() {
      o2.balance = void 0;
    }, resetAccount() {
      o2.address = void 0, o2.isConnected = false, o2.profileName = void 0, o2.profileAvatar = void 0, o2.balance = void 0;
    } };
    d2 = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", W3M_VERSION: "W3M_VERSION", isMobile() {
      return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : false;
    }, isAndroid() {
      return d2.isMobile() && navigator.userAgent.toLowerCase().includes("android");
    }, isEmptyObject(e11) {
      return Object.getPrototypeOf(e11) === Object.prototype && Object.getOwnPropertyNames(e11).length === 0 && Object.getOwnPropertySymbols(e11).length === 0;
    }, isHttpUrl(e11) {
      return e11.startsWith("http://") || e11.startsWith("https://");
    }, formatNativeUrl(e11, t8, n8) {
      if (d2.isHttpUrl(e11))
        return this.formatUniversalUrl(e11, t8, n8);
      let a9 = e11;
      a9.includes("://") || (a9 = e11.replaceAll("/", "").replaceAll(":", ""), a9 = `${a9}://`), this.setWalletConnectDeepLink(a9, n8);
      const l9 = encodeURIComponent(t8);
      return `${a9}wc?uri=${l9}`;
    }, formatUniversalUrl(e11, t8, n8) {
      if (!d2.isHttpUrl(e11))
        return this.formatNativeUrl(e11, t8, n8);
      let a9 = e11;
      e11.endsWith("/") && (a9 = e11.slice(0, -1)), this.setWalletConnectDeepLink(a9, n8);
      const l9 = encodeURIComponent(t8);
      return `${a9}/wc?uri=${l9}`;
    }, async wait(e11) {
      return new Promise((t8) => {
        setTimeout(t8, e11);
      });
    }, openHref(e11, t8) {
      window.open(e11, t8, "noreferrer noopener");
    }, setWalletConnectDeepLink(e11, t8) {
      localStorage.setItem(d2.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e11, name: t8 }));
    }, setWalletConnectAndroidDeepLink(e11) {
      const [t8] = e11.split("?");
      localStorage.setItem(d2.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t8, name: "Android" }));
    }, removeWalletConnectDeepLink() {
      localStorage.removeItem(d2.WALLETCONNECT_DEEPLINK_CHOICE);
    }, isNull(e11) {
      return e11 === null;
    }, setWeb3ModalVersionInStorage() {
      typeof localStorage < "u" && localStorage.setItem(d2.W3M_VERSION, "2.2.2");
    } };
    s2 = proxy({ selectedChain: void 0, chains: void 0, standaloneChains: void 0, standaloneUri: void 0, isStandalone: false, isCustomDesktop: false, isCustomMobile: false, isDataLoaded: false, isUiLoaded: false, walletConnectVersion: 1 });
    i2 = { state: s2, subscribe(e11) {
      return subscribe(s2, () => e11(s2));
    }, setChains(e11) {
      s2.chains = e11;
    }, setStandaloneChains(e11) {
      s2.standaloneChains = e11;
    }, setStandaloneUri(e11) {
      s2.standaloneUri = e11;
    }, getSelectedChain() {
      const e11 = p3.client().getNetwork().chain;
      return e11 && (s2.selectedChain = e11), s2.selectedChain;
    }, setSelectedChain(e11) {
      s2.selectedChain = e11;
    }, setIsStandalone(e11) {
      s2.isStandalone = e11;
    }, setIsCustomDesktop(e11) {
      s2.isCustomDesktop = e11;
    }, setIsCustomMobile(e11) {
      s2.isCustomMobile = e11;
    }, setIsDataLoaded(e11) {
      s2.isDataLoaded = e11;
    }, setIsUiLoaded(e11) {
      s2.isUiLoaded = e11;
    }, setWalletConnectVersion(e11) {
      s2.walletConnectVersion = e11;
    } };
    b4 = proxy({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chainImages: void 0, tokenImages: void 0, standaloneChains: void 0, enableStandaloneMode: false, enableNetworkView: false, enableAccountView: true, enableExplorer: true, defaultChain: void 0, explorerAllowList: void 0, explorerDenyList: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 });
    S2 = { state: b4, subscribe(e11) {
      return subscribe(b4, () => e11(b4));
    }, setConfig(e11) {
      var t8, n8, a9, l9;
      if (i2.setStandaloneChains(e11.standaloneChains), i2.setIsStandalone(!!((t8 = e11.standaloneChains) != null && t8.length) || !!e11.enableStandaloneMode), i2.setIsCustomMobile(!!((n8 = e11.mobileWallets) != null && n8.length)), i2.setIsCustomDesktop(!!((a9 = e11.desktopWallets) != null && a9.length)), i2.setWalletConnectVersion((l9 = e11.walletConnectVersion) != null ? l9 : 1), !i2.state.isStandalone) {
        const c8 = p3.client().getDefaultChain();
        i2.setSelectedChain(c8), i2.setChains(p3.client().chains);
      }
      e11.defaultChain && i2.setSelectedChain(e11.defaultChain), d2.setWeb3ModalVersionInStorage(), Object.assign(b4, e11);
    } };
    W3 = "https://explorer-api.walletconnect.com";
    I4 = { async fetchWallets(e11, t8) {
      const n8 = D3(t8), a9 = `${W3}/v3/wallets?projectId=${e11}&${n8}`;
      return (await fetch(a9)).json();
    }, formatImageUrl(e11, t8) {
      return `${W3}/v3/logo/lg/${t8}?projectId=${e11}`;
    } };
    h5 = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, previewWallets: [], recomendedWallets: [] });
    _3 = { state: h5, async getPreviewWallets(e11) {
      const { listings: t8 } = await I4.fetchWallets(y4(), e11);
      return h5.previewWallets = Object.values(t8), h5.previewWallets;
    }, async getRecomendedWallets() {
      const { listings: e11 } = await I4.fetchWallets(y4(), { page: 1, entries: 6 });
      h5.recomendedWallets = Object.values(e11);
    }, async getPaginatedWallets(e11) {
      const { page: t8, search: n8 } = e11, { listings: a9, total: l9 } = await I4.fetchWallets(y4(), e11), c8 = Object.values(a9), v7 = n8 ? "search" : "wallets";
      return h5[v7] = { listings: [...h5[v7].listings, ...c8], total: l9, page: t8 ?? 1 }, { listings: c8, total: l9 };
    }, getImageUrl(e11) {
      return I4.formatImageUrl(y4(), e11);
    }, resetSearch() {
      h5.search = { listings: [], total: 0, page: 1 };
    } };
    r = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
    g4 = { state: r, subscribe(e11) {
      return subscribe(r, () => e11(r));
    }, push(e11, t8) {
      e11 !== r.view && (r.view = e11, t8 && (r.data = t8), r.history.push(e11));
    }, replace(e11) {
      r.view = e11, r.history = [e11];
    }, goBack() {
      if (r.history.length > 1) {
        r.history.pop();
        const [e11] = r.history.slice(-1);
        r.view = e11;
      }
    } };
    m3 = proxy({ open: false });
    x3 = { state: m3, subscribe(e11) {
      return subscribe(m3, () => e11(m3));
    }, async open(e11) {
      return new Promise((t8) => {
        const { isStandalone: n8, isUiLoaded: a9, isDataLoaded: l9 } = i2.state, { isConnected: c8 } = A4.state, { enableNetworkView: v7 } = S2.state;
        if (n8 ? (i2.setStandaloneUri(e11?.uri), i2.setStandaloneChains(e11?.standaloneChains), g4.replace("ConnectWallet")) : e11 != null && e11.route ? g4.replace(e11.route) : c8 ? g4.replace("Account") : v7 ? g4.replace("SelectNetwork") : g4.replace("ConnectWallet"), a9 && l9)
          m3.open = true, t8();
        else {
          const N16 = setInterval(() => {
            i2.state.isUiLoaded && i2.state.isDataLoaded && (clearInterval(N16), m3.open = true, t8());
          }, 200);
        }
      });
    }, close() {
      m3.open = false;
    } };
    P4 = Object.defineProperty;
    E4 = Object.getOwnPropertySymbols;
    j = Object.prototype.hasOwnProperty;
    k3 = Object.prototype.propertyIsEnumerable;
    O4 = (e11, t8, n8) => t8 in e11 ? P4(e11, t8, { enumerable: true, configurable: true, writable: true, value: n8 }) : e11[t8] = n8;
    M5 = (e11, t8) => {
      for (var n8 in t8 || (t8 = {}))
        j.call(t8, n8) && O4(e11, n8, t8[n8]);
      if (E4)
        for (var n8 of E4(t8))
          k3.call(t8, n8) && O4(e11, n8, t8[n8]);
      return e11;
    };
    w5 = proxy({ themeMode: $5() ? "dark" : "light" });
    B3 = { state: w5, subscribe(e11) {
      return subscribe(w5, () => e11(w5));
    }, setThemeConfig(e11) {
      const { themeMode: t8, themeVariables: n8 } = e11;
      t8 && (w5.themeMode = t8), n8 && (w5.themeVariables = M5({}, n8));
    } };
    C4 = proxy({ open: false, message: "", variant: "success" });
    H5 = { state: C4, subscribe(e11) {
      return subscribe(C4, () => e11(C4));
    }, openToast(e11, t8) {
      C4.open = true, C4.message = e11, C4.variant = t8;
    }, closeToast() {
      C4.open = false;
    } };
    typeof window < "u" && (window.Buffer || (window.Buffer = import_buffer.Buffer), window.global || (window.global = window), window.process || (window.process = { env: {} }));
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t2, e2, s3, n2, o3, r2, i3, S3, c3;
var init_css_tag = __esm({
  "node_modules/@lit/reactive-element/css-tag.js"() {
    t2 = window;
    e2 = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    s3 = Symbol();
    n2 = /* @__PURE__ */ new WeakMap();
    o3 = class {
      constructor(t8, e11, n8) {
        if (this._$cssResult$ = true, n8 !== s3)
          throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t8, this.t = e11;
      }
      get styleSheet() {
        let t8 = this.o;
        const s11 = this.t;
        if (e2 && void 0 === t8) {
          const e11 = void 0 !== s11 && 1 === s11.length;
          e11 && (t8 = n2.get(s11)), void 0 === t8 && ((this.o = t8 = new CSSStyleSheet()).replaceSync(this.cssText), e11 && n2.set(s11, t8));
        }
        return t8;
      }
      toString() {
        return this.cssText;
      }
    };
    r2 = (t8) => new o3("string" == typeof t8 ? t8 : t8 + "", void 0, s3);
    i3 = (t8, ...e11) => {
      const n8 = 1 === t8.length ? t8[0] : e11.reduce((e12, s11, n9) => e12 + ((t9) => {
        if (true === t9._$cssResult$)
          return t9.cssText;
        if ("number" == typeof t9)
          return t9;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t9 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      })(s11) + t8[n9 + 1], t8[0]);
      return new o3(n8, t8, s3);
    };
    S3 = (s11, n8) => {
      e2 ? s11.adoptedStyleSheets = n8.map((t8) => t8 instanceof CSSStyleSheet ? t8 : t8.styleSheet) : n8.forEach((e11) => {
        const n9 = document.createElement("style"), o11 = t2.litNonce;
        void 0 !== o11 && n9.setAttribute("nonce", o11), n9.textContent = e11.cssText, s11.appendChild(n9);
      });
    };
    c3 = e2 ? (t8) => t8 : (t8) => t8 instanceof CSSStyleSheet ? ((t9) => {
      let e11 = "";
      for (const s11 of t9.cssRules)
        e11 += s11.cssText;
      return r2(e11);
    })(t8) : t8;
  }
});

// node_modules/@lit/reactive-element/reactive-element.js
var s4, e3, r3, h6, o4, n3, a3, l2, d3;
var init_reactive_element = __esm({
  "node_modules/@lit/reactive-element/reactive-element.js"() {
    init_css_tag();
    init_css_tag();
    e3 = window;
    r3 = e3.trustedTypes;
    h6 = r3 ? r3.emptyScript : "";
    o4 = e3.reactiveElementPolyfillSupport;
    n3 = { toAttribute(t8, i10) {
      switch (i10) {
        case Boolean:
          t8 = t8 ? h6 : null;
          break;
        case Object:
        case Array:
          t8 = null == t8 ? t8 : JSON.stringify(t8);
      }
      return t8;
    }, fromAttribute(t8, i10) {
      let s11 = t8;
      switch (i10) {
        case Boolean:
          s11 = null !== t8;
          break;
        case Number:
          s11 = null === t8 ? null : Number(t8);
          break;
        case Object:
        case Array:
          try {
            s11 = JSON.parse(t8);
          } catch (t9) {
            s11 = null;
          }
      }
      return s11;
    } };
    a3 = (t8, i10) => i10 !== t8 && (i10 == i10 || t8 == t8);
    l2 = { attribute: true, type: String, converter: n3, reflect: false, hasChanged: a3 };
    d3 = class extends HTMLElement {
      constructor() {
        super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
      }
      static addInitializer(t8) {
        var i10;
        this.finalize(), (null !== (i10 = this.h) && void 0 !== i10 ? i10 : this.h = []).push(t8);
      }
      static get observedAttributes() {
        this.finalize();
        const t8 = [];
        return this.elementProperties.forEach((i10, s11) => {
          const e11 = this._$Ep(s11, i10);
          void 0 !== e11 && (this._$Ev.set(e11, s11), t8.push(e11));
        }), t8;
      }
      static createProperty(t8, i10 = l2) {
        if (i10.state && (i10.attribute = false), this.finalize(), this.elementProperties.set(t8, i10), !i10.noAccessor && !this.prototype.hasOwnProperty(t8)) {
          const s11 = "symbol" == typeof t8 ? Symbol() : "__" + t8, e11 = this.getPropertyDescriptor(t8, s11, i10);
          void 0 !== e11 && Object.defineProperty(this.prototype, t8, e11);
        }
      }
      static getPropertyDescriptor(t8, i10, s11) {
        return { get() {
          return this[i10];
        }, set(e11) {
          const r7 = this[t8];
          this[i10] = e11, this.requestUpdate(t8, r7, s11);
        }, configurable: true, enumerable: true };
      }
      static getPropertyOptions(t8) {
        return this.elementProperties.get(t8) || l2;
      }
      static finalize() {
        if (this.hasOwnProperty("finalized"))
          return false;
        this.finalized = true;
        const t8 = Object.getPrototypeOf(this);
        if (t8.finalize(), void 0 !== t8.h && (this.h = [...t8.h]), this.elementProperties = new Map(t8.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
          const t9 = this.properties, i10 = [...Object.getOwnPropertyNames(t9), ...Object.getOwnPropertySymbols(t9)];
          for (const s11 of i10)
            this.createProperty(s11, t9[s11]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), true;
      }
      static finalizeStyles(i10) {
        const s11 = [];
        if (Array.isArray(i10)) {
          const e11 = new Set(i10.flat(1 / 0).reverse());
          for (const i11 of e11)
            s11.unshift(c3(i11));
        } else
          void 0 !== i10 && s11.push(c3(i10));
        return s11;
      }
      static _$Ep(t8, i10) {
        const s11 = i10.attribute;
        return false === s11 ? void 0 : "string" == typeof s11 ? s11 : "string" == typeof t8 ? t8.toLowerCase() : void 0;
      }
      u() {
        var t8;
        this._$E_ = new Promise((t9) => this.enableUpdating = t9), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t8 = this.constructor.h) || void 0 === t8 || t8.forEach((t9) => t9(this));
      }
      addController(t8) {
        var i10, s11;
        (null !== (i10 = this._$ES) && void 0 !== i10 ? i10 : this._$ES = []).push(t8), void 0 !== this.renderRoot && this.isConnected && (null === (s11 = t8.hostConnected) || void 0 === s11 || s11.call(t8));
      }
      removeController(t8) {
        var i10;
        null === (i10 = this._$ES) || void 0 === i10 || i10.splice(this._$ES.indexOf(t8) >>> 0, 1);
      }
      _$Eg() {
        this.constructor.elementProperties.forEach((t8, i10) => {
          this.hasOwnProperty(i10) && (this._$Ei.set(i10, this[i10]), delete this[i10]);
        });
      }
      createRenderRoot() {
        var t8;
        const s11 = null !== (t8 = this.shadowRoot) && void 0 !== t8 ? t8 : this.attachShadow(this.constructor.shadowRootOptions);
        return S3(s11, this.constructor.elementStyles), s11;
      }
      connectedCallback() {
        var t8;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t8 = this._$ES) || void 0 === t8 || t8.forEach((t9) => {
          var i10;
          return null === (i10 = t9.hostConnected) || void 0 === i10 ? void 0 : i10.call(t9);
        });
      }
      enableUpdating(t8) {
      }
      disconnectedCallback() {
        var t8;
        null === (t8 = this._$ES) || void 0 === t8 || t8.forEach((t9) => {
          var i10;
          return null === (i10 = t9.hostDisconnected) || void 0 === i10 ? void 0 : i10.call(t9);
        });
      }
      attributeChangedCallback(t8, i10, s11) {
        this._$AK(t8, s11);
      }
      _$EO(t8, i10, s11 = l2) {
        var e11;
        const r7 = this.constructor._$Ep(t8, s11);
        if (void 0 !== r7 && true === s11.reflect) {
          const h11 = (void 0 !== (null === (e11 = s11.converter) || void 0 === e11 ? void 0 : e11.toAttribute) ? s11.converter : n3).toAttribute(i10, s11.type);
          this._$El = t8, null == h11 ? this.removeAttribute(r7) : this.setAttribute(r7, h11), this._$El = null;
        }
      }
      _$AK(t8, i10) {
        var s11;
        const e11 = this.constructor, r7 = e11._$Ev.get(t8);
        if (void 0 !== r7 && this._$El !== r7) {
          const t9 = e11.getPropertyOptions(r7), h11 = "function" == typeof t9.converter ? { fromAttribute: t9.converter } : void 0 !== (null === (s11 = t9.converter) || void 0 === s11 ? void 0 : s11.fromAttribute) ? t9.converter : n3;
          this._$El = r7, this[r7] = h11.fromAttribute(i10, t9.type), this._$El = null;
        }
      }
      requestUpdate(t8, i10, s11) {
        let e11 = true;
        void 0 !== t8 && (((s11 = s11 || this.constructor.getPropertyOptions(t8)).hasChanged || a3)(this[t8], i10) ? (this._$AL.has(t8) || this._$AL.set(t8, i10), true === s11.reflect && this._$El !== t8 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t8, s11))) : e11 = false), !this.isUpdatePending && e11 && (this._$E_ = this._$Ej());
      }
      async _$Ej() {
        this.isUpdatePending = true;
        try {
          await this._$E_;
        } catch (t9) {
          Promise.reject(t9);
        }
        const t8 = this.scheduleUpdate();
        return null != t8 && await t8, !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        var t8;
        if (!this.isUpdatePending)
          return;
        this.hasUpdated, this._$Ei && (this._$Ei.forEach((t9, i11) => this[i11] = t9), this._$Ei = void 0);
        let i10 = false;
        const s11 = this._$AL;
        try {
          i10 = this.shouldUpdate(s11), i10 ? (this.willUpdate(s11), null === (t8 = this._$ES) || void 0 === t8 || t8.forEach((t9) => {
            var i11;
            return null === (i11 = t9.hostUpdate) || void 0 === i11 ? void 0 : i11.call(t9);
          }), this.update(s11)) : this._$Ek();
        } catch (t9) {
          throw i10 = false, this._$Ek(), t9;
        }
        i10 && this._$AE(s11);
      }
      willUpdate(t8) {
      }
      _$AE(t8) {
        var i10;
        null === (i10 = this._$ES) || void 0 === i10 || i10.forEach((t9) => {
          var i11;
          return null === (i11 = t9.hostUpdated) || void 0 === i11 ? void 0 : i11.call(t9);
        }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t8)), this.updated(t8);
      }
      _$Ek() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$E_;
      }
      shouldUpdate(t8) {
        return true;
      }
      update(t8) {
        void 0 !== this._$EC && (this._$EC.forEach((t9, i10) => this._$EO(i10, this[i10], t9)), this._$EC = void 0), this._$Ek();
      }
      updated(t8) {
      }
      firstUpdated(t8) {
      }
    };
    d3.finalized = true, d3.elementProperties = /* @__PURE__ */ new Map(), d3.elementStyles = [], d3.shadowRootOptions = { mode: "open" }, null == o4 || o4({ ReactiveElement: d3 }), (null !== (s4 = e3.reactiveElementVersions) && void 0 !== s4 ? s4 : e3.reactiveElementVersions = []).push("1.6.1");
  }
});

// node_modules/lit-html/lit-html.js
function N12(t8, i10, s11 = t8, e11) {
  var o11, n8, l9, h11;
  if (i10 === T)
    return i10;
  let r7 = void 0 !== e11 ? null === (o11 = s11._$Co) || void 0 === o11 ? void 0 : o11[e11] : s11._$Cl;
  const d9 = u5(i10) ? void 0 : i10._$litDirective$;
  return (null == r7 ? void 0 : r7.constructor) !== d9 && (null === (n8 = null == r7 ? void 0 : r7._$AO) || void 0 === n8 || n8.call(r7, false), void 0 === d9 ? r7 = void 0 : (r7 = new d9(t8), r7._$AT(t8, s11, e11)), void 0 !== e11 ? (null !== (l9 = (h11 = s11)._$Co) && void 0 !== l9 ? l9 : h11._$Co = [])[e11] = r7 : s11._$Cl = r7), void 0 !== r7 && (i10 = N12(t8, r7._$AS(t8, i10.values), r7, e11)), i10;
}
var t3, i4, s5, e4, o5, n4, l3, h7, r4, d4, u5, c4, v3, a4, f2, _4, m4, p4, g5, $6, y5, w6, x4, b5, T, A5, E5, C5, P5, V3, S4, M6, R2, k4, H6, I5, L3, z4, j2, B4;
var init_lit_html = __esm({
  "node_modules/lit-html/lit-html.js"() {
    i4 = window;
    s5 = i4.trustedTypes;
    e4 = s5 ? s5.createPolicy("lit-html", { createHTML: (t8) => t8 }) : void 0;
    o5 = "$lit$";
    n4 = `lit$${(Math.random() + "").slice(9)}$`;
    l3 = "?" + n4;
    h7 = `<${l3}>`;
    r4 = document;
    d4 = () => r4.createComment("");
    u5 = (t8) => null === t8 || "object" != typeof t8 && "function" != typeof t8;
    c4 = Array.isArray;
    v3 = (t8) => c4(t8) || "function" == typeof (null == t8 ? void 0 : t8[Symbol.iterator]);
    a4 = "[ 	\n\f\r]";
    f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    _4 = /-->/g;
    m4 = />/g;
    p4 = RegExp(`>|${a4}(?:([^\\s"'>=/]+)(${a4}*=${a4}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
    g5 = /'/g;
    $6 = /"/g;
    y5 = /^(?:script|style|textarea|title)$/i;
    w6 = (t8) => (i10, ...s11) => ({ _$litType$: t8, strings: i10, values: s11 });
    x4 = w6(1);
    b5 = w6(2);
    T = Symbol.for("lit-noChange");
    A5 = Symbol.for("lit-nothing");
    E5 = /* @__PURE__ */ new WeakMap();
    C5 = r4.createTreeWalker(r4, 129, null, false);
    P5 = (t8, i10) => {
      const s11 = t8.length - 1, l9 = [];
      let r7, d9 = 2 === i10 ? "<svg>" : "", u9 = f2;
      for (let i11 = 0; i11 < s11; i11++) {
        const s12 = t8[i11];
        let e11, c9, v7 = -1, a9 = 0;
        for (; a9 < s12.length && (u9.lastIndex = a9, c9 = u9.exec(s12), null !== c9); )
          a9 = u9.lastIndex, u9 === f2 ? "!--" === c9[1] ? u9 = _4 : void 0 !== c9[1] ? u9 = m4 : void 0 !== c9[2] ? (y5.test(c9[2]) && (r7 = RegExp("</" + c9[2], "g")), u9 = p4) : void 0 !== c9[3] && (u9 = p4) : u9 === p4 ? ">" === c9[0] ? (u9 = null != r7 ? r7 : f2, v7 = -1) : void 0 === c9[1] ? v7 = -2 : (v7 = u9.lastIndex - c9[2].length, e11 = c9[1], u9 = void 0 === c9[3] ? p4 : '"' === c9[3] ? $6 : g5) : u9 === $6 || u9 === g5 ? u9 = p4 : u9 === _4 || u9 === m4 ? u9 = f2 : (u9 = p4, r7 = void 0);
        const w11 = u9 === p4 && t8[i11 + 1].startsWith("/>") ? " " : "";
        d9 += u9 === f2 ? s12 + h7 : v7 >= 0 ? (l9.push(e11), s12.slice(0, v7) + o5 + s12.slice(v7) + n4 + w11) : s12 + n4 + (-2 === v7 ? (l9.push(void 0), i11) : w11);
      }
      const c8 = d9 + (t8[s11] || "<?>") + (2 === i10 ? "</svg>" : "");
      if (!Array.isArray(t8) || !t8.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
      return [void 0 !== e4 ? e4.createHTML(c8) : c8, l9];
    };
    V3 = class {
      constructor({ strings: t8, _$litType$: i10 }, e11) {
        let h11;
        this.parts = [];
        let r7 = 0, u9 = 0;
        const c8 = t8.length - 1, v7 = this.parts, [a9, f7] = P5(t8, i10);
        if (this.el = V3.createElement(a9, e11), C5.currentNode = this.el.content, 2 === i10) {
          const t9 = this.el.content, i11 = t9.firstChild;
          i11.remove(), t9.append(...i11.childNodes);
        }
        for (; null !== (h11 = C5.nextNode()) && v7.length < c8; ) {
          if (1 === h11.nodeType) {
            if (h11.hasAttributes()) {
              const t9 = [];
              for (const i11 of h11.getAttributeNames())
                if (i11.endsWith(o5) || i11.startsWith(n4)) {
                  const s11 = f7[u9++];
                  if (t9.push(i11), void 0 !== s11) {
                    const t10 = h11.getAttribute(s11.toLowerCase() + o5).split(n4), i12 = /([.?@])?(.*)/.exec(s11);
                    v7.push({ type: 1, index: r7, name: i12[2], strings: t10, ctor: "." === i12[1] ? k4 : "?" === i12[1] ? I5 : "@" === i12[1] ? L3 : R2 });
                  } else
                    v7.push({ type: 6, index: r7 });
                }
              for (const i11 of t9)
                h11.removeAttribute(i11);
            }
            if (y5.test(h11.tagName)) {
              const t9 = h11.textContent.split(n4), i11 = t9.length - 1;
              if (i11 > 0) {
                h11.textContent = s5 ? s5.emptyScript : "";
                for (let s11 = 0; s11 < i11; s11++)
                  h11.append(t9[s11], d4()), C5.nextNode(), v7.push({ type: 2, index: ++r7 });
                h11.append(t9[i11], d4());
              }
            }
          } else if (8 === h11.nodeType)
            if (h11.data === l3)
              v7.push({ type: 2, index: r7 });
            else {
              let t9 = -1;
              for (; -1 !== (t9 = h11.data.indexOf(n4, t9 + 1)); )
                v7.push({ type: 7, index: r7 }), t9 += n4.length - 1;
            }
          r7++;
        }
      }
      static createElement(t8, i10) {
        const s11 = r4.createElement("template");
        return s11.innerHTML = t8, s11;
      }
    };
    S4 = class {
      constructor(t8, i10) {
        this.u = [], this._$AN = void 0, this._$AD = t8, this._$AM = i10;
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      v(t8) {
        var i10;
        const { el: { content: s11 }, parts: e11 } = this._$AD, o11 = (null !== (i10 = null == t8 ? void 0 : t8.creationScope) && void 0 !== i10 ? i10 : r4).importNode(s11, true);
        C5.currentNode = o11;
        let n8 = C5.nextNode(), l9 = 0, h11 = 0, d9 = e11[0];
        for (; void 0 !== d9; ) {
          if (l9 === d9.index) {
            let i11;
            2 === d9.type ? i11 = new M6(n8, n8.nextSibling, this, t8) : 1 === d9.type ? i11 = new d9.ctor(n8, d9.name, d9.strings, this, t8) : 6 === d9.type && (i11 = new z4(n8, this, t8)), this.u.push(i11), d9 = e11[++h11];
          }
          l9 !== (null == d9 ? void 0 : d9.index) && (n8 = C5.nextNode(), l9++);
        }
        return o11;
      }
      p(t8) {
        let i10 = 0;
        for (const s11 of this.u)
          void 0 !== s11 && (void 0 !== s11.strings ? (s11._$AI(t8, s11, i10), i10 += s11.strings.length - 2) : s11._$AI(t8[i10])), i10++;
      }
    };
    M6 = class {
      constructor(t8, i10, s11, e11) {
        var o11;
        this.type = 2, this._$AH = A5, this._$AN = void 0, this._$AA = t8, this._$AB = i10, this._$AM = s11, this.options = e11, this._$Cm = null === (o11 = null == e11 ? void 0 : e11.isConnected) || void 0 === o11 || o11;
      }
      get _$AU() {
        var t8, i10;
        return null !== (i10 = null === (t8 = this._$AM) || void 0 === t8 ? void 0 : t8._$AU) && void 0 !== i10 ? i10 : this._$Cm;
      }
      get parentNode() {
        let t8 = this._$AA.parentNode;
        const i10 = this._$AM;
        return void 0 !== i10 && 11 === (null == t8 ? void 0 : t8.nodeType) && (t8 = i10.parentNode), t8;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(t8, i10 = this) {
        t8 = N12(this, t8, i10), u5(t8) ? t8 === A5 || null == t8 || "" === t8 ? (this._$AH !== A5 && this._$AR(), this._$AH = A5) : t8 !== this._$AH && t8 !== T && this.g(t8) : void 0 !== t8._$litType$ ? this.$(t8) : void 0 !== t8.nodeType ? this.T(t8) : v3(t8) ? this.k(t8) : this.g(t8);
      }
      S(t8) {
        return this._$AA.parentNode.insertBefore(t8, this._$AB);
      }
      T(t8) {
        this._$AH !== t8 && (this._$AR(), this._$AH = this.S(t8));
      }
      g(t8) {
        this._$AH !== A5 && u5(this._$AH) ? this._$AA.nextSibling.data = t8 : this.T(r4.createTextNode(t8)), this._$AH = t8;
      }
      $(t8) {
        var i10;
        const { values: s11, _$litType$: e11 } = t8, o11 = "number" == typeof e11 ? this._$AC(t8) : (void 0 === e11.el && (e11.el = V3.createElement(e11.h, this.options)), e11);
        if ((null === (i10 = this._$AH) || void 0 === i10 ? void 0 : i10._$AD) === o11)
          this._$AH.p(s11);
        else {
          const t9 = new S4(o11, this), i11 = t9.v(this.options);
          t9.p(s11), this.T(i11), this._$AH = t9;
        }
      }
      _$AC(t8) {
        let i10 = E5.get(t8.strings);
        return void 0 === i10 && E5.set(t8.strings, i10 = new V3(t8)), i10;
      }
      k(t8) {
        c4(this._$AH) || (this._$AH = [], this._$AR());
        const i10 = this._$AH;
        let s11, e11 = 0;
        for (const o11 of t8)
          e11 === i10.length ? i10.push(s11 = new M6(this.S(d4()), this.S(d4()), this, this.options)) : s11 = i10[e11], s11._$AI(o11), e11++;
        e11 < i10.length && (this._$AR(s11 && s11._$AB.nextSibling, e11), i10.length = e11);
      }
      _$AR(t8 = this._$AA.nextSibling, i10) {
        var s11;
        for (null === (s11 = this._$AP) || void 0 === s11 || s11.call(this, false, true, i10); t8 && t8 !== this._$AB; ) {
          const i11 = t8.nextSibling;
          t8.remove(), t8 = i11;
        }
      }
      setConnected(t8) {
        var i10;
        void 0 === this._$AM && (this._$Cm = t8, null === (i10 = this._$AP) || void 0 === i10 || i10.call(this, t8));
      }
    };
    R2 = class {
      constructor(t8, i10, s11, e11, o11) {
        this.type = 1, this._$AH = A5, this._$AN = void 0, this.element = t8, this.name = i10, this._$AM = e11, this.options = o11, s11.length > 2 || "" !== s11[0] || "" !== s11[1] ? (this._$AH = Array(s11.length - 1).fill(new String()), this.strings = s11) : this._$AH = A5;
      }
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t8, i10 = this, s11, e11) {
        const o11 = this.strings;
        let n8 = false;
        if (void 0 === o11)
          t8 = N12(this, t8, i10, 0), n8 = !u5(t8) || t8 !== this._$AH && t8 !== T, n8 && (this._$AH = t8);
        else {
          const e12 = t8;
          let l9, h11;
          for (t8 = o11[0], l9 = 0; l9 < o11.length - 1; l9++)
            h11 = N12(this, e12[s11 + l9], i10, l9), h11 === T && (h11 = this._$AH[l9]), n8 || (n8 = !u5(h11) || h11 !== this._$AH[l9]), h11 === A5 ? t8 = A5 : t8 !== A5 && (t8 += (null != h11 ? h11 : "") + o11[l9 + 1]), this._$AH[l9] = h11;
        }
        n8 && !e11 && this.j(t8);
      }
      j(t8) {
        t8 === A5 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t8 ? t8 : "");
      }
    };
    k4 = class extends R2 {
      constructor() {
        super(...arguments), this.type = 3;
      }
      j(t8) {
        this.element[this.name] = t8 === A5 ? void 0 : t8;
      }
    };
    H6 = s5 ? s5.emptyScript : "";
    I5 = class extends R2 {
      constructor() {
        super(...arguments), this.type = 4;
      }
      j(t8) {
        t8 && t8 !== A5 ? this.element.setAttribute(this.name, H6) : this.element.removeAttribute(this.name);
      }
    };
    L3 = class extends R2 {
      constructor(t8, i10, s11, e11, o11) {
        super(t8, i10, s11, e11, o11), this.type = 5;
      }
      _$AI(t8, i10 = this) {
        var s11;
        if ((t8 = null !== (s11 = N12(this, t8, i10, 0)) && void 0 !== s11 ? s11 : A5) === T)
          return;
        const e11 = this._$AH, o11 = t8 === A5 && e11 !== A5 || t8.capture !== e11.capture || t8.once !== e11.once || t8.passive !== e11.passive, n8 = t8 !== A5 && (e11 === A5 || o11);
        o11 && this.element.removeEventListener(this.name, this, e11), n8 && this.element.addEventListener(this.name, this, t8), this._$AH = t8;
      }
      handleEvent(t8) {
        var i10, s11;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s11 = null === (i10 = this.options) || void 0 === i10 ? void 0 : i10.host) && void 0 !== s11 ? s11 : this.element, t8) : this._$AH.handleEvent(t8);
      }
    };
    z4 = class {
      constructor(t8, i10, s11) {
        this.element = t8, this.type = 6, this._$AN = void 0, this._$AM = i10, this.options = s11;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t8) {
        N12(this, t8);
      }
    };
    j2 = i4.litHtmlPolyfillSupport;
    null == j2 || j2(V3, M6), (null !== (t3 = i4.litHtmlVersions) && void 0 !== t3 ? t3 : i4.litHtmlVersions = []).push("2.7.0");
    B4 = (t8, i10, s11) => {
      var e11, o11;
      const n8 = null !== (e11 = null == s11 ? void 0 : s11.renderBefore) && void 0 !== e11 ? e11 : i10;
      let l9 = n8._$litPart$;
      if (void 0 === l9) {
        const t9 = null !== (o11 = null == s11 ? void 0 : s11.renderBefore) && void 0 !== o11 ? o11 : null;
        n8._$litPart$ = l9 = new M6(i10.insertBefore(d4(), t9), t9, void 0, null != s11 ? s11 : {});
      }
      return l9._$AI(t8), l9;
    };
  }
});

// node_modules/lit-element/lit-element.js
var l4, o6, s6, n5;
var init_lit_element = __esm({
  "node_modules/lit-element/lit-element.js"() {
    init_reactive_element();
    init_reactive_element();
    init_lit_html();
    init_lit_html();
    s6 = class extends d3 {
      constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
      }
      createRenderRoot() {
        var t8, e11;
        const i10 = super.createRenderRoot();
        return null !== (t8 = (e11 = this.renderOptions).renderBefore) && void 0 !== t8 || (e11.renderBefore = i10.firstChild), i10;
      }
      update(t8) {
        const i10 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t8), this._$Do = B4(i10, this.renderRoot, this.renderOptions);
      }
      connectedCallback() {
        var t8;
        super.connectedCallback(), null === (t8 = this._$Do) || void 0 === t8 || t8.setConnected(true);
      }
      disconnectedCallback() {
        var t8;
        super.disconnectedCallback(), null === (t8 = this._$Do) || void 0 === t8 || t8.setConnected(false);
      }
      render() {
        return T;
      }
    };
    s6.finalized = true, s6._$litElement$ = true, null === (l4 = globalThis.litElementHydrateSupport) || void 0 === l4 || l4.call(globalThis, { LitElement: s6 });
    n5 = globalThis.litElementPolyfillSupport;
    null == n5 || n5({ LitElement: s6 });
    (null !== (o6 = globalThis.litElementVersions) && void 0 !== o6 ? o6 : globalThis.litElementVersions = []).push("3.3.0");
  }
});

// node_modules/lit-html/is-server.js
var init_is_server = __esm({
  "node_modules/lit-html/is-server.js"() {
  }
});

// node_modules/lit/index.js
var init_lit = __esm({
  "node_modules/lit/index.js"() {
    init_reactive_element();
    init_lit_html();
    init_lit_element();
    init_is_server();
  }
});

// node_modules/@lit/reactive-element/decorators/custom-element.js
var e5;
var init_custom_element = __esm({
  "node_modules/@lit/reactive-element/decorators/custom-element.js"() {
    e5 = (e11) => (n8) => "function" == typeof n8 ? ((e12, n9) => (customElements.define(e12, n9), n9))(e11, n8) : ((e12, n9) => {
      const { kind: t8, elements: s11 } = n9;
      return { kind: t8, elements: s11, finisher(n10) {
        customElements.define(e12, n10);
      } };
    })(e11, n8);
  }
});

// node_modules/@lit/reactive-element/decorators/property.js
function e6(e11) {
  return (n8, t8) => void 0 !== t8 ? ((i10, e12, n9) => {
    e12.constructor.createProperty(n9, i10);
  })(e11, n8, t8) : i5(e11, n8);
}
var i5;
var init_property = __esm({
  "node_modules/@lit/reactive-element/decorators/property.js"() {
    i5 = (i10, e11) => "method" === e11.kind && e11.descriptor && !("value" in e11.descriptor) ? { ...e11, finisher(n8) {
      n8.createProperty(e11.key, i10);
    } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e11.key, initializer() {
      "function" == typeof e11.initializer && (this[e11.key] = e11.initializer.call(this));
    }, finisher(n8) {
      n8.createProperty(e11.key, i10);
    } };
  }
});

// node_modules/@lit/reactive-element/decorators/state.js
function t4(t8) {
  return e6({ ...t8, state: true });
}
var init_state = __esm({
  "node_modules/@lit/reactive-element/decorators/state.js"() {
    init_property();
  }
});

// node_modules/@lit/reactive-element/decorators/base.js
var init_base3 = __esm({
  "node_modules/@lit/reactive-element/decorators/base.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/event-options.js
var init_event_options = __esm({
  "node_modules/@lit/reactive-element/decorators/event-options.js"() {
    init_base3();
  }
});

// node_modules/@lit/reactive-element/decorators/query.js
var init_query = __esm({
  "node_modules/@lit/reactive-element/decorators/query.js"() {
    init_base3();
  }
});

// node_modules/@lit/reactive-element/decorators/query-all.js
var init_query_all = __esm({
  "node_modules/@lit/reactive-element/decorators/query-all.js"() {
    init_base3();
  }
});

// node_modules/@lit/reactive-element/decorators/query-async.js
var init_query_async = __esm({
  "node_modules/@lit/reactive-element/decorators/query-async.js"() {
    init_base3();
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
var n6, e7;
var init_query_assigned_elements = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-elements.js"() {
    init_base3();
    e7 = null != (null === (n6 = window.HTMLSlotElement) || void 0 === n6 ? void 0 : n6.prototype.assignedElements) ? (o11, n8) => o11.assignedElements(n8) : (o11, n8) => o11.assignedNodes(n8).filter((o12) => o12.nodeType === Node.ELEMENT_NODE);
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js
var init_query_assigned_nodes = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js"() {
    init_base3();
    init_query_assigned_elements();
  }
});

// node_modules/lit/decorators.js
var init_decorators = __esm({
  "node_modules/lit/decorators.js"() {
    init_custom_element();
    init_property();
    init_state();
    init_event_options();
    init_query();
    init_query_all();
    init_query_async();
    init_query_assigned_elements();
    init_query_assigned_nodes();
  }
});

// node_modules/lit-html/directive.js
var t5, e8, i6;
var init_directive = __esm({
  "node_modules/lit-html/directive.js"() {
    t5 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
    e8 = (t8) => (...e11) => ({ _$litDirective$: t8, values: e11 });
    i6 = class {
      constructor(t8) {
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AT(t8, e11, i10) {
        this._$Ct = t8, this._$AM = e11, this._$Ci = i10;
      }
      _$AS(t8, e11) {
        return this.update(t8, e11);
      }
      update(t8, e11) {
        return this.render(...e11);
      }
    };
  }
});

// node_modules/lit-html/directives/class-map.js
var o8;
var init_class_map = __esm({
  "node_modules/lit-html/directives/class-map.js"() {
    init_lit_html();
    init_directive();
    o8 = e8(class extends i6 {
      constructor(t8) {
        var i10;
        if (super(t8), t8.type !== t5.ATTRIBUTE || "class" !== t8.name || (null === (i10 = t8.strings) || void 0 === i10 ? void 0 : i10.length) > 2)
          throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
      }
      render(t8) {
        return " " + Object.keys(t8).filter((i10) => t8[i10]).join(" ") + " ";
      }
      update(i10, [s11]) {
        var r7, o11;
        if (void 0 === this.nt) {
          this.nt = /* @__PURE__ */ new Set(), void 0 !== i10.strings && (this.st = new Set(i10.strings.join(" ").split(/\s/).filter((t8) => "" !== t8)));
          for (const t8 in s11)
            s11[t8] && !(null === (r7 = this.st) || void 0 === r7 ? void 0 : r7.has(t8)) && this.nt.add(t8);
          return this.render(s11);
        }
        const e11 = i10.element.classList;
        this.nt.forEach((t8) => {
          t8 in s11 || (e11.remove(t8), this.nt.delete(t8));
        });
        for (const t8 in s11) {
          const i11 = !!s11[t8];
          i11 === this.nt.has(t8) || (null === (o11 = this.st) || void 0 === o11 ? void 0 : o11.has(t8)) || (i11 ? (e11.add(t8), this.nt.add(t8)) : (e11.remove(t8), this.nt.delete(t8)));
        }
        return T;
      }
    });
  }
});

// node_modules/lit/directives/class-map.js
var init_class_map2 = __esm({
  "node_modules/lit/directives/class-map.js"() {
    init_class_map();
  }
});

// node_modules/@motionone/utils/dist/array.es.js
function addUniqueItem(array, item) {
  array.indexOf(item) === -1 && array.push(item);
}
var init_array_es = __esm({
  "node_modules/@motionone/utils/dist/array.es.js"() {
  }
});

// node_modules/@motionone/utils/dist/clamp.es.js
var clamp;
var init_clamp_es = __esm({
  "node_modules/@motionone/utils/dist/clamp.es.js"() {
    clamp = (min, max, v7) => Math.min(Math.max(v7, min), max);
  }
});

// node_modules/@motionone/utils/dist/defaults.es.js
var defaults;
var init_defaults_es = __esm({
  "node_modules/@motionone/utils/dist/defaults.es.js"() {
    defaults = {
      duration: 0.3,
      delay: 0,
      endDelay: 0,
      repeat: 0,
      easing: "ease"
    };
  }
});

// node_modules/@motionone/utils/dist/is-number.es.js
var isNumber;
var init_is_number_es = __esm({
  "node_modules/@motionone/utils/dist/is-number.es.js"() {
    isNumber = (value) => typeof value === "number";
  }
});

// node_modules/@motionone/utils/dist/is-easing-list.es.js
var isEasingList;
var init_is_easing_list_es = __esm({
  "node_modules/@motionone/utils/dist/is-easing-list.es.js"() {
    init_is_number_es();
    isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);
  }
});

// node_modules/@motionone/utils/dist/wrap.es.js
var wrap;
var init_wrap_es = __esm({
  "node_modules/@motionone/utils/dist/wrap.es.js"() {
    wrap = (min, max, v7) => {
      const rangeSize = max - min;
      return ((v7 - min) % rangeSize + rangeSize) % rangeSize + min;
    };
  }
});

// node_modules/@motionone/utils/dist/easing.es.js
function getEasingForSegment(easing, i10) {
  return isEasingList(easing) ? easing[wrap(0, easing.length, i10)] : easing;
}
var init_easing_es = __esm({
  "node_modules/@motionone/utils/dist/easing.es.js"() {
    init_is_easing_list_es();
    init_wrap_es();
  }
});

// node_modules/@motionone/utils/dist/mix.es.js
var mix;
var init_mix_es = __esm({
  "node_modules/@motionone/utils/dist/mix.es.js"() {
    mix = (min, max, progress2) => -progress2 * min + progress2 * max + min;
  }
});

// node_modules/@motionone/utils/dist/noop.es.js
var noop, noopReturn;
var init_noop_es = __esm({
  "node_modules/@motionone/utils/dist/noop.es.js"() {
    noop = () => {
    };
    noopReturn = (v7) => v7;
  }
});

// node_modules/@motionone/utils/dist/progress.es.js
var progress;
var init_progress_es = __esm({
  "node_modules/@motionone/utils/dist/progress.es.js"() {
    progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
  }
});

// node_modules/@motionone/utils/dist/offset.es.js
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i10 = 1; i10 <= remaining; i10++) {
    const offsetProgress = progress(0, remaining, i10);
    offset.push(mix(min, 1, offsetProgress));
  }
}
function defaultOffset(length2) {
  const offset = [0];
  fillOffset(offset, length2 - 1);
  return offset;
}
var init_offset_es = __esm({
  "node_modules/@motionone/utils/dist/offset.es.js"() {
    init_mix_es();
    init_progress_es();
  }
});

// node_modules/@motionone/utils/dist/interpolate.es.js
function interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {
  const length2 = output.length;
  const remainder = length2 - input.length;
  remainder > 0 && fillOffset(input, remainder);
  return (t8) => {
    let i10 = 0;
    for (; i10 < length2 - 2; i10++) {
      if (t8 < input[i10 + 1])
        break;
    }
    let progressInRange = clamp(0, 1, progress(input[i10], input[i10 + 1], t8));
    const segmentEasing = getEasingForSegment(easing, i10);
    progressInRange = segmentEasing(progressInRange);
    return mix(output[i10], output[i10 + 1], progressInRange);
  };
}
var init_interpolate_es = __esm({
  "node_modules/@motionone/utils/dist/interpolate.es.js"() {
    init_mix_es();
    init_noop_es();
    init_offset_es();
    init_progress_es();
    init_easing_es();
    init_clamp_es();
  }
});

// node_modules/@motionone/utils/dist/is-cubic-bezier.es.js
var isCubicBezier;
var init_is_cubic_bezier_es = __esm({
  "node_modules/@motionone/utils/dist/is-cubic-bezier.es.js"() {
    init_is_number_es();
    isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);
  }
});

// node_modules/@motionone/utils/dist/is-easing-generator.es.js
var isEasingGenerator;
var init_is_easing_generator_es = __esm({
  "node_modules/@motionone/utils/dist/is-easing-generator.es.js"() {
    isEasingGenerator = (easing) => typeof easing === "object" && Boolean(easing.createAnimation);
  }
});

// node_modules/@motionone/utils/dist/is-function.es.js
var isFunction;
var init_is_function_es = __esm({
  "node_modules/@motionone/utils/dist/is-function.es.js"() {
    isFunction = (value) => typeof value === "function";
  }
});

// node_modules/@motionone/utils/dist/is-string.es.js
var isString;
var init_is_string_es = __esm({
  "node_modules/@motionone/utils/dist/is-string.es.js"() {
    isString = (value) => typeof value === "string";
  }
});

// node_modules/@motionone/utils/dist/time.es.js
var time;
var init_time_es = __esm({
  "node_modules/@motionone/utils/dist/time.es.js"() {
    time = {
      ms: (seconds) => seconds * 1e3,
      s: (milliseconds) => milliseconds / 1e3
    };
  }
});

// node_modules/@motionone/utils/dist/velocity.es.js
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
var init_velocity_es = __esm({
  "node_modules/@motionone/utils/dist/velocity.es.js"() {
  }
});

// node_modules/@motionone/utils/dist/index.es.js
var init_index_es6 = __esm({
  "node_modules/@motionone/utils/dist/index.es.js"() {
    init_array_es();
    init_clamp_es();
    init_defaults_es();
    init_interpolate_es();
    init_is_cubic_bezier_es();
    init_is_easing_generator_es();
    init_is_easing_list_es();
    init_is_function_es();
    init_is_number_es();
    init_is_string_es();
    init_noop_es();
    init_progress_es();
    init_time_es();
    init_velocity_es();
  }
});

// node_modules/@motionone/easing/dist/cubic-bezier.es.js
function binarySubdivide(x8, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i10 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x8;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i10 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noopReturn;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t8) => t8 === 0 || t8 === 1 ? t8 : calcBezier(getTForX(t8), mY1, mY2);
}
var calcBezier, subdivisionPrecision, subdivisionMaxIterations;
var init_cubic_bezier_es = __esm({
  "node_modules/@motionone/easing/dist/cubic-bezier.es.js"() {
    init_index_es6();
    calcBezier = (t8, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t8 + (3 * a22 - 6 * a1)) * t8 + 3 * a1) * t8;
    subdivisionPrecision = 1e-7;
    subdivisionMaxIterations = 12;
  }
});

// node_modules/@motionone/easing/dist/steps.es.js
var steps;
var init_steps_es = __esm({
  "node_modules/@motionone/easing/dist/steps.es.js"() {
    init_index_es6();
    steps = (steps2, direction = "end") => (progress2) => {
      progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
      const expanded = progress2 * steps2;
      const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
      return clamp(0, 1, rounded / steps2);
    };
  }
});

// node_modules/@motionone/easing/dist/index.es.js
var init_index_es7 = __esm({
  "node_modules/@motionone/easing/dist/index.es.js"() {
    init_cubic_bezier_es();
    init_steps_es();
  }
});

// node_modules/@motionone/animation/dist/utils/easing.es.js
function getEasingFunction(definition) {
  if (isFunction(definition))
    return definition;
  if (isCubicBezier(definition))
    return cubicBezier(...definition);
  if (namedEasings[definition])
    return namedEasings[definition];
  if (definition.startsWith("steps")) {
    const args = functionArgsRegex.exec(definition);
    if (args) {
      const argsArray = args[1].split(",");
      return steps(parseFloat(argsArray[0]), argsArray[1].trim());
    }
  }
  return noopReturn;
}
var namedEasings, functionArgsRegex;
var init_easing_es2 = __esm({
  "node_modules/@motionone/animation/dist/utils/easing.es.js"() {
    init_index_es7();
    init_index_es6();
    namedEasings = {
      ease: cubicBezier(0.25, 0.1, 0.25, 1),
      "ease-in": cubicBezier(0.42, 0, 1, 1),
      "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
      "ease-out": cubicBezier(0, 0, 0.58, 1)
    };
    functionArgsRegex = /\((.*?)\)/;
  }
});

// node_modules/@motionone/animation/dist/Animation.es.js
var Animation;
var init_Animation_es = __esm({
  "node_modules/@motionone/animation/dist/Animation.es.js"() {
    init_index_es6();
    init_easing_es2();
    Animation = class {
      constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = "normal" } = {}) {
        this.startTime = null;
        this.rate = 1;
        this.t = 0;
        this.cancelTimestamp = null;
        this.easing = noopReturn;
        this.duration = 0;
        this.totalDuration = 0;
        this.repeat = 0;
        this.playState = "idle";
        this.finished = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        easing = easing || defaults.easing;
        if (isEasingGenerator(easing)) {
          const custom = easing.createAnimation(keyframes);
          easing = custom.easing;
          keyframes = custom.keyframes || keyframes;
          initialDuration = custom.duration || initialDuration;
        }
        this.repeat = repeat;
        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);
        this.updateDuration(initialDuration);
        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);
        this.tick = (timestamp) => {
          var _a2;
          delay = delay;
          let t8 = 0;
          if (this.pauseTime !== void 0) {
            t8 = this.pauseTime;
          } else {
            t8 = (timestamp - this.startTime) * this.rate;
          }
          this.t = t8;
          t8 /= 1e3;
          t8 = Math.max(t8 - delay, 0);
          if (this.playState === "finished" && this.pauseTime === void 0) {
            t8 = this.totalDuration;
          }
          const progress2 = t8 / this.duration;
          let currentIteration = Math.floor(progress2);
          let iterationProgress = progress2 % 1;
          if (!iterationProgress && progress2 >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          const iterationIsOdd = currentIteration % 2;
          if (direction === "reverse" || direction === "alternate" && iterationIsOdd || direction === "alternate-reverse" && !iterationIsOdd) {
            iterationProgress = 1 - iterationProgress;
          }
          const p10 = t8 >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
          const latest = interpolate$1(this.easing(p10));
          output(latest);
          const isAnimationFinished = this.pauseTime === void 0 && (this.playState === "finished" || t8 >= this.totalDuration + endDelay);
          if (isAnimationFinished) {
            this.playState = "finished";
            (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, latest);
          } else if (this.playState !== "idle") {
            this.frameRequestId = requestAnimationFrame(this.tick);
          }
        };
        this.play();
      }
      play() {
        const now2 = performance.now();
        this.playState = "running";
        if (this.pauseTime !== void 0) {
          this.startTime = now2 - this.pauseTime;
        } else if (!this.startTime) {
          this.startTime = now2;
        }
        this.cancelTimestamp = this.startTime;
        this.pauseTime = void 0;
        this.frameRequestId = requestAnimationFrame(this.tick);
      }
      pause() {
        this.playState = "paused";
        this.pauseTime = this.t;
      }
      finish() {
        this.playState = "finished";
        this.tick(0);
      }
      stop() {
        var _a2;
        this.playState = "idle";
        if (this.frameRequestId !== void 0) {
          cancelAnimationFrame(this.frameRequestId);
        }
        (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, false);
      }
      cancel() {
        this.stop();
        this.tick(this.cancelTimestamp);
      }
      reverse() {
        this.rate *= -1;
      }
      commitStyles() {
      }
      updateDuration(duration) {
        this.duration = duration;
        this.totalDuration = duration * (this.repeat + 1);
      }
      get currentTime() {
        return this.t;
      }
      set currentTime(t8) {
        if (this.pauseTime !== void 0 || this.rate === 0) {
          this.pauseTime = t8;
        } else {
          this.startTime = performance.now() - t8 / this.rate;
        }
      }
      get playbackRate() {
        return this.rate;
      }
      set playbackRate(rate) {
        this.rate = rate;
      }
    };
  }
});

// node_modules/@motionone/animation/dist/index.es.js
var init_index_es8 = __esm({
  "node_modules/@motionone/animation/dist/index.es.js"() {
    init_Animation_es();
  }
});

// node_modules/hey-listen/dist/hey-listen.es.js
var warning, invariant;
var init_hey_listen_es = __esm({
  "node_modules/hey-listen/dist/hey-listen.es.js"() {
    warning = function() {
    };
    invariant = function() {
    };
    if (true) {
      warning = function(check, message) {
        if (!check && typeof console !== "undefined") {
          console.warn(message);
        }
      };
      invariant = function(check, message) {
        if (!check) {
          throw new Error(message);
        }
      };
    }
  }
});

// node_modules/@motionone/types/dist/MotionValue.es.js
var MotionValue;
var init_MotionValue_es = __esm({
  "node_modules/@motionone/types/dist/MotionValue.es.js"() {
    MotionValue = class {
      setAnimation(animation) {
        this.animation = animation;
        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => {
        });
      }
      clearAnimation() {
        this.animation = this.generator = void 0;
      }
    };
  }
});

// node_modules/@motionone/types/dist/index.es.js
var init_index_es9 = __esm({
  "node_modules/@motionone/types/dist/index.es.js"() {
    init_MotionValue_es();
  }
});

// node_modules/@motionone/dom/dist/animate/data.es.js
function getAnimationData(element) {
  if (!data.has(element)) {
    data.set(element, {
      transforms: [],
      values: /* @__PURE__ */ new Map()
    });
  }
  return data.get(element);
}
function getMotionValue(motionValues, name2) {
  if (!motionValues.has(name2)) {
    motionValues.set(name2, new MotionValue());
  }
  return motionValues.get(name2);
}
var data;
var init_data_es = __esm({
  "node_modules/@motionone/dom/dist/animate/data.es.js"() {
    init_index_es9();
    data = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@motionone/dom/dist/animate/utils/transforms.es.js
var axes, order, transformAlias, rotation, baseTransformProperties, transformDefinitions, asTransformCssVar, transforms, compareTransformOrder, transformLookup, isTransform, addTransformToElement, buildTransformTemplate, transformListToString;
var init_transforms_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/transforms.es.js"() {
    init_index_es6();
    init_data_es();
    axes = ["", "X", "Y", "Z"];
    order = ["translate", "scale", "rotate", "skew"];
    transformAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ"
    };
    rotation = {
      syntax: "<angle>",
      initialValue: "0deg",
      toDefaultUnit: (v7) => v7 + "deg"
    };
    baseTransformProperties = {
      translate: {
        syntax: "<length-percentage>",
        initialValue: "0px",
        toDefaultUnit: (v7) => v7 + "px"
      },
      rotate: rotation,
      scale: {
        syntax: "<number>",
        initialValue: 1,
        toDefaultUnit: noopReturn
      },
      skew: rotation
    };
    transformDefinitions = /* @__PURE__ */ new Map();
    asTransformCssVar = (name2) => `--motion-${name2}`;
    transforms = ["x", "y", "z"];
    order.forEach((name2) => {
      axes.forEach((axis) => {
        transforms.push(name2 + axis);
        transformDefinitions.set(asTransformCssVar(name2 + axis), baseTransformProperties[name2]);
      });
    });
    compareTransformOrder = (a9, b10) => transforms.indexOf(a9) - transforms.indexOf(b10);
    transformLookup = new Set(transforms);
    isTransform = (name2) => transformLookup.has(name2);
    addTransformToElement = (element, name2) => {
      if (transformAlias[name2])
        name2 = transformAlias[name2];
      const { transforms: transforms2 } = getAnimationData(element);
      addUniqueItem(transforms2, name2);
      element.style.transform = buildTransformTemplate(transforms2);
    };
    buildTransformTemplate = (transforms2) => transforms2.sort(compareTransformOrder).reduce(transformListToString, "").trim();
    transformListToString = (template, name2) => `${template} ${name2}(var(${asTransformCssVar(name2)}))`;
  }
});

// node_modules/@motionone/dom/dist/animate/utils/css-var.es.js
function registerCssVariable(name2) {
  if (registeredProperties.has(name2))
    return;
  registeredProperties.add(name2);
  try {
    const { syntax, initialValue } = transformDefinitions.has(name2) ? transformDefinitions.get(name2) : {};
    CSS.registerProperty({
      name: name2,
      inherits: false,
      syntax,
      initialValue
    });
  } catch (e11) {
  }
}
var isCssVar, registeredProperties;
var init_css_var_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/css-var.es.js"() {
    init_transforms_es();
    isCssVar = (name2) => name2.startsWith("--");
    registeredProperties = /* @__PURE__ */ new Set();
  }
});

// node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js
var testAnimation, featureTests, results, supports;
var init_feature_detection_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js"() {
    testAnimation = (keyframes, options) => document.createElement("div").animate(keyframes, options);
    featureTests = {
      cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
      waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
      partialKeyframes: () => {
        try {
          testAnimation({ opacity: [1] });
        } catch (e11) {
          return false;
        }
        return true;
      },
      finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 1e-3 }).finished),
      linearEasing: () => {
        try {
          testAnimation({ opacity: 0 }, { easing: "linear(0, 1)" });
        } catch (e11) {
          return false;
        }
        return true;
      }
    };
    results = {};
    supports = {};
    for (const key in featureTests) {
      supports[key] = () => {
        if (results[key] === void 0)
          results[key] = featureTests[key]();
        return results[key];
      };
    }
  }
});

// node_modules/@motionone/dom/dist/animate/utils/easing.es.js
var resolution, generateLinearEasingPoints, convertEasing, cubicBezierAsString;
var init_easing_es3 = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/easing.es.js"() {
    init_index_es6();
    init_feature_detection_es();
    resolution = 0.015;
    generateLinearEasingPoints = (easing, duration) => {
      let points = "";
      const numPoints = Math.round(duration / resolution);
      for (let i10 = 0; i10 < numPoints; i10++) {
        points += easing(progress(0, numPoints - 1, i10)) + ", ";
      }
      return points.substring(0, points.length - 2);
    };
    convertEasing = (easing, duration) => {
      if (isFunction(easing)) {
        return supports.linearEasing() ? `linear(${generateLinearEasingPoints(easing, duration)})` : defaults.easing;
      } else {
        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;
      }
    };
    cubicBezierAsString = ([a9, b10, c8, d9]) => `cubic-bezier(${a9}, ${b10}, ${c8}, ${d9})`;
  }
});

// node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js
function hydrateKeyframes(keyframes, readInitialValue) {
  for (let i10 = 0; i10 < keyframes.length; i10++) {
    if (keyframes[i10] === null) {
      keyframes[i10] = i10 ? keyframes[i10 - 1] : readInitialValue();
    }
  }
  return keyframes;
}
var keyframesList;
var init_keyframes_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js"() {
    keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];
  }
});

// node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js
function getStyleName(key) {
  if (transformAlias[key])
    key = transformAlias[key];
  return isTransform(key) ? asTransformCssVar(key) : key;
}
var init_get_style_name_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js"() {
    init_transforms_es();
  }
});

// node_modules/@motionone/dom/dist/animate/style.es.js
var style;
var init_style_es = __esm({
  "node_modules/@motionone/dom/dist/animate/style.es.js"() {
    init_css_var_es();
    init_get_style_name_es();
    init_transforms_es();
    style = {
      get: (element, name2) => {
        name2 = getStyleName(name2);
        let value = isCssVar(name2) ? element.style.getPropertyValue(name2) : getComputedStyle(element)[name2];
        if (!value && value !== 0) {
          const definition = transformDefinitions.get(name2);
          if (definition)
            value = definition.initialValue;
        }
        return value;
      },
      set: (element, name2, value) => {
        name2 = getStyleName(name2);
        if (isCssVar(name2)) {
          element.style.setProperty(name2, value);
        } else {
          element.style[name2] = value;
        }
      }
    };
  }
});

// node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js
function stopAnimation(animation, needsCommit = true) {
  if (!animation || animation.playState === "finished")
    return;
  try {
    if (animation.stop) {
      animation.stop();
    } else {
      needsCommit && animation.commitStyles();
      animation.cancel();
    }
  } catch (e11) {
  }
}
var init_stop_animation_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js"() {
  }
});

// node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js
function getUnitConverter(keyframes, definition) {
  var _a2;
  let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;
  const finalKeyframe = keyframes[keyframes.length - 1];
  if (isString(finalKeyframe)) {
    const unit = ((_a2 = finalKeyframe.match(/(-?[\d.]+)([a-z%]*)/)) === null || _a2 === void 0 ? void 0 : _a2[2]) || "";
    if (unit)
      toUnit = (value) => value + unit;
  }
  return toUnit;
}
var init_get_unit_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js"() {
    init_index_es6();
  }
});

// node_modules/@motionone/dom/dist/animate/animate-style.es.js
function getDevToolsRecord() {
  return window.__MOTION_DEV_TOOLS_RECORD;
}
function animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {
  const record = getDevToolsRecord();
  const isRecording = options.record !== false && record;
  let animation;
  let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist: persist2 = false, direction, offset, allowWebkitAcceleration = false } = options;
  const data2 = getAnimationData(element);
  const valueIsTransform = isTransform(key);
  let canAnimateNatively = supports.waapi();
  valueIsTransform && addTransformToElement(element, key);
  const name2 = getStyleName(key);
  const motionValue = getMotionValue(data2.values, name2);
  const definition = transformDefinitions.get(name2);
  stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) && options.record !== false);
  return () => {
    const readInitialValue = () => {
      var _a2, _b;
      return (_b = (_a2 = style.get(element, name2)) !== null && _a2 !== void 0 ? _a2 : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0;
    };
    let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);
    const toUnit = getUnitConverter(keyframes, definition);
    if (isEasingGenerator(easing)) {
      const custom = easing.createAnimation(keyframes, key !== "opacity", readInitialValue, name2, motionValue);
      easing = custom.easing;
      keyframes = custom.keyframes || keyframes;
      duration = custom.duration || duration;
    }
    if (isCssVar(name2)) {
      if (supports.cssRegisterProperty()) {
        registerCssVariable(name2);
      } else {
        canAnimateNatively = false;
      }
    }
    if (valueIsTransform && !supports.linearEasing() && (isFunction(easing) || isEasingList(easing) && easing.some(isFunction))) {
      canAnimateNatively = false;
    }
    if (canAnimateNatively) {
      if (definition) {
        keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);
      }
      if (keyframes.length === 1 && (!supports.partialKeyframes() || isRecording)) {
        keyframes.unshift(readInitialValue());
      }
      const animationOptions = {
        delay: time.ms(delay),
        duration: time.ms(duration),
        endDelay: time.ms(endDelay),
        easing: !isEasingList(easing) ? convertEasing(easing, duration) : void 0,
        direction,
        iterations: repeat + 1,
        fill: "both"
      };
      animation = element.animate({
        [name2]: keyframes,
        offset,
        easing: isEasingList(easing) ? easing.map((thisEasing) => convertEasing(thisEasing, duration)) : void 0
      }, animationOptions);
      if (!animation.finished) {
        animation.finished = new Promise((resolve, reject) => {
          animation.onfinish = resolve;
          animation.oncancel = reject;
        });
      }
      const target = keyframes[keyframes.length - 1];
      animation.finished.then(() => {
        if (persist2)
          return;
        style.set(element, name2, target);
        animation.cancel();
      }).catch(noop);
      if (!allowWebkitAcceleration)
        animation.playbackRate = 1.000001;
    } else if (AnimationPolyfill && valueIsTransform) {
      keyframes = keyframes.map((value) => typeof value === "string" ? parseFloat(value) : value);
      if (keyframes.length === 1) {
        keyframes.unshift(parseFloat(readInitialValue()));
      }
      animation = new AnimationPolyfill((latest) => {
        style.set(element, name2, toUnit ? toUnit(latest) : latest);
      }, keyframes, Object.assign(Object.assign({}, options), {
        duration,
        easing
      }));
    } else {
      const target = keyframes[keyframes.length - 1];
      style.set(element, name2, definition && isNumber(target) ? definition.toDefaultUnit(target) : target);
    }
    if (isRecording) {
      record(element, key, keyframes, {
        duration,
        delay,
        easing,
        repeat,
        offset
      }, "motion-one");
    }
    motionValue.setAnimation(animation);
    return animation;
  };
}
var init_animate_style_es = __esm({
  "node_modules/@motionone/dom/dist/animate/animate-style.es.js"() {
    init_data_es();
    init_css_var_es();
    init_index_es6();
    init_transforms_es();
    init_easing_es3();
    init_feature_detection_es();
    init_keyframes_es();
    init_style_es();
    init_get_style_name_es();
    init_stop_animation_es();
    init_get_unit_es();
  }
});

// node_modules/@motionone/dom/dist/animate/utils/options.es.js
var getOptions;
var init_options_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/options.es.js"() {
    getOptions = (options, key) => (
      /**
       * TODO: Make test for this
       * Always return a new object otherwise delay is overwritten by results of stagger
       * and this results in no stagger
       */
      options[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options)
    );
  }
});

// node_modules/@motionone/dom/dist/utils/resolve-elements.es.js
function resolveElements(elements, selectorCache) {
  var _a2;
  if (typeof elements === "string") {
    if (selectorCache) {
      (_a2 = selectorCache[elements]) !== null && _a2 !== void 0 ? _a2 : selectorCache[elements] = document.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = document.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}
var init_resolve_elements_es = __esm({
  "node_modules/@motionone/dom/dist/utils/resolve-elements.es.js"() {
  }
});

// node_modules/@motionone/dom/dist/animate/utils/controls.es.js
var createAnimation, withControls, getActiveAnimation, controls, selectFinished;
var init_controls_es = __esm({
  "node_modules/@motionone/dom/dist/animate/utils/controls.es.js"() {
    init_index_es6();
    init_stop_animation_es();
    createAnimation = (factory) => factory();
    withControls = (animationFactory, options, duration = defaults.duration) => {
      return new Proxy({
        animations: animationFactory.map(createAnimation).filter(Boolean),
        duration,
        options
      }, controls);
    };
    getActiveAnimation = (state) => state.animations[0];
    controls = {
      get: (target, key) => {
        const activeAnimation = getActiveAnimation(target);
        switch (key) {
          case "duration":
            return target.duration;
          case "currentTime":
            return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);
          case "playbackRate":
          case "playState":
            return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];
          case "finished":
            if (!target.finished) {
              target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);
            }
            return target.finished;
          case "stop":
            return () => {
              target.animations.forEach((animation) => stopAnimation(animation));
            };
          case "forEachNative":
            return (callback) => {
              target.animations.forEach((animation) => callback(animation, target));
            };
          default:
            return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === "undefined" ? void 0 : () => target.animations.forEach((animation) => animation[key]());
        }
      },
      set: (target, key, value) => {
        switch (key) {
          case "currentTime":
            value = time.ms(value);
          case "currentTime":
          case "playbackRate":
            for (let i10 = 0; i10 < target.animations.length; i10++) {
              target.animations[i10][key] = value;
            }
            return true;
        }
        return false;
      }
    };
    selectFinished = (animation) => animation.finished;
  }
});

// node_modules/@motionone/dom/dist/utils/stagger.es.js
function resolveOption(option, i10, total) {
  return isFunction(option) ? option(i10, total) : option;
}
var init_stagger_es = __esm({
  "node_modules/@motionone/dom/dist/utils/stagger.es.js"() {
    init_index_es6();
  }
});

// node_modules/@motionone/dom/dist/animate/create-animate.es.js
function createAnimate(AnimatePolyfill) {
  return function animate3(elements, keyframes, options = {}) {
    elements = resolveElements(elements);
    const numElements = elements.length;
    invariant(Boolean(numElements), "No valid element provided.");
    invariant(Boolean(keyframes), "No keyframes defined.");
    const animationFactories = [];
    for (let i10 = 0; i10 < numElements; i10++) {
      const element = elements[i10];
      for (const key in keyframes) {
        const valueOptions = getOptions(options, key);
        valueOptions.delay = resolveOption(valueOptions.delay, i10, numElements);
        const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);
        animationFactories.push(animation);
      }
    }
    return withControls(
      animationFactories,
      options,
      /**
       * TODO:
       * If easing is set to spring or glide, duration will be dynamically
       * generated. Ideally we would dynamically generate this from
       * animation.effect.getComputedTiming().duration but this isn't
       * supported in iOS13 or our number polyfill. Perhaps it's possible
       * to Proxy animations returned from animateStyle that has duration
       * as a getter.
       */
      options.duration
    );
  };
}
var init_create_animate_es = __esm({
  "node_modules/@motionone/dom/dist/animate/create-animate.es.js"() {
    init_hey_listen_es();
    init_animate_style_es();
    init_options_es();
    init_resolve_elements_es();
    init_controls_es();
    init_stagger_es();
  }
});

// node_modules/@motionone/dom/dist/animate/index.es.js
var animate;
var init_index_es10 = __esm({
  "node_modules/@motionone/dom/dist/animate/index.es.js"() {
    init_index_es8();
    init_create_animate_es();
    animate = createAnimate(Animation);
  }
});

// node_modules/@motionone/generators/dist/utils/velocity.es.js
function calcGeneratorVelocity(resolveValue, t8, current) {
  const prevT = Math.max(t8 - sampleT, 0);
  return velocityPerSecond(current - resolveValue(prevT), t8 - prevT);
}
var sampleT;
var init_velocity_es2 = __esm({
  "node_modules/@motionone/generators/dist/utils/velocity.es.js"() {
    init_index_es6();
    sampleT = 5;
  }
});

// node_modules/@motionone/generators/dist/spring/defaults.es.js
var defaults2;
var init_defaults_es2 = __esm({
  "node_modules/@motionone/generators/dist/spring/defaults.es.js"() {
    defaults2 = {
      stiffness: 100,
      damping: 10,
      mass: 1
    };
  }
});

// node_modules/@motionone/generators/dist/spring/utils.es.js
var calcDampingRatio;
var init_utils_es = __esm({
  "node_modules/@motionone/generators/dist/spring/utils.es.js"() {
    init_defaults_es2();
    calcDampingRatio = (stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass) => damping / (2 * Math.sqrt(stiffness * mass));
  }
});

// node_modules/@motionone/generators/dist/utils/has-reached-target.es.js
function hasReachedTarget(origin, target, current) {
  return origin < target && current >= target || origin > target && current <= target;
}
var init_has_reached_target_es = __esm({
  "node_modules/@motionone/generators/dist/utils/has-reached-target.es.js"() {
  }
});

// node_modules/@motionone/generators/dist/spring/index.es.js
var spring;
var init_index_es11 = __esm({
  "node_modules/@motionone/generators/dist/spring/index.es.js"() {
    init_index_es6();
    init_defaults_es2();
    init_utils_es();
    init_has_reached_target_es();
    init_velocity_es2();
    spring = ({ stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass, from: from3 = 0, to: to2 = 1, velocity = 0, restSpeed = 2, restDistance = 0.5 } = {}) => {
      velocity = velocity ? time.s(velocity) : 0;
      const state = {
        done: false,
        hasReachedTarget: false,
        current: from3,
        target: to2
      };
      const initialDelta = to2 - from3;
      const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
      const dampingRatio = calcDampingRatio(stiffness, damping, mass);
      let resolveSpring;
      if (dampingRatio < 1) {
        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
        resolveSpring = (t8) => to2 - Math.exp(-dampingRatio * undampedAngularFreq * t8) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t8) + initialDelta * Math.cos(angularFreq * t8));
      } else {
        resolveSpring = (t8) => {
          return to2 - Math.exp(-undampedAngularFreq * t8) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t8);
        };
      }
      return (t8) => {
        state.current = resolveSpring(t8);
        const currentVelocity = t8 === 0 ? velocity : calcGeneratorVelocity(resolveSpring, t8, state.current);
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to2 - state.current) <= restDistance;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        state.hasReachedTarget = hasReachedTarget(from3, to2, state.current);
        return state;
      };
    };
  }
});

// node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js
function pregenerateKeyframes(generator, toUnit = noopReturn) {
  let overshootDuration = void 0;
  let timestamp = timeStep;
  let state = generator(0);
  const keyframes = [toUnit(state.current)];
  while (!state.done && timestamp < maxDuration) {
    state = generator(timestamp);
    keyframes.push(toUnit(state.done ? state.target : state.current));
    if (overshootDuration === void 0 && state.hasReachedTarget) {
      overshootDuration = timestamp;
    }
    timestamp += timeStep;
  }
  const duration = timestamp - timeStep;
  if (keyframes.length === 1)
    keyframes.push(state.current);
  return {
    keyframes,
    duration: duration / 1e3,
    overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1e3
  };
}
var timeStep, maxDuration;
var init_pregenerate_keyframes_es = __esm({
  "node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js"() {
    init_index_es6();
    timeStep = 10;
    maxDuration = 1e4;
  }
});

// node_modules/@motionone/generators/dist/index.es.js
var init_index_es12 = __esm({
  "node_modules/@motionone/generators/dist/index.es.js"() {
    init_index_es11();
    init_pregenerate_keyframes_es();
    init_velocity_es2();
  }
});

// node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js
function canGenerate(value) {
  return isNumber(value) && !isNaN(value);
}
function getAsNumber(value) {
  return isString(value) ? parseFloat(value) : value;
}
function createGeneratorEasing(createGenerator) {
  const keyframesCache = /* @__PURE__ */ new WeakMap();
  return (options = {}) => {
    const generatorCache = /* @__PURE__ */ new Map();
    const getGenerator = (from3 = 0, to2 = 100, velocity = 0, isScale = false) => {
      const key = `${from3}-${to2}-${velocity}-${isScale}`;
      if (!generatorCache.has(key)) {
        generatorCache.set(key, createGenerator(Object.assign({
          from: from3,
          to: to2,
          velocity,
          restSpeed: isScale ? 0.05 : 2,
          restDistance: isScale ? 0.01 : 0.5
        }, options)));
      }
      return generatorCache.get(key);
    };
    const getKeyframes = (generator, toUnit) => {
      if (!keyframesCache.has(generator)) {
        keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));
      }
      return keyframesCache.get(generator);
    };
    return {
      createAnimation: (keyframes, shouldGenerate = true, getOrigin, name2, motionValue) => {
        let settings;
        let origin;
        let target;
        let velocity = 0;
        let toUnit = noopReturn;
        const numKeyframes = keyframes.length;
        if (shouldGenerate) {
          toUnit = getUnitConverter(keyframes, name2 ? transformDefinitions.get(getStyleName(name2)) : void 0);
          const targetDefinition = keyframes[numKeyframes - 1];
          target = getAsNumber(targetDefinition);
          if (numKeyframes > 1 && keyframes[0] !== null) {
            origin = getAsNumber(keyframes[0]);
          } else {
            const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;
            if (prevGenerator) {
              const { animation, generatorStartTime } = motionValue;
              const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;
              const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;
              const prevGeneratorCurrent = prevGenerator(currentTime).current;
              origin = prevGeneratorCurrent;
              velocity = calcGeneratorVelocity((t8) => prevGenerator(t8).current, currentTime, prevGeneratorCurrent);
            } else if (getOrigin) {
              origin = getAsNumber(getOrigin());
            }
          }
        }
        if (canGenerate(origin) && canGenerate(target)) {
          const generator = getGenerator(origin, target, velocity, name2 === null || name2 === void 0 ? void 0 : name2.includes("scale"));
          settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: "linear" });
          if (motionValue) {
            motionValue.generator = generator;
            motionValue.generatorStartTime = performance.now();
          }
        }
        if (!settings) {
          const keyframesMetadata = getKeyframes(getGenerator(0, 100));
          settings = {
            easing: "ease",
            duration: keyframesMetadata.overshootDuration
          };
        }
        return settings;
      }
    };
  };
}
var init_create_generator_easing_es = __esm({
  "node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js"() {
    init_index_es12();
    init_index_es6();
    init_get_unit_es();
    init_transforms_es();
    init_get_style_name_es();
  }
});

// node_modules/@motionone/dom/dist/easing/spring/index.es.js
var spring2;
var init_index_es13 = __esm({
  "node_modules/@motionone/dom/dist/easing/spring/index.es.js"() {
    init_index_es12();
    init_create_generator_easing_es();
    spring2 = createGeneratorEasing(spring);
  }
});

// node_modules/@motionone/dom/dist/index.es.js
var init_index_es14 = __esm({
  "node_modules/@motionone/dom/dist/index.es.js"() {
    init_index_es10();
    init_index_es13();
    init_controls_es();
  }
});

// node_modules/motion/dist/animate.es.js
function animateProgress(target, options = {}) {
  return withControls([
    () => {
      const animation = new Animation(target, [0, 1], options);
      animation.finished.catch(() => {
      });
      return animation;
    }
  ], options, options.duration);
}
function animate2(target, keyframesOrOptions, options) {
  const factory = isFunction(target) ? animateProgress : animate;
  return factory(target, keyframesOrOptions, options);
}
var init_animate_es = __esm({
  "node_modules/motion/dist/animate.es.js"() {
    init_index_es14();
    init_index_es6();
    init_index_es8();
  }
});

// node_modules/motion/dist/main.es.js
var init_main_es = __esm({
  "node_modules/motion/dist/main.es.js"() {
    init_index_es14();
    init_index_es9();
    init_animate_es();
  }
});

// node_modules/lit-html/directives/if-defined.js
var l6;
var init_if_defined = __esm({
  "node_modules/lit-html/directives/if-defined.js"() {
    init_lit_html();
    l6 = (l9) => null != l9 ? l9 : A5;
  }
});

// node_modules/lit/directives/if-defined.js
var init_if_defined2 = __esm({
  "node_modules/lit/directives/if-defined.js"() {
    init_if_defined();
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils9 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version6) {
      if (!version6)
        throw new Error('"version" cannot be null or undefined');
      if (version6 < 1 || version6 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version6 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version6) {
      return CODEWORDS_COUNT[version6];
    };
    exports.getBCHDigit = function(data2) {
      let digit = 0;
      while (data2 !== 0) {
        digit++;
        data2 >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f7) {
      if (typeof f7 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f7;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e11) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length2) {
        for (let i10 = 0; i10 < length2; i10++) {
          this.putBit((num >>> length2 - i10 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils9().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version6) {
      if (version6 === 1)
        return [];
      const posCount = Math.floor(version6 / 7) + 2;
      const size = getSymbolSize(version6);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i10 = 1; i10 < posCount - 1; i10++) {
        positions[i10] = positions[i10 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version6) {
      const coords = [];
      const pos = exports.getRowColCoords(version6);
      const posLength = pos.length;
      for (let i10 = 0; i10 < posLength; i10++) {
        for (let j8 = 0; j8 < posLength; j8++) {
          if (i10 === 0 && j8 === 0 || // top-left
          i10 === 0 && j8 === posLength - 1 || // bottom-left
          i10 === posLength - 1 && j8 === 0) {
            continue;
          }
          coords.push([pos[i10], pos[j8]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils9().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version6) {
      const size = getSymbolSize(version6);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from3(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data2) {
      const size = data2.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data2.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data2.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data2) {
      const size = data2.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data2) {
      const size = data2.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data2) {
      let darkCount = 0;
      const modulesCount = data2.data.length;
      for (let i10 = 0; i10 < modulesCount; i10++)
        darkCount += data2.data[i10];
      const k8 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k8 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i10, j8) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i10 + j8) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i10 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j8 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i10 + j8) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i10 / 2) + Math.floor(j8 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i10 * j8 % 2 + i10 * j8 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i10 * j8 % 2 + i10 * j8 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i10 * j8 % 3 + (i10 + j8) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data2) {
      const size = data2.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data2.isReserved(row, col))
            continue;
          data2.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p10 = 0; p10 < numPatterns; p10++) {
        setupFormatFunc(p10);
        exports.applyMask(p10, data2);
        const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
        exports.applyMask(p10, data2);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p10;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version6, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version6 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version6, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version6 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x8 = 1;
      for (let i10 = 0; i10 < 255; i10++) {
        EXP_TABLE[i10] = x8;
        LOG_TABLE[x8] = i10;
        x8 <<= 1;
        if (x8 & 256) {
          x8 ^= 285;
        }
      }
      for (let i10 = 255; i10 < 512; i10++) {
        EXP_TABLE[i10] = EXP_TABLE[i10 - 255];
      }
    })();
    exports.log = function log(n8) {
      if (n8 < 1)
        throw new Error("log(" + n8 + ")");
      return LOG_TABLE[n8];
    };
    exports.exp = function exp(n8) {
      return EXP_TABLE[n8];
    };
    exports.mul = function mul(x8, y10) {
      if (x8 === 0 || y10 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x8] + LOG_TABLE[y10]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p22) {
      const coeff = new Uint8Array(p1.length + p22.length - 1);
      for (let i10 = 0; i10 < p1.length; i10++) {
        for (let j8 = 0; j8 < p22.length; j8++) {
          coeff[i10 + j8] ^= GF.mul(p1[i10], p22[j8]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i10 = 0; i10 < divisor.length; i10++) {
          result[i10] ^= GF.mul(divisor[i10], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i10 = 0; i10 < degree; i10++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i10)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode5(data2) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data2.length + this.degree);
      paddedData.set(data2);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version6) {
      return !isNaN(version6) && version6 >= 1 && version6 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version6) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version6)) {
        throw new Error("Invalid version: " + version6);
      }
      if (version6 >= 1 && version6 < 10)
        return mode.ccBits[0];
      else if (version6 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e11) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version23 = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils9();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version6) {
      return Mode.getCharCountIndicator(mode, version6) + 4;
    }
    function getTotalBitsFromDataArray(segments, version6) {
      let totalBits = 0;
      segments.forEach(function(data2) {
        const reservedBits = getReservedBitsCount(data2.mode, version6);
        totalBits += reservedBits + data2.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from3(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version6, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version6)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version6);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data2)) {
        if (data2.length > 1) {
          return getBestVersionForMixedData(data2, ecl);
        }
        if (data2.length === 0) {
          return 1;
        }
        seg = data2[0];
      } else {
        seg = data2;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version6) {
      if (!VersionCheck.isValid(version6) || version6 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d9 = version6 << 12;
      while (Utils.getBCHDigit(d9) - G18_BCH >= 0) {
        d9 ^= G18 << Utils.getBCHDigit(d9) - G18_BCH;
      }
      return version6 << 12 | d9;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils9();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data2 = errorCorrectionLevel.bit << 3 | mask;
      let d9 = data2 << 10;
      while (Utils.getBCHDigit(d9) - G15_BCH >= 0) {
        d9 ^= G15 << Utils.getBCHDigit(d9) - G15_BCH;
      }
      return (data2 << 10 | d9) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data2) {
      this.mode = Mode.NUMERIC;
      this.data = data2.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i10, group, value;
      for (i10 = 0; i10 + 3 <= this.data.length; i10 += 3) {
        group = this.data.substr(i10, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i10;
      if (remainingNum > 0) {
        group = this.data.substr(i10);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data2) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data2;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i10;
      for (i10 = 0; i10 + 2 <= this.data.length; i10 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i10]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i10 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i10]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module) {
    "use strict";
    module.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data2) {
      this.mode = Mode.BYTE;
      if (typeof data2 === "string") {
        data2 = encodeUtf8(data2);
      }
      this.data = new Uint8Array(data2);
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i10 = 0, l9 = this.data.length; i10 < l9; i10++) {
        bitBuffer.put(this.data[i10], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils9();
    function KanjiData(data2) {
      this.mode = Mode.KANJI;
      this.data = data2;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i10;
      for (i10 = 0; i10 < this.data.length; i10++) {
        let value = Utils.toSJIS(this.data[i10]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i10] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s11, d9) {
        var predecessors = {};
        var costs = {};
        costs[s11] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s11, 0);
        var closest, u9, v7, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u9 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u9] || {};
          for (v7 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v7)) {
              cost_of_e = adjacent_nodes[v7];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v7];
              first_visit = typeof costs[v7] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v7] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v7, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v7] = u9;
              }
            }
          }
        }
        if (typeof d9 !== "undefined" && typeof costs[d9] === "undefined") {
          var msg = ["Could not find a path from ", s11, " to ", d9, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d9) {
        var nodes = [];
        var u9 = d9;
        var predecessor;
        while (u9) {
          nodes.push(u9);
          predecessor = predecessors[u9];
          u9 = predecessors[u9];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s11, d9) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s11, d9);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d9
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T6 = dijkstra.PriorityQueue, t8 = {}, key;
          opts = opts || {};
          for (key in T6) {
            if (T6.hasOwnProperty(key)) {
              t8[key] = T6[key];
            }
          }
          t8.queue = [];
          t8.sorter = opts.sorter || T6.default_sorter;
          return t8;
        },
        default_sorter: function(a9, b10) {
          return a9.cost - b10.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils9();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i10 = 0; i10 < segs.length; i10++) {
        const seg = segs[i10];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version6) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i10 = 0; i10 < nodes.length; i10++) {
        const nodeGroup = nodes[i10];
        const currentNodeIds = [];
        for (let j8 = 0; j8 < nodeGroup.length; j8++) {
          const node = nodeGroup[j8];
          const key = "" + i10 + j8;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n8 = 0; n8 < prevNodeIds.length; n8++) {
            const prevNodeId = prevNodeIds[n8];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version6);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n8 = 0; n8 < prevNodeIds.length; n8++) {
        graph[prevNodeIds[n8]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data2, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data2);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data2);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data2);
        case Mode.KANJI:
          return new KanjiData(data2);
        case Mode.BYTE:
          return new ByteData(data2);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString3(data2, version6) {
      const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version6);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i10 = 1; i10 < path.length - 1; i10++) {
        optimizedSegs.push(graph.table[path[i10]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data2) {
      return exports.fromArray(
        getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils9();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version23();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version6) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version6);
      for (let i10 = 0; i10 < pos.length; i10++) {
        const row = pos[i10][0];
        const col = pos[i10][1];
        for (let r7 = -1; r7 <= 7; r7++) {
          if (row + r7 <= -1 || size <= row + r7)
            continue;
          for (let c8 = -1; c8 <= 7; c8++) {
            if (col + c8 <= -1 || size <= col + c8)
              continue;
            if (r7 >= 0 && r7 <= 6 && (c8 === 0 || c8 === 6) || c8 >= 0 && c8 <= 6 && (r7 === 0 || r7 === 6) || r7 >= 2 && r7 <= 4 && c8 >= 2 && c8 <= 4) {
              matrix.set(row + r7, col + c8, true, true);
            } else {
              matrix.set(row + r7, col + c8, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r7 = 8; r7 < size - 8; r7++) {
        const value = r7 % 2 === 0;
        matrix.set(r7, 6, value, true);
        matrix.set(6, r7, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version6) {
      const pos = AlignmentPattern.getPositions(version6);
      for (let i10 = 0; i10 < pos.length; i10++) {
        const row = pos[i10][0];
        const col = pos[i10][1];
        for (let r7 = -2; r7 <= 2; r7++) {
          for (let c8 = -2; c8 <= 2; c8++) {
            if (r7 === -2 || r7 === 2 || c8 === -2 || c8 === 2 || r7 === 0 && c8 === 0) {
              matrix.set(row + r7, col + c8, true, true);
            } else {
              matrix.set(row + r7, col + c8, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version6) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version6);
      let row, col, mod;
      for (let i10 = 0; i10 < 18; i10++) {
        row = Math.floor(i10 / 3);
        col = i10 % 3 + size - 8 - 3;
        mod = (bits >> i10 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i10, mod;
      for (i10 = 0; i10 < 15; i10++) {
        mod = (bits >> i10 & 1) === 1;
        if (i10 < 6) {
          matrix.set(i10, 8, mod, true);
        } else if (i10 < 8) {
          matrix.set(i10 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i10, 8, mod, true);
        }
        if (i10 < 8) {
          matrix.set(8, size - i10 - 1, mod, true);
        } else if (i10 < 9) {
          matrix.set(8, 15 - i10 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i10 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data2) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c8 = 0; c8 < 2; c8++) {
            if (!matrix.isReserved(row, col - c8)) {
              let dark = false;
              if (byteIndex < data2.length) {
                dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c8, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version6, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data2) {
        buffer.put(data2.mode.bit, 4);
        buffer.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version6));
        data2.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i10 = 0; i10 < remainingByte; i10++) {
        buffer.put(i10 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version6, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version6, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version6);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version6, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version6, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs2 = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b10 = 0; b10 < ecTotalBlocks; b10++) {
        const dataSize = b10 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b10] = buffer.slice(offset, offset + dataSize);
        ecData[b10] = rs2.encode(dcData[b10]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data2 = new Uint8Array(totalCodewords);
      let index = 0;
      let i10, r7;
      for (i10 = 0; i10 < maxDataSize; i10++) {
        for (r7 = 0; r7 < ecTotalBlocks; r7++) {
          if (i10 < dcData[r7].length) {
            data2[index++] = dcData[r7][i10];
          }
        }
      }
      for (i10 = 0; i10 < ecCount; i10++) {
        for (r7 = 0; r7 < ecTotalBlocks; r7++) {
          data2[index++] = ecData[r7][i10];
        }
      }
      return data2;
    }
    function createSymbol(data2, version6, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data2)) {
        segments = Segments.fromArray(data2);
      } else if (typeof data2 === "string") {
        let estimatedVersion = version6;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data2);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data2, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version6) {
        version6 = bestVersion;
      } else if (version6 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version6, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version6);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version6);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version6);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version6 >= 7) {
        setupVersionInfo(modules, version6);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version6,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create2(data2, options) {
      if (typeof data2 === "undefined" || data2 === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version6;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version6 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data2, version6, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils10 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c8) {
          return [c8, c8];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue9 = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue9 >> 24 & 255,
        g: hexValue9 >> 16 & 255,
        b: hexValue9 >> 8 & 255,
        a: hexValue9 & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions2(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data2 = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i10 = 0; i10 < symbolSize; i10++) {
        for (let j8 = 0; j8 < symbolSize; j8++) {
          let posDst = (i10 * symbolSize + j8) * 4;
          let pxColor = opts.color.light;
          if (i10 >= scaledMargin && j8 >= scaledMargin && i10 < symbolSize - scaledMargin && j8 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i10 - scaledMargin) / scale);
            const jSrc = Math.floor((j8 - scaledMargin) / scale);
            pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils10();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e11) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils10();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x8, y10) {
      let str = cmd + x8;
      if (typeof y10 !== "undefined")
        str += " " + y10;
      return str;
    }
    function qrToPath(data2, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i10 = 0; i10 < data2.length; i10++) {
        const col = Math.floor(i10 % size);
        const row = Math.floor(i10 / size);
        if (!col && !newRow)
          newRow = true;
        if (data2[i10]) {
          lineLength++;
          if (!(i10 > 0 && col > 0 && data2[i10 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data2[i10 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data2 = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser5 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e11) {
            reject(e11);
          }
        });
      }
      try {
        const data2 = QRCode.create(text, opts);
        cb(null, renderFunc(data2, canvas, opts));
      } catch (e11) {
        cb(e11);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data2, _8, opts) {
      return SvgRenderer.render(data2, opts);
    });
  }
});

// node_modules/@web3modal/ui/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  W3mAccountButton: () => ge3,
  W3mConnectButton: () => re5,
  W3mCoreButton: () => Y4,
  W3mModal: () => Le4,
  W3mNetworkSwitch: () => ne5
});
function Nt2() {
  var e11;
  const t8 = (e11 = B3.state.themeMode) != null ? e11 : "dark", o11 = { light: { foreground: { 1: "rgb(20,20,20)", 2: "rgb(121,134,134)", 3: "rgb(158,169,169)" }, background: { 1: "rgb(255,255,255)", 2: "rgb(241,243,243)", 3: "rgb(228,231,231)" }, overlay: "rgba(0,0,0,0.1)" }, dark: { foreground: { 1: "rgb(228,231,231)", 2: "rgb(148,158,158)", 3: "rgb(110,119,119)" }, background: { 1: "rgb(20,20,20)", 2: "rgb(39,42,42)", 3: "rgb(59,64,64)" }, overlay: "rgba(255,255,255,0.1)" } }[t8];
  return { "--w3m-color-fg-1": o11.foreground[1], "--w3m-color-fg-2": o11.foreground[2], "--w3m-color-fg-3": o11.foreground[3], "--w3m-color-bg-1": o11.background[1], "--w3m-color-bg-2": o11.background[2], "--w3m-color-bg-3": o11.background[3], "--w3m-color-overlay": o11.overlay };
}
function _t2() {
  return { "--w3m-accent-color": "#3396FF", "--w3m-accent-fill-color": "#FFFFFF", "--w3m-z-index": "89", "--w3m-background-color": "#3396FF", "--w3m-background-border-radius": "8px", "--w3m-container-border-radius": "30px", "--w3m-wallet-icon-border-radius": "15px", "--w3m-input-border-radius": "28px", "--w3m-button-border-radius": "10px", "--w3m-notification-border-radius": "36px", "--w3m-secondary-button-border-radius": "28px", "--w3m-icon-button-border-radius": "50%", "--w3m-button-hover-highlight-border-radius": "10px", "--w3m-text-big-bold-size": "20px", "--w3m-text-big-bold-weight": "600", "--w3m-text-big-bold-line-height": "24px", "--w3m-text-big-bold-letter-spacing": "-0.03em", "--w3m-text-big-bold-text-transform": "none", "--w3m-text-xsmall-bold-size": "10px", "--w3m-text-xsmall-bold-weight": "700", "--w3m-text-xsmall-bold-line-height": "12px", "--w3m-text-xsmall-bold-letter-spacing": "0.02em", "--w3m-text-xsmall-bold-text-transform": "uppercase", "--w3m-text-xsmall-regular-size": "12px", "--w3m-text-xsmall-regular-weight": "600", "--w3m-text-xsmall-regular-line-height": "14px", "--w3m-text-xsmall-regular-letter-spacing": "-0.03em", "--w3m-text-xsmall-regular-text-transform": "none", "--w3m-text-small-thin-size": "14px", "--w3m-text-small-thin-weight": "500", "--w3m-text-small-thin-line-height": "16px", "--w3m-text-small-thin-letter-spacing": "-0.03em", "--w3m-text-small-thin-text-transform": "none", "--w3m-text-small-regular-size": "14px", "--w3m-text-small-regular-weight": "600", "--w3m-text-small-regular-line-height": "16px", "--w3m-text-small-regular-letter-spacing": "-0.03em", "--w3m-text-small-regular-text-transform": "none", "--w3m-text-medium-regular-size": "16px", "--w3m-text-medium-regular-weight": "600", "--w3m-text-medium-regular-line-height": "20px", "--w3m-text-medium-regular-letter-spacing": "-0.03em", "--w3m-text-medium-regular-text-transform": "none", "--w3m-font-family": "-apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', sans-serif", "--w3m-success-color": "rgb(38,181,98)", "--w3m-error-color": "rgb(242, 90, 103)" };
}
function Dt2() {
  const { themeVariables: e11 } = B3.state;
  return { "--w3m-background-image-url": e11 != null && e11["--w3m-background-image-url"] ? `url(${e11["--w3m-background-image-url"]})` : "none" };
}
function Ve3(e11, t8, o11) {
  return e11 === t8 ? false : (e11 - t8 < 0 ? t8 - e11 : e11 - t8) <= o11 + Oa;
}
function Ia(e11, t8) {
  const o11 = Array.prototype.slice.call(import_qrcode.default.create(e11, { errorCorrectionLevel: t8 }).modules.data, 0), r7 = Math.sqrt(o11.length);
  return o11.reduce((a9, n8, l9) => (l9 % r7 === 0 ? a9.push([n8]) : a9[a9.length - 1].push(n8)) && a9, []);
}
var import_qrcode, At2, wt2, Lt, Tt2, pt3, $e3, m5, Rt2, Zt, Ht, Oe3, ae4, St2, Bt, Vt, ce3, G5, Ut, zt2, Gt, Ze4, de2, p5, Ft, Kt, qt, ut3, Ie3, Qt, Yt, Xt, Jt, He4, ea, ta, aa, oa, Se3, ra, la, na, me3, F4, ia, ie4, J4, sa, ca, gt3, da, ma, vt2, ha, s7, wa, pa, ua, Be4, he5, ga, va, ba, bt2, We4, fa, xa, ya, Me3, oe4, Ca, ka, $a, ft3, Ee2, Oa, xt2, B5, Wa, Ma, Ea, ja, we2, K3, Pa, Aa, La, yt3, je3, Ta, Na, _a, Da, Ue2, Ra, Za, Ha, ze3, pe3, Sa, Ba, Va, Ct2, Pe3, Ua, za, Ga, V4, S5, Fa, Ka, qa, Ge3, ue2, Qa, Ya, Xa, kt, Ja, eo, $t, Fe4, to, ao, Ot2, Ke3, oo, ro, lo, It2, no, io, so, qe3, ge3, co, mo, ho, Qe4, ve, wo, po, uo, be4, q3, T2, go, vo, bo, fo, Ye3, xo, yo, Co, fe2, Q3, ko, $o, Oo, Xe3, xe3, Io, Wo, Mo, Ae3, re5, Eo, jo, le2, Y4, Po, Ao, Lo, To, Je3, No, _o, Do, Ro, et3, Zo, Ho, So, Bo, tt3, Vo, Uo, zo, Wt, Le4, Go, Fo, Ko, Te3, ne5, qo, Qo, Yo, Xo, at3, Jo, er2, tr2, Mt, Ne3, ar2, or3, rr2, lr2, ot3, nr2, ir2, sr2, rt3, cr2, dr2, mr, hr2, lt3, wr, pr, ur2, Et3, _e2, gr2, vr, br, fr, nt3, xr, yr, Cr, kr, it3, $r, Or, Ir, st3, ye3, Wr, Mr, Er, jr, ct3, Pr, Ar, Lr, dt3, Tr, Nr, _r, Dr, mt3, Rr, Zr, Hr, jt, De2, Sr, Br, Vr, Ce3, ht3, X4;
var init_dist2 = __esm({
  "node_modules/@web3modal/ui/dist/index.js"() {
    init_lit();
    init_decorators();
    init_dist();
    init_class_map2();
    init_lit_html();
    init_main_es();
    init_if_defined2();
    import_qrcode = __toESM(require_browser5(), 1);
    At2 = Object.defineProperty;
    wt2 = Object.getOwnPropertySymbols;
    Lt = Object.prototype.hasOwnProperty;
    Tt2 = Object.prototype.propertyIsEnumerable;
    pt3 = (e11, t8, o11) => t8 in e11 ? At2(e11, t8, { enumerable: true, configurable: true, writable: true, value: o11 }) : e11[t8] = o11;
    $e3 = (e11, t8) => {
      for (var o11 in t8 || (t8 = {}))
        Lt.call(t8, o11) && pt3(e11, o11, t8[o11]);
      if (wt2)
        for (var o11 of wt2(t8))
          Tt2.call(t8, o11) && pt3(e11, o11, t8[o11]);
      return e11;
    };
    m5 = { setTheme() {
      const e11 = document.querySelector(":root"), { themeVariables: t8 } = B3.state;
      if (e11) {
        const o11 = $e3($e3($e3($e3({}, Nt2()), _t2()), t8), Dt2());
        Object.entries(o11).forEach(([r7, a9]) => e11.style.setProperty(r7, a9));
      }
    }, globalCss: i3`*,::after,::before{margin:0;padding:0;box-sizing:border-box;font-style:normal;text-rendering:optimizeSpeed;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent;backface-visibility:hidden}button{cursor:pointer;display:flex;justify-content:center;align-items:center;position:relative;border:none;background-color:transparent}button::after{content:'';position:absolute;inset:0;transition:background-color,.2s ease}button:disabled{cursor:not-allowed}button svg,button w3m-text{position:relative;z-index:1}input{border:none;outline:0;appearance:none}img{display:block}::selection{color:var(--w3m-accent-fill-color);background:var(--w3m-accent-color)}` };
    Rt2 = i3`button{display:flex;border-radius:var(--w3m-button-hover-highlight-border-radius);flex-direction:column;transition:background-color .2s ease;justify-content:center;padding:5px;width:100px}button:hover{background-color:var(--w3m-color-overlay)}button>div{display:flex;justify-content:center;align-items:center;width:32px;height:32px;box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);background-color:var(--w3m-accent-color);border-radius:var(--w3m-icon-button-border-radius);margin-bottom:4px}button path{fill:var(--w3m-accent-fill-color)}`;
    Zt = Object.defineProperty;
    Ht = Object.getOwnPropertyDescriptor;
    Oe3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ht(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Zt(t8, o11, a9), a9;
    };
    ae4 = class extends s6 {
      constructor() {
        super(...arguments), this.icon = void 0, this.label = "", this.onClick = () => null;
      }
      render() {
        return x4`<button @click="${this.onClick}"><div>${this.icon}</div><w3m-text variant="xsmall-regular" color="accent">${this.label}</w3m-text></button>`;
      }
    };
    ae4.styles = [m5.globalCss, Rt2], Oe3([e6()], ae4.prototype, "icon", 2), Oe3([e6()], ae4.prototype, "label", 2), Oe3([e6()], ae4.prototype, "onClick", 2), ae4 = Oe3([e5("w3m-box-button")], ae4);
    St2 = i3`button{border-radius:var(--w3m-secondary-button-border-radius);height:28px;padding:0 10px;background-color:var(--w3m-accent-color)}button path{fill:var(--w3m-accent-fill-color)}button::after{border-radius:inherit;border:1px solid var(--w3m-color-overlay)}button:disabled::after{background-color:transparent}.w3m-icon-left svg{margin-right:5px}.w3m-icon-right svg{margin-left:5px}button:hover::after{background-color:var(--w3m-color-overlay)}button:disabled{background-color:var(--w3m-color-bg-3)}`;
    Bt = Object.defineProperty;
    Vt = Object.getOwnPropertyDescriptor;
    ce3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Vt(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Bt(t8, o11, a9), a9;
    };
    G5 = class extends s6 {
      constructor() {
        super(...arguments), this.disabled = false, this.iconLeft = void 0, this.iconRight = void 0, this.onClick = () => null;
      }
      render() {
        const e11 = { "w3m-icon-left": this.iconLeft !== void 0, "w3m-icon-right": this.iconRight !== void 0 };
        return x4`<button class="${o8(e11)}" ?disabled="${this.disabled}" @click="${this.onClick}">${this.iconLeft}<w3m-text variant="small-regular" color="inverse"><slot></slot></w3m-text>${this.iconRight}</button>`;
      }
    };
    G5.styles = [m5.globalCss, St2], ce3([e6()], G5.prototype, "disabled", 2), ce3([e6()], G5.prototype, "iconLeft", 2), ce3([e6()], G5.prototype, "iconRight", 2), ce3([e6()], G5.prototype, "onClick", 2), G5 = ce3([e5("w3m-button")], G5);
    Ut = i3`:host{display:inline-block}button{padding:0 15px 1px;height:40px;border-radius:var(--w3m-button-border-radius);color:var(--w3m-accent-fill-color);background-color:var(--w3m-accent-color)}button::after{content:'';inset:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--w3m-color-overlay)}button:hover::after{background-color:var(--w3m-color-overlay)}button:disabled{padding-bottom:0;background-color:var(--w3m-color-bg-3);color:var(--w3m-color-fg-3)}.w3m-secondary{color:var(--w3m-accent-color);background-color:transparent}.w3m-secondary::after{display:none}`;
    zt2 = Object.defineProperty;
    Gt = Object.getOwnPropertyDescriptor;
    Ze4 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Gt(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && zt2(t8, o11, a9), a9;
    };
    de2 = class extends s6 {
      constructor() {
        super(...arguments), this.disabled = false, this.variant = "primary";
      }
      render() {
        const e11 = { "w3m-secondary": this.variant === "secondary" };
        return x4`<button ?disabled="${this.disabled}" class="${o8(e11)}"><slot></slot></button>`;
      }
    };
    de2.styles = [m5.globalCss, Ut], Ze4([e6()], de2.prototype, "disabled", 2), Ze4([e6()], de2.prototype, "variant", 2), de2 = Ze4([e5("w3m-button-big")], de2);
    p5 = { CROSS_ICON: b5`<svg width="12" height="12" viewBox="0 0 12 12"><path d="M9.94 11A.75.75 0 1 0 11 9.94L7.414 6.353a.5.5 0 0 1 0-.708L11 2.061A.75.75 0 1 0 9.94 1L6.353 4.586a.5.5 0 0 1-.708 0L2.061 1A.75.75 0 0 0 1 2.06l3.586 3.586a.5.5 0 0 1 0 .708L1 9.939A.75.75 0 1 0 2.06 11l3.586-3.586a.5.5 0 0 1 .708 0L9.939 11Z" fill="#fff"/></svg>`, WALLET_CONNECT_LOGO: b5`<svg width="178" height="29" viewBox="0 0 178 29" id="w3m-wc-logo"><path d="M10.683 7.926c5.284-5.17 13.85-5.17 19.134 0l.636.623a.652.652 0 0 1 0 .936l-2.176 2.129a.343.343 0 0 1-.478 0l-.875-.857c-3.686-3.607-9.662-3.607-13.348 0l-.937.918a.343.343 0 0 1-.479 0l-2.175-2.13a.652.652 0 0 1 0-.936l.698-.683Zm23.633 4.403 1.935 1.895a.652.652 0 0 1 0 .936l-8.73 8.543a.687.687 0 0 1-.956 0L20.37 17.64a.172.172 0 0 0-.239 0l-6.195 6.063a.687.687 0 0 1-.957 0l-8.73-8.543a.652.652 0 0 1 0-.936l1.936-1.895a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .239 0l6.195-6.064a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .24 0l6.195-6.064a.687.687 0 0 1 .956 0ZM48.093 20.948l2.338-9.355c.139-.515.258-1.07.416-1.942.12.872.258 1.427.357 1.942l2.022 9.355h4.181l3.528-13.874h-3.21l-1.943 8.523a24.825 24.825 0 0 0-.456 2.457c-.158-.931-.317-1.625-.495-2.438l-1.883-8.542h-4.201l-2.042 8.542a41.204 41.204 0 0 0-.475 2.438 41.208 41.208 0 0 0-.476-2.438l-1.903-8.542h-3.349l3.508 13.874h4.083ZM63.33 21.304c1.585 0 2.596-.654 3.11-1.605-.059.297-.078.595-.078.892v.357h2.655V15.22c0-2.735-1.248-4.32-4.3-4.32-2.636 0-4.36 1.466-4.52 3.487h2.914c.1-.891.734-1.426 1.705-1.426.911 0 1.407.515 1.407 1.11 0 .435-.258.693-1.03.792l-1.388.159c-2.061.257-3.825 1.01-3.825 3.19 0 1.982 1.645 3.092 3.35 3.092Zm.891-2.041c-.773 0-1.348-.436-1.348-1.19 0-.733.655-1.09 1.645-1.268l.674-.119c.575-.118.892-.218 1.09-.396v.912c0 1.228-.892 2.06-2.06 2.06ZM70.398 7.074v13.874h2.874V7.074h-2.874ZM74.934 7.074v13.874h2.874V7.074h-2.874ZM84.08 21.304c2.735 0 4.5-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922H81.92ZM94.92 21.146c.633 0 1.248-.1 1.525-.179v-2.18c-.218.04-.475.06-.693.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.338v-2.24h-2.338V7.788H91.47v3.448H89.37v2.24h2.1v4.201c0 2.3 1.15 3.469 3.45 3.469ZM104.62 21.304c3.924 0 6.302-2.299 6.599-5.608h-3.111c-.238 1.803-1.506 3.032-3.369 3.032-2.2 0-3.746-1.784-3.746-4.796 0-2.953 1.605-4.638 3.805-4.638 1.883 0 2.953 1.15 3.171 2.834h3.191c-.317-3.448-2.854-5.41-6.342-5.41-3.984 0-7.036 2.695-7.036 7.214 0 4.677 2.676 7.372 6.838 7.372ZM117.449 21.304c2.993 0 5.114-1.882 5.114-5.172 0-3.23-2.121-5.233-5.114-5.233-2.972 0-5.093 2.002-5.093 5.233 0 3.29 2.101 5.172 5.093 5.172Zm0-2.22c-1.327 0-2.18-1.09-2.18-2.952 0-1.903.892-2.973 2.18-2.973 1.308 0 2.2 1.07 2.2 2.973 0 1.862-.872 2.953-2.2 2.953ZM126.569 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.229-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM137.464 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.228-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM149.949 21.304c2.735 0 4.499-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922h-3.984ZM160.876 21.304c3.013 0 4.658-1.645 4.975-4.201h-2.874c-.099 1.07-.713 1.982-2.001 1.982-1.309 0-2.2-1.21-2.2-2.993 0-1.942 1.03-2.933 2.259-2.933 1.209 0 1.803.872 1.883 1.882h2.873c-.218-2.358-1.823-4.142-4.776-4.142-2.874 0-5.153 1.903-5.153 5.193 0 3.25 1.923 5.212 5.014 5.212ZM172.067 21.146c.634 0 1.248-.1 1.526-.179v-2.18c-.218.04-.476.06-.694.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.339v-2.24h-2.339V7.788h-2.854v3.448h-2.1v2.24h2.1v4.201c0 2.3 1.15 3.469 3.449 3.469Z" fill="#fff"/></svg>`, WALLET_CONNECT_ICON: b5`<svg width="28" height="20" viewBox="0 0 28 20"><g clip-path="url(#a)"><path d="M7.386 6.482c3.653-3.576 9.575-3.576 13.228 0l.44.43a.451.451 0 0 1 0 .648L19.55 9.033a.237.237 0 0 1-.33 0l-.606-.592c-2.548-2.496-6.68-2.496-9.228 0l-.648.634a.237.237 0 0 1-.33 0L6.902 7.602a.451.451 0 0 1 0-.647l.483-.473Zm16.338 3.046 1.339 1.31a.451.451 0 0 1 0 .648l-6.035 5.909a.475.475 0 0 1-.662 0L14.083 13.2a.119.119 0 0 0-.166 0l-4.283 4.194a.475.475 0 0 1-.662 0l-6.035-5.91a.451.451 0 0 1 0-.647l1.338-1.31a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0Z" fill="#000000"/></g><defs><clipPath id="a"><path fill="#ffffff" d="M0 0h28v20H0z"/></clipPath></defs></svg>`, WALLET_CONNECT_ICON_COLORED: b5`<svg width="96" height="96" fill="none"><path fill="#fff" d="M25.322 33.597c12.525-12.263 32.83-12.263 45.355 0l1.507 1.476a1.547 1.547 0 0 1 0 2.22l-5.156 5.048a.814.814 0 0 1-1.134 0l-2.074-2.03c-8.737-8.555-22.903-8.555-31.64 0l-2.222 2.175a.814.814 0 0 1-1.134 0l-5.156-5.049a1.547 1.547 0 0 1 0-2.22l1.654-1.62Zm56.019 10.44 4.589 4.494a1.547 1.547 0 0 1 0 2.22l-20.693 20.26a1.628 1.628 0 0 1-2.267 0L48.283 56.632a.407.407 0 0 0-.567 0L33.03 71.012a1.628 1.628 0 0 1-2.268 0L10.07 50.75a1.547 1.547 0 0 1 0-2.22l4.59-4.494a1.628 1.628 0 0 1 2.267 0l14.687 14.38c.156.153.41.153.567 0l14.685-14.38a1.628 1.628 0 0 1 2.268 0l14.687 14.38c.156.153.41.153.567 0l14.686-14.38a1.628 1.628 0 0 1 2.268 0Z"/><path stroke="#000" d="M25.672 33.954c12.33-12.072 32.325-12.072 44.655 0l1.508 1.476a1.047 1.047 0 0 1 0 1.506l-5.157 5.048a.314.314 0 0 1-.434 0l-2.074-2.03c-8.932-8.746-23.409-8.746-32.34 0l-2.222 2.174a.314.314 0 0 1-.434 0l-5.157-5.048a1.047 1.047 0 0 1 0-1.506l1.655-1.62Zm55.319 10.44 4.59 4.494a1.047 1.047 0 0 1 0 1.506l-20.694 20.26a1.128 1.128 0 0 1-1.568 0l-14.686-14.38a.907.907 0 0 0-1.267 0L32.68 70.655a1.128 1.128 0 0 1-1.568 0L10.42 50.394a1.047 1.047 0 0 1 0-1.506l4.59-4.493a1.128 1.128 0 0 1 1.567 0l14.687 14.379a.907.907 0 0 0 1.266 0l-.35-.357.35.357 14.686-14.38a1.128 1.128 0 0 1 1.568 0l14.687 14.38a.907.907 0 0 0 1.267 0l14.686-14.38a1.128 1.128 0 0 1 1.568 0Z"/></svg>`, BACK_ICON: b5`<svg width="10" height="18" viewBox="0 0 10 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.735.179a.75.75 0 0 1 .087 1.057L2.92 8.192a1.25 1.25 0 0 0 0 1.617l5.902 6.956a.75.75 0 1 1-1.144.97L1.776 10.78a2.75 2.75 0 0 1 0-3.559L7.678.265A.75.75 0 0 1 8.735.18Z" fill="#fff"/></svg>`, COPY_ICON: b5`<svg width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M7.01 7.01c.03-1.545.138-2.5.535-3.28A5 5 0 0 1 9.73 1.545C10.8 1 12.2 1 15 1c2.8 0 4.2 0 5.27.545a5 5 0 0 1 2.185 2.185C23 4.8 23 6.2 23 9c0 2.8 0 4.2-.545 5.27a5 5 0 0 1-2.185 2.185c-.78.397-1.735.505-3.28.534l-.001.01c-.03 1.54-.138 2.493-.534 3.27a5 5 0 0 1-2.185 2.186C13.2 23 11.8 23 9 23c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C1 19.2 1 17.8 1 15c0-2.8 0-4.2.545-5.27A5 5 0 0 1 3.73 7.545C4.508 7.149 5.46 7.04 7 7.01h.01ZM15 15.5c-1.425 0-2.403-.001-3.162-.063-.74-.06-1.139-.172-1.427-.319a3.5 3.5 0 0 1-1.53-1.529c-.146-.288-.257-.686-.318-1.427C8.501 11.403 8.5 10.425 8.5 9c0-1.425.001-2.403.063-3.162.06-.74.172-1.139.318-1.427a3.5 3.5 0 0 1 1.53-1.53c.288-.146.686-.257 1.427-.318.759-.062 1.737-.063 3.162-.063 1.425 0 2.403.001 3.162.063.74.06 1.139.172 1.427.318a3.5 3.5 0 0 1 1.53 1.53c.146.288.257.686.318 1.427.062.759.063 1.737.063 3.162 0 1.425-.001 2.403-.063 3.162-.06.74-.172 1.139-.319 1.427a3.5 3.5 0 0 1-1.529 1.53c-.288.146-.686.257-1.427.318-.759.062-1.737.063-3.162.063ZM7 8.511c-.444.009-.825.025-1.162.052-.74.06-1.139.172-1.427.318a3.5 3.5 0 0 0-1.53 1.53c-.146.288-.257.686-.318 1.427-.062.759-.063 1.737-.063 3.162 0 1.425.001 2.403.063 3.162.06.74.172 1.139.318 1.427a3.5 3.5 0 0 0 1.53 1.53c.288.146.686.257 1.427.318.759.062 1.737.063 3.162.063 1.425 0 2.403-.001 3.162-.063.74-.06 1.139-.172 1.427-.319a3.5 3.5 0 0 0 1.53-1.53c.146-.287.257-.685.318-1.426.027-.337.043-.718.052-1.162H15c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C7 13.2 7 11.8 7 9v-.489Z" clip-rule="evenodd"/></svg>`, RETRY_ICON: b5`<svg width="15" height="16" viewBox="0 0 15 16"><path d="M6.464 2.03A.75.75 0 0 0 5.403.97L2.08 4.293a1 1 0 0 0 0 1.414L5.403 9.03a.75.75 0 0 0 1.06-1.06L4.672 6.177a.25.25 0 0 1 .177-.427h2.085a4 4 0 1 1-3.93 4.746c-.077-.407-.405-.746-.82-.746-.414 0-.755.338-.7.748a5.501 5.501 0 1 0 5.45-6.248H4.848a.25.25 0 0 1-.177-.427L6.464 2.03Z" fill="#fff"/></svg>`, DESKTOP_ICON: b5`<svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 5.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C2.204 1 3.13 1 4.98 1h6.04c1.85 0 2.775 0 3.466.394a3 3 0 0 1 1.12 1.12C16 3.204 16 4.13 16 5.98v1.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C13.796 12 12.87 12 11.02 12H4.98c-1.85 0-2.775 0-3.466-.394a3 3 0 0 1-1.12-1.12C0 9.796 0 8.87 0 7.02V5.98ZM4.98 2.5h6.04c.953 0 1.568.001 2.034.043.446.04.608.108.69.154a1.5 1.5 0 0 1 .559.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033v1.04c0 .952-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.046-.243.114-.69.154-.466.042-1.08.043-2.033.043H4.98c-.952 0-1.568-.001-2.034-.043-.446-.04-.608-.108-.69-.154a1.5 1.5 0 0 1-.559-.56c-.046-.08-.114-.243-.154-.69-.042-.465-.043-1.08-.043-2.033V5.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.046.243-.114.69-.154.465-.042 1.08-.043 2.033-.043Z" fill="#fff"/><path d="M4 14.25a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, MOBILE_ICON: b5`<svg width="16" height="16" viewBox="0 0 16 16"><path d="M6.75 5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M3 4.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C5.204 0 6.136 0 8 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C13 2.204 13 3.13 13 4.98v6.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C10.796 16 9.864 16 8 16s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C3 13.796 3 12.87 3 11.02V4.98Zm8.5 0v6.04c0 .953-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.046-.08-.114-.243-.154-.69-.042-.466-.043-1.08-.043-2.033V4.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.045.243-.113.693-.154C6.42 1.501 7.041 1.5 8 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033Z" fill="#fff"/></svg>`, ARROW_DOWN_ICON: b5`<svg width="14" height="14" viewBox="0 0 14 14"><path d="M2.28 7.47a.75.75 0 0 0-1.06 1.06l5.25 5.25a.75.75 0 0 0 1.06 0l5.25-5.25a.75.75 0 0 0-1.06-1.06l-3.544 3.543a.25.25 0 0 1-.426-.177V.75a.75.75 0 0 0-1.5 0v10.086a.25.25 0 0 1-.427.176L2.28 7.47Z" fill="#fff"/></svg>`, ARROW_UP_RIGHT_ICON: b5`<svg width="15" height="14" fill="none"><path d="M4.5 1.75A.75.75 0 0 1 5.25 1H12a1.5 1.5 0 0 1 1.5 1.5v6.75a.75.75 0 0 1-1.5 0V4.164a.25.25 0 0 0-.427-.176L4.061 11.5A.75.75 0 0 1 3 10.44l7.513-7.513a.25.25 0 0 0-.177-.427H5.25a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, ARROW_RIGHT_ICON: b5`<svg width="6" height="14" viewBox="0 0 6 14"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.181 1.099a.75.75 0 0 1 1.024.279l2.433 4.258a2.75 2.75 0 0 1 0 2.729l-2.433 4.257a.75.75 0 1 1-1.303-.744L4.335 7.62a1.25 1.25 0 0 0 0-1.24L1.902 2.122a.75.75 0 0 1 .28-1.023Z" fill="#fff"/></svg>`, QRCODE_ICON: b5`<svg width="25" height="24" viewBox="0 0 25 24"><path d="M23.748 9a.748.748 0 0 0 .748-.752c-.018-2.596-.128-4.07-.784-5.22a6 6 0 0 0-2.24-2.24c-1.15-.656-2.624-.766-5.22-.784a.748.748 0 0 0-.752.748c0 .414.335.749.748.752 1.015.007 1.82.028 2.494.088.995.09 1.561.256 1.988.5.7.398 1.28.978 1.679 1.678.243.427.41.993.498 1.988.061.675.082 1.479.09 2.493a.753.753 0 0 0 .75.749ZM3.527.788C4.677.132 6.152.022 8.747.004A.748.748 0 0 1 9.5.752a.753.753 0 0 1-.749.752c-1.014.007-1.818.028-2.493.088-.995.09-1.561.256-1.988.5-.7.398-1.28.978-1.679 1.678-.243.427-.41.993-.499 1.988-.06.675-.081 1.479-.088 2.493A.753.753 0 0 1 1.252 9a.748.748 0 0 1-.748-.752c.018-2.596.128-4.07.784-5.22a6 6 0 0 1 2.24-2.24ZM1.252 15a.748.748 0 0 0-.748.752c.018 2.596.128 4.07.784 5.22a6 6 0 0 0 2.24 2.24c1.15.656 2.624.766 5.22.784a.748.748 0 0 0 .752-.748.753.753 0 0 0-.749-.752c-1.014-.007-1.818-.028-2.493-.089-.995-.089-1.561-.255-1.988-.498a4.5 4.5 0 0 1-1.679-1.68c-.243-.426-.41-.992-.499-1.987-.06-.675-.081-1.479-.088-2.493A.753.753 0 0 0 1.252 15ZM22.996 15.749a.753.753 0 0 1 .752-.749c.415 0 .751.338.748.752-.018 2.596-.128 4.07-.784 5.22a6 6 0 0 1-2.24 2.24c-1.15.656-2.624.766-5.22.784a.748.748 0 0 1-.752-.748c0-.414.335-.749.748-.752 1.015-.007 1.82-.028 2.494-.089.995-.089 1.561-.255 1.988-.498a4.5 4.5 0 0 0 1.679-1.68c.243-.426.41-.992.498-1.987.061-.675.082-1.479.09-2.493Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 11h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 4H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1ZM13.5 6.5A2.5 2.5 0 0 1 16 4h2a2.5 2.5 0 0 1 2.5 2.5v2A2.5 2.5 0 0 1 18 11h-2a2.5 2.5 0 0 1-2.5-2.5v-2Zm2.5-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1ZM7 13a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 20h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 13H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z" fill="#fff"/><path d="M13.5 15.5c0-.465 0-.697.038-.89a2 2 0 0 1 1.572-1.572C15.303 13 15.535 13 16 13v2.5h-2.5ZM18 13c.465 0 .697 0 .89.038a2 2 0 0 1 1.572 1.572c.038.193.038.425.038.89H18V13ZM18 17.5h2.5c0 .465 0 .697-.038.89a2 2 0 0 1-1.572 1.572C18.697 20 18.465 20 18 20v-2.5ZM13.5 17.5H16V20c-.465 0-.697 0-.89-.038a2 2 0 0 1-1.572-1.572c-.038-.193-.038-.425-.038-.89Z" fill="#fff"/></svg>`, SCAN_ICON: b5`<svg width="16" height="16" fill="none"><path fill="#fff" d="M10 15.216c0 .422.347.763.768.74 1.202-.064 2.025-.222 2.71-.613a5.001 5.001 0 0 0 1.865-1.866c.39-.684.549-1.507.613-2.709a.735.735 0 0 0-.74-.768.768.768 0 0 0-.76.732c-.009.157-.02.306-.032.447-.073.812-.206 1.244-.384 1.555-.31.545-.761.996-1.306 1.306-.311.178-.743.311-1.555.384-.141.013-.29.023-.447.032a.768.768 0 0 0-.732.76ZM10 .784c0 .407.325.737.732.76.157.009.306.02.447.032.812.073 1.244.206 1.555.384a3.5 3.5 0 0 1 1.306 1.306c.178.311.311.743.384 1.555.013.142.023.29.032.447a.768.768 0 0 0 .76.732.734.734 0 0 0 .74-.768c-.064-1.202-.222-2.025-.613-2.71A5 5 0 0 0 13.477.658c-.684-.39-1.507-.549-2.709-.613a.735.735 0 0 0-.768.74ZM5.232.044A.735.735 0 0 1 6 .784a.768.768 0 0 1-.732.76c-.157.009-.305.02-.447.032-.812.073-1.244.206-1.555.384A3.5 3.5 0 0 0 1.96 3.266c-.178.311-.311.743-.384 1.555-.013.142-.023.29-.032.447A.768.768 0 0 1 .784 6a.735.735 0 0 1-.74-.768c.064-1.202.222-2.025.613-2.71A5 5 0 0 1 2.523.658C3.207.267 4.03.108 5.233.044ZM5.268 14.456a.768.768 0 0 1 .732.76.734.734 0 0 1-.768.74c-1.202-.064-2.025-.222-2.71-.613a5 5 0 0 1-1.865-1.866c-.39-.684-.549-1.507-.613-2.709A.735.735 0 0 1 .784 10c.407 0 .737.325.76.732.009.157.02.306.032.447.073.812.206 1.244.384 1.555a3.5 3.5 0 0 0 1.306 1.306c.311.178.743.311 1.555.384.142.013.29.023.447.032Z"/></svg>`, CHECKMARK_ICON: b5`<svg width="13" height="12" viewBox="0 0 13 12"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.155.132a.75.75 0 0 1 .232 1.035L5.821 11.535a1 1 0 0 1-1.626.09L.665 7.21a.75.75 0 1 1 1.17-.937L4.71 9.867a.25.25 0 0 0 .406-.023L11.12.364a.75.75 0 0 1 1.035-.232Z" fill="#fff"/></svg>`, HELP_ETH_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#j)"><rect width="60" height="60" rx="30" fill="#987DE8"/><path fill-rule="evenodd" clip-rule="evenodd" d="m15.48 28.367 11.966-19.3c1.174-1.892 3.927-1.892 5.1 0l11.97 19.306a6 6 0 0 1 .9 3.142v.028a6 6 0 0 1-1.154 3.56L33.227 50.208c-1.599 2.188-4.864 2.188-6.461 0L15.733 35.095a6 6 0 0 1-1.154-3.538v-.029a6 6 0 0 1 .9-3.161Z" fill="#fff"/><path d="M30.84 10.112a.992.992 0 0 0-.844-.464V24.5l12.598 5.53c.081-.466-.001-.963-.27-1.398L30.84 10.112Z" fill="#643CDD"/><path d="M29.996 9.648a.991.991 0 0 0-.845.465l-11.489 18.53a1.991 1.991 0 0 0-.264 1.387l12.598-5.53V9.648Z" fill="#BDADEB"/><path d="M29.996 50.544a.994.994 0 0 0 .808-.41l11.235-15.38c.307-.434-.193-.988-.658-.72L31.49 39.71a2.998 2.998 0 0 1-1.494.398v10.437Z" fill="#643CDD"/><path d="M17.966 34.762 29.19 50.134c.2.274.503.41.807.41V40.108a2.998 2.998 0 0 1-1.493-.398l-9.884-5.676c-.468-.27-.971.292-.653.728Z" fill="#BDADEB"/><path d="M42.594 30.03 29.996 24.5v13.138a3 3 0 0 0 1.495-.399l10.149-5.83c.525-.31.856-.823.954-1.38Z" fill="#401AB3"/><path d="M29.996 37.638V24.462l-12.598 5.566c.098.564.437 1.083.974 1.392l10.13 5.82c.462.265.978.398 1.494.398Z" fill="#7C5AE2"/></g><rect class="help-img-highlight" x=".5" y=".5" width="59" height="59" rx="29.5"/><defs><clipPath id="j"><rect width="60" height="60" rx="30" fill="#fff"/></clipPath></defs></svg>`, HELP_PAINTING_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#k)"><rect width="60" height="60" rx="3" fill="#C653C6"/><path d="M52.094 47.344c0-4.246-1.436-9.557-5.885-12.4a2.876 2.876 0 0 0-1.615-3.891v-.819a4.037 4.037 0 0 0-1.34-3.007 4.75 4.75 0 0 0-2.41-6.252v-5.506c0-6.248-5.065-11.313-11.313-11.313-6.247 0-11.312 5.065-11.312 11.313v2.152a3.343 3.343 0 0 0-1.18 5.045 4.738 4.738 0 0 0-1.633 3.584 4.73 4.73 0 0 0 .956 2.858 5.218 5.218 0 0 0-2.358 6.815c-3.06 4.129-6.098 8.298-6.098 15.64 0 2.668.364 4.856.731 6.385.184.765.368 1.366.509 1.78a12.721 12.721 0 0 0 .225.611l.015.037.005.011.001.004v.002h.001l.92-.393-.92.394.26.606h38.26l.291-.49-.86-.51.86.51v-.001l.002-.002.002-.005.01-.017.035-.06.127-.225c.108-.195.26-.477.441-.835.363-.714.845-1.732 1.328-2.953.959-2.427 1.945-5.725 1.945-9.068Z" fill="#E87DE8" stroke="#fff" stroke-width="2"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.5 29.5c-3-.5-5.5-3-5.503-7l.002-7c0-.466 0-.698.026-.893a3 3 0 0 1 2.582-2.582c.195-.026.428-.026.893-.026 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.398 0 2.097 0 2.648.229a3 3 0 0 1 1.624 1.623c.228.552.228 1.25.228 2.649v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.495 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z" fill="#fff"/></g><rect class="help-img-highlight" x=".5" y=".5" width="59" height="59" rx="2.5"/><defs><clipPath id="k"><rect width="60" height="60" rx="3" fill="#fff"/></clipPath></defs></svg>`, HELP_CHART_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#l)"><path d="M0 25.01C0 15.76 0 11.133 1.97 7.678a15 15 0 0 1 5.598-5.597C11.023.11 15.648.11 24.9.11h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.597C60 11.133 60 15.758 60 25.01v10.2c0 9.252 0 13.877-1.97 17.332a15 15 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a14.999 14.999 0 0 1-5.597-5.598C0 49.087 0 44.462 0 35.21v-10.2Z" fill="#1DC956"/><path d="M.5 25.01c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.289a14.5 14.5 0 0 1 5.412-5.41c1.639-.936 3.579-1.418 6.289-1.661C16.822.61 20.265.61 24.9.61h10.2c4.635 0 8.078 0 10.795.245 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.579 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.795-.244 2.71-.726 4.65-1.66 6.29a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.412C1.47 50.655.988 48.716.745 46.005.5 43.288.5 39.845.5 35.21v-10.2Z" stroke="#fff" stroke-opacity=".1"/><path d="M16.109 60c-3.833-.179-6.41-.645-8.541-1.86a15 15 0 0 1-5.598-5.598C.553 50.057.155 46.967.043 41.985l4.146-1.382a4 4 0 0 0 2.48-2.39l4.654-12.409a2 2 0 0 1 2.505-1.195l2.526.842a2 2 0 0 0 2.422-1.003l2.968-5.938c.81-1.62 3.185-1.415 3.705.32l3.774 12.581a2 2 0 0 0 3.025 1.09l3.342-2.228c.27-.18.49-.422.646-.706l5.297-9.712a2 2 0 0 1 1.428-1.016l4.134-.689a2 2 0 0 1 1.61.437l3.892 3.243a2 2 0 0 0 2.694-.122l4.633-4.632C60 19.28 60 21.88 60 25.01v10.2c0 9.252 0 13.877-1.97 17.332a14.998 14.998 0 0 1-5.598 5.598c-2.131 1.215-4.708 1.681-8.54 1.86H16.108Z" fill="#2BEE6C"/><path d="M.072 43.03a112.37 112.37 0 0 1-.048-2.093l3.85-1.283a3 3 0 0 0 1.86-1.793l4.653-12.408a3 3 0 0 1 3.758-1.793l2.526.842a1 1 0 0 0 1.21-.501l2.97-5.938c1.214-2.43 4.775-2.123 5.556.48l3.774 12.58a1 1 0 0 0 1.513.545l3.341-2.227a1 1 0 0 0 .323-.353l5.298-9.712a3 3 0 0 1 2.14-1.523l4.135-.69a3 3 0 0 1 2.414.655l3.892 3.244a1 1 0 0 0 1.347-.061l5.28-5.28c.046.845.077 1.752.097 2.732l-3.962 3.962a3 3 0 0 1-4.042.183l-3.893-3.243a1 1 0 0 0-.804-.218l-4.135.689a1 1 0 0 0-.714.507l-5.297 9.712c-.233.427-.565.79-.97 1.06l-3.34 2.228a3 3 0 0 1-4.538-1.635l-3.775-12.58c-.26-.868-1.447-.97-1.852-.16l-2.969 5.937a3 3 0 0 1-3.632 1.505l-2.526-.842a1 1 0 0 0-1.252.597L7.606 38.564a5 5 0 0 1-3.1 2.988L.072 43.029Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z" fill="#2BEE6C"/><path d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" fill="#fff"/><path d="M45 .283v59.654c-.63.042-1.294.074-2 .098V.185c.706.025 1.37.056 2 .098Z" fill="#fff"/><path class="help-img-highlight" d="M.5 25.01c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.289a14.5 14.5 0 0 1 5.412-5.41c1.639-.936 3.579-1.418 6.289-1.661C16.822.61 20.265.61 24.9.61h10.2c4.635 0 8.078 0 10.795.245 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.579 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.795-.244 2.71-.726 4.65-1.66 6.29a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.412C1.47 50.655.988 48.716.745 46.005.5 43.288.5 39.845.5 35.21v-10.2Z"/></g><defs><clipPath id="l"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, HELP_KEY_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#m)"><path fill="#EB8B47" d="M0 24.9c0-9.252 0-13.878 1.97-17.332A15 15 0 0 1 7.569 1.97C11.023 0 15.648 0 24.9 0h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.022 60 15.648 60 24.899v10.2c0 9.252 0 13.878-1.97 17.332a15.001 15.001 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.351 0 35.1V24.9Z"/><path class="help-img-highlight" d="M.5 24.9c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.29a14.5 14.5 0 0 1 5.412-5.41C9.455 1.468 11.395.986 14.105.743 16.822.5 20.265.5 24.9.5h10.2c4.635 0 8.078 0 10.795.244 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.58 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.796-.244 2.71-.726 4.65-1.66 6.289a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.411c-.935-1.64-1.417-3.58-1.66-6.29C.5 43.178.5 39.734.5 35.1V24.9Z"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M39.192 29.192c5.077-5.077 5.077-13.308 0-18.385-5.076-5.077-13.308-5.077-18.384 0-5.077 5.077-5.077 13.308 0 18.385l1.287 1.291c1.137 1.142 1.706 1.712 2.097 2.387.267.462.472.957.608 1.473.2.755.2 1.56.2 3.171V48.75c0 1.077 0 1.615.134 2.119a4 4 0 0 0 .407.984c.262.45.643.831 1.404 1.592l.294.295c.654.654.982.981 1.365 1.086.26.07.533.07.792 0 .383-.105.71-.432 1.365-1.086l3.478-3.479c.655-.654.982-.981 1.087-1.365a1.5 1.5 0 0 0 0-.791c-.105-.384-.432-.711-1.087-1.365l-.478-.479c-.655-.654-.982-.981-1.087-1.365a1.5 1.5 0 0 1 0-.791c.105-.384.432-.711 1.087-1.365l.478-.479c.655-.654.982-.981 1.087-1.365a1.5 1.5 0 0 0 0-.791c-.105-.384-.432-.711-1.087-1.365l-.492-.493c-.65-.65-.974-.974-1.08-1.355a1.5 1.5 0 0 1-.003-.788c.102-.382.425-.71 1.069-1.364l5.46-5.547Z"/><circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/></g><defs><clipPath id="m"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, HELP_USER_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#n)"><rect width="60" height="60" fill="#00ACE6" rx="30"/><path fill="#1AC6FF" stroke="#fff" stroke-width="2" d="M59 73c0 16.016-12.984 29-29 29S1 89.016 1 73c0-16.017 11-29 29-29s29 12.983 29 29ZM18.69 19.902a11 11 0 0 1 9.281-8.692 14.842 14.842 0 0 1 4.058 0 11 11 0 0 1 9.28 8.692c.178.866.322 1.75.44 2.625.132.977.132 1.968 0 2.945a39.467 39.467 0 0 1-.44 2.625 11 11 0 0 1-9.28 8.692 14.862 14.862 0 0 1-4.058 0 11 11 0 0 1-9.28-8.692 39.467 39.467 0 0 1-.44-2.625 11.004 11.004 0 0 1 0-2.945c.118-.876.262-1.759.44-2.625Z"/><circle cx="24.5" cy="23.5" r="1.5" fill="#fff"/><circle cx="35.5" cy="23.5" r="1.5" fill="#fff"/><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m31 20-3 8h4"/></g><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="29.5"/><defs><clipPath id="n"><rect width="60" height="60" fill="#fff" rx="30"/></clipPath></defs></svg>`, HELP_LOCK_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#C653C6" rx="3"/><path fill="#fff" d="M20.034 15.216C20 15.607 20 16.07 20 17v2.808c0 1.13 0 1.696-.2 2.11a1.78 1.78 0 0 1-.584.714c-.366.28-1.051.42-2.423.7a7.076 7.076 0 0 0-1.597.511 9.001 9.001 0 0 0-4.353 4.353C10 30.005 10 32.336 10 37c0 4.663 0 6.995.843 8.804a9.001 9.001 0 0 0 4.353 4.353C17.005 51 19.336 51 24 51h12c4.663 0 6.995 0 8.804-.843a9.001 9.001 0 0 0 4.353-4.353C50 43.995 50 41.664 50 37c0-4.663 0-6.995-.843-8.804a9.001 9.001 0 0 0-4.353-4.353 7.076 7.076 0 0 0-1.597-.511c-1.372-.28-2.057-.42-2.423-.7a1.78 1.78 0 0 1-.583-.715C40 21.505 40 20.94 40 19.809V17c0-.929 0-1.393-.034-1.784a9 9 0 0 0-8.182-8.182C31.393 7 30.93 7 30 7s-1.393 0-1.784.034a9 9 0 0 0-8.182 8.182Z"/><path fill="#E87DE8" d="M22 17c0-.929 0-1.393.044-1.784a7 7 0 0 1 6.172-6.172C28.606 9 29.071 9 30 9s1.393 0 1.784.044a7 7 0 0 1 6.172 6.172c.044.39.044.855.044 1.784v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.394-.077-1.78a4 4 0 0 0-3.143-3.143C31.394 12 30.93 12 30 12s-1.394 0-1.78.077a4 4 0 0 0-3.143 3.143C25 15.606 25 16.07 25 17v4.5a1.5 1.5 0 0 1-3 0V17Z"/><path fill="#E87DE8" fill-rule="evenodd" d="M12 36.62c0-4.317 0-6.476.92-8.088a7 7 0 0 1 2.612-2.612c1.612-.92 3.77-.92 8.088-.92h6.855c.469 0 .703 0 .906.017 2.73.222 4.364 2.438 4.619 4.983.27-2.698 2.111-5 5.015-5A6.985 6.985 0 0 1 48 31.985v5.395c0 4.317 0 6.476-.92 8.088a7 7 0 0 1-2.612 2.612c-1.612.92-3.77.92-8.088.92h-5.855c-.469 0-.703 0-.906-.017-2.73-.222-4.364-2.438-4.619-4.983-.258 2.583-1.943 4.818-4.714 4.99-.155.01-.335.01-.694.01-.55 0-.825 0-1.057-.015a7 7 0 0 1-6.52-6.52C12 42.233 12 41.958 12 41.408V36.62Zm21.24-.273a4 4 0 1 0-6.478 0c.985 1.36 1.479 2.039 1.564 2.229.178.398.176.818.174 1.247V42.5a1.5 1.5 0 0 0 3 0v-2.677c-.002-.429-.004-.85.174-1.247.085-.19.579-.87 1.565-2.229Z" clip-rule="evenodd"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="2.5"/></svg>`, HELP_COMPAS_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#1DC956" rx="30"/><circle cx="30" cy="29.999" r="3" fill="#fff"/><path fill="#2BEE6C" stroke="#fff" stroke-width="2" d="m45.316 17.9-.88-.425.88.424a7.9 7.9 0 0 1 .026-.053c.093-.192.21-.432.26-.687l-.819-.162.819.162a2 2 0 0 0-.239-1.405c-.132-.224-.32-.412-.472-.562a8.415 8.415 0 0 1-.042-.042l-.042-.042c-.15-.151-.338-.34-.562-.472l-.508.862.508-.862a2 2 0 0 0-1.405-.239c-.255.05-.495.167-.687.26l-.053.026-15.05 7.246-.108.052c-1.131.545-1.843.887-2.456 1.374a6.994 6.994 0 0 0-1.13 1.13c-.487.613-.83 1.325-1.375 2.457l-.051.108-7.247 15.05-.025.053c-.094.192-.21.431-.26.686a2 2 0 0 0 .239 1.406l.855-.505-.856.505c.133.224.321.411.473.562l.042.042.041.042c.15.151.338.34.563.472a2 2 0 0 0 1.405.239l-.195-.981.195.98c.255-.05.494-.166.686-.26l.054-.025-.419-.87.419.87 15.05-7.247.107-.051c1.132-.545 1.844-.888 2.457-1.374a7.002 7.002 0 0 0 1.13-1.13c.487-.614.83-1.325 1.374-2.457l.052-.108 7.246-15.05Z"/><path fill="#1DC956" d="m33.376 32.723-2.669-3.43-14.85 14.849.206.205a1 1 0 0 0 1.141.194l15.105-7.273a3 3 0 0 0 1.067-4.545Z"/><path fill="#86F999" d="m26.624 27.276 2.669 3.43 14.85-14.849-.206-.205a1 1 0 0 0-1.141-.194L27.69 22.731a3 3 0 0 0-1.067 4.545Z"/><circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="29.5"/></svg>`, HELP_NOUN_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#794CFF" rx="3"/><path fill="#987DE8" stroke="#fff" stroke-width="2" d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"/><path fill="#fff" d="M37.5 25h10v10h-10z"/><path fill="#4019B2" d="M42.5 25h5v10h-5z"/><path fill="#fff" d="M19.5 25h10v10h-10z"/><path fill="#4019B2" d="M24.5 25h5v10h-5z"/><path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="2.5"/></svg>`, HELP_DAO_IMG: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#o)"><path fill="#EB8B47" d="M0 24.9c0-9.252 0-13.878 1.97-17.332A15 15 0 0 1 7.569 1.97C11.023 0 15.648 0 24.9 0h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.022 60 15.648 60 24.899v10.2c0 9.252 0 13.878-1.97 17.332a15.001 15.001 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.351 0 35.1V24.9Z"/><path class="help-img-highlight" d="M.5 24.9c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.29a14.5 14.5 0 0 1 5.412-5.41C9.455 1.468 11.395.986 14.105.743 16.822.5 20.265.5 24.9.5h10.2c4.635 0 8.078 0 10.795.244 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.58 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.796-.244 2.71-.726 4.65-1.66 6.289a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.411c-.935-1.64-1.417-3.58-1.66-6.29C.5 43.178.5 39.734.5 35.1V24.9Z"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M19 52c5.523 0 10-4.477 10-10s-4.477-10-10-10S9 36.477 9 42s4.477 10 10 10Z"/><path fill="#fff" fill-rule="evenodd" d="M42.844 8.326a1 1 0 0 0-1.687 0L28.978 27.463A1 1 0 0 0 29.822 29h24.357a1 1 0 0 0 .843-1.537L42.844 8.326Z" clip-rule="evenodd"/><path fill="#FF974C" fill-rule="evenodd" d="M42.335 11.646c.324.115.571.504 1.066 1.28l7.332 11.523c.562.883.843 1.325.792 1.69a1 1 0 0 1-.342.623c-.28.238-.803.238-1.85.238H34.667c-1.047 0-1.57 0-1.85-.238a1 1 0 0 1-.342-.623c-.051-.365.23-.806.792-1.69l7.332-11.523c.495-.776.742-1.165 1.066-1.28a1 1 0 0 1 .67 0ZM35 27a7 7 0 0 0 7-7 7 7 0 0 0 7 7H35Z" clip-rule="evenodd"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M10.106 9.357c-.109.32-.107.682-.106.975V25.668c-.001.293-.003.654.106.975a2 2 0 0 0 1.251 1.25c.32.11.682.108.975.107H19c5.523 0 10-4.477 10-10S24.523 8 19 8h-6.668c-.293-.001-.654-.003-.975.106a2 2 0 0 0-1.25 1.251Z"/><circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/><circle cx="19" cy="41.999" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/></g><defs><clipPath id="o"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, SEARCH_ICON: b5`<svg width="20" height="21"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.432 13.992c-.354-.353-.91-.382-1.35-.146a5.5 5.5 0 1 1 2.265-2.265c-.237.441-.208.997.145 1.35l3.296 3.296a.75.75 0 1 1-1.06 1.061l-3.296-3.296Zm.06-5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" fill="#949E9E"/></svg>`, HELP_ICON: b5`<svg width="11" height="17" viewBox="0 0 11 17"><path fill="#fff" d="M5.22 2.97c-1.07 0-2.25.843-2.25 2.25a.75.75 0 0 1-1.5 0c0-2.393 2.019-3.75 3.75-3.75 1.73 0 3.75 1.357 3.75 3.75 0 1.64-1.038 2.466-1.785 3.057-.802.635-1.215.984-1.215 1.693a.75.75 0 1 1-1.5 0c0-1.466.985-2.24 1.681-2.788l.103-.081C7.007 6.504 7.47 6.08 7.47 5.22c0-1.407-1.181-2.25-2.25-2.25ZM5.22 14.97a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"/></svg>`, WALLET_ICON: b5`<svg width="15" height="14" fill="none" viewBox="0 0 15 14"><path fill="#fff" fill-rule="evenodd" d="M.64 9.2v-3h.001c.009-1.857.07-2.886.525-3.682a4 4 0 0 1 1.492-1.493C3.58.5 4.813.5 7.28.5h3.735c.58 0 .871 0 1.114.04A3 3 0 0 1 14.6 3.011c.04.243.04.533.04 1.114 0 .58 0 .871-.04 1.114a3 3 0 0 1-2.471 2.47c-.243.041-.533.041-1.114.041h-.777c.178.307.302.648.362 1.011.04.243.04.533.04 1.114 0 .58 0 .871-.04 1.114a3 3 0 0 1-2.471 2.47c-.243.041-.533.041-1.114.041H4.507A3.867 3.867 0 0 1 .64 9.633V9.2ZM7.28 2h3.735c.64 0 .779.005.87.02a1.5 1.5 0 0 1 1.235 1.236c.015.09.02.229.02.869s-.005.779-.02.87a1.5 1.5 0 0 1-1.236 1.235c-.09.015-.229.02-.869.02H4.023c-.697 0-1.345.21-1.883.572V6.25h.001c.004-.791.015-1.383.059-1.867.056-.629.157-.926.269-1.122a2.5 2.5 0 0 1 .932-.933c.197-.111.494-.212 1.123-.268C5.173 2 6.019 2 7.28 2Zm-.265 5.75H4.023c-1.04 0-1.883.843-1.883 1.883A2.367 2.367 0 0 0 4.507 12h2.508c.64 0 .779-.005.87-.02a1.5 1.5 0 0 0 1.235-1.236c.015-.09.02-.229.02-.869s-.005-.779-.02-.87A1.5 1.5 0 0 0 7.884 7.77c-.09-.015-.228-.02-.869-.02Z" clip-rule="evenodd"/></svg>`, NETWORK_PLACEHOLDER: b5`<svg width="28" height="28" fill="none" viewBox="0 0 28 28"><mask id="p" width="26" height="28" x="1" y="0" maskUnits="userSpaceOnUse" style="mask-type:alpha"><path fill="#D9D9D9" d="M12 1.172a4 4 0 0 1 4 0l8.124 4.69a4 4 0 0 1 2 3.465v9.381a4 4 0 0 1-2 3.464L16 26.862a4 4 0 0 1-4 0l-8.124-4.69a4 4 0 0 1-2-3.464V9.327a4 4 0 0 1 2-3.464L12 1.173Z"/></mask><g mask="url(#p)"><path id="network-placeholder-fill" fill="#fff" d="M0 0h28v28H0z"/><path id="network-placeholder-dash" stroke="#000" stroke-dasharray="2 2" d="m8.953 2.931 2.032-1.173.25.433 1.015-.586c.269-.155.553-.271.844-.35l-.13-.483a4.003 4.003 0 0 1 2.071 0l-.13.483c.293.079.576.195.845.35l1.016.586.25-.433 2.03 1.173-.25.433 2.032 1.173.25-.433 2.03 1.172-.25.433 1.016.587c.269.155.512.342.725.556l.354-.354a4.003 4.003 0 0 1 1.035 1.794l-.483.129c.078.292.12.596.12.906v1.172h.5v2.346h-.5v2.345h.5v2.345h-.5v1.173c0 .31-.042.614-.12.906l.483.13a4.003 4.003 0 0 1-1.035 1.793l-.354-.354a3.498 3.498 0 0 1-.725.556l-1.015.586.25.434-2.031 1.172-.25-.433-2.031 1.173.25.433-2.031 1.172-.25-.433-1.016.587a3.494 3.494 0 0 1-.844.35l.13.482a4.003 4.003 0 0 1-2.071 0l.13-.483a3.496 3.496 0 0 1-.845-.35l-1.015-.586-.25.433-2.032-1.172.25-.433-2.03-1.173-.25.433L4.89 22.76l.25-.434-1.015-.586a3.498 3.498 0 0 1-.725-.556l-.354.354a4.003 4.003 0 0 1-1.035-1.794l.483-.13a3.497 3.497 0 0 1-.12-.905v-1.173h-.5V15.19h.5v-2.345h-.5v-2.346h.5V9.327c0-.31.042-.614.12-.906l-.483-.13a4.003 4.003 0 0 1 1.035-1.793l.354.354c.213-.214.456-.401.725-.556l1.015-.587-.25-.433 2.031-1.172.25.433 2.031-1.173-.25-.433Z"/><path fill="#798686" stroke="#fff" d="M14.243 13.563 14 13.428l-.243.135-6.388 3.549-.024.013c-.432.24-.79.44-1.053.622-.266.184-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.317.37.538.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722l-.468-.177.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.317-.37-.538-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-6.388-3.55Z"/><path fill="#9EA9A9" stroke="#fff" d="M14.243 8.563 14 8.428l-.243.135-6.388 3.549-.024.013c-.432.24-.79.44-1.053.622-.266.184-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.316.37.537.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722l-.468-.177.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.316-.37-.537-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-6.388-3.55Z"/><path fill="#C9CFCF" stroke="#fff" d="m22.344 9.53-.468-.176.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.317-.37-.537-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-3.163-1.758-.09-.05c-1.163-.645-1.856-1.03-2.606-1.161a4.5 4.5 0 0 0-1.544 0c-.75.13-1.443.516-2.607 1.162l-.088.05-3.164 1.757-.024.013c-.432.24-.79.44-1.053.622-.266.185-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.317.37.537.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722Z"/></g></svg>`, WALLET_PLACEHOLDER: b5`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#q)"><path id="wallet-placeholder-fill" fill="#fff" d="M0 24.9c0-9.251 0-13.877 1.97-17.332a15 15 0 0 1 5.598-5.597C11.023 0 15.648 0 24.9 0h10.2c9.252 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.023 60 15.648 60 24.9v10.2c0 9.252 0 13.877-1.97 17.332a15.001 15.001 0 0 1-5.598 5.597C48.977 60 44.352 60 35.1 60H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.352 0 35.1V24.9Z"/><path id="wallet-placeholder-dash" stroke="#000" stroke-dasharray="4 4" stroke-width="1.5" d="M.04 41.708a231.598 231.598 0 0 1-.039-4.403l.75-.001L.75 35.1v-2.55H0v-5.1h.75V24.9l.001-2.204h-.75c.003-1.617.011-3.077.039-4.404l.75.016c.034-1.65.099-3.08.218-4.343l-.746-.07c.158-1.678.412-3.083.82-4.316l.713.236c.224-.679.497-1.296.827-1.875a14.25 14.25 0 0 1 1.05-1.585L3.076 5.9A15 15 0 0 1 5.9 3.076l.455.596a14.25 14.25 0 0 1 1.585-1.05c.579-.33 1.196-.603 1.875-.827l-.236-.712C10.812.674 12.217.42 13.895.262l.07.746C15.23.89 16.66.824 18.308.79l-.016-.75C19.62.012 21.08.004 22.695.001l.001.75L24.9.75h2.55V0h5.1v.75h2.55l2.204.001v-.75c1.617.003 3.077.011 4.404.039l-.016.75c1.65.034 3.08.099 4.343.218l.07-.746c1.678.158 3.083.412 4.316.82l-.236.713c.679.224 1.296.497 1.875.827a14.24 14.24 0 0 1 1.585 1.05l.455-.596A14.999 14.999 0 0 1 56.924 5.9l-.596.455c.384.502.735 1.032 1.05 1.585.33.579.602 1.196.827 1.875l.712-.236c.409 1.233.663 2.638.822 4.316l-.747.07c.119 1.264.184 2.694.218 4.343l.75-.016c.028 1.327.036 2.787.039 4.403l-.75.001.001 2.204v2.55H60v5.1h-.75v2.55l-.001 2.204h.75a231.431 231.431 0 0 1-.039 4.404l-.75-.016c-.034 1.65-.099 3.08-.218 4.343l.747.07c-.159 1.678-.413 3.083-.822 4.316l-.712-.236a10.255 10.255 0 0 1-.827 1.875 14.242 14.242 0 0 1-1.05 1.585l.596.455a14.997 14.997 0 0 1-2.824 2.824l-.455-.596c-.502.384-1.032.735-1.585 1.05-.579.33-1.196.602-1.875.827l.236.712c-1.233.409-2.638.663-4.316.822l-.07-.747c-1.264.119-2.694.184-4.343.218l.016.75c-1.327.028-2.787.036-4.403.039l-.001-.75-2.204.001h-2.55V60h-5.1v-.75H24.9l-2.204-.001v.75a231.431 231.431 0 0 1-4.404-.039l.016-.75c-1.65-.034-3.08-.099-4.343-.218l-.07.747c-1.678-.159-3.083-.413-4.316-.822l.236-.712a10.258 10.258 0 0 1-1.875-.827 14.252 14.252 0 0 1-1.585-1.05l-.455.596A14.999 14.999 0 0 1 3.076 54.1l.596-.455a14.24 14.24 0 0 1-1.05-1.585 10.259 10.259 0 0 1-.827-1.875l-.712.236C.674 49.188.42 47.783.262 46.105l.746-.07C.89 44.77.824 43.34.79 41.692l-.75.016Z"/><path fill="#fff" fill-rule="evenodd" d="M35.643 32.145c-.297-.743-.445-1.114-.401-1.275a.42.42 0 0 1 .182-.27c.134-.1.463-.1 1.123-.1.742 0 1.499.046 2.236-.05a6 6 0 0 0 5.166-5.166c.051-.39.051-.855.051-1.784 0-.928 0-1.393-.051-1.783a6 6 0 0 0-5.166-5.165c-.39-.052-.854-.052-1.783-.052h-7.72c-4.934 0-7.401 0-9.244 1.051a8 8 0 0 0-2.985 2.986C16.057 22.28 16.003 24.58 16 29 15.998 31.075 16 33.15 16 35.224A7.778 7.778 0 0 0 23.778 43H28.5c1.394 0 2.09 0 2.67-.116a6 6 0 0 0 4.715-4.714c.115-.58.115-1.301.115-2.744 0-1.31 0-1.964-.114-2.49a4.998 4.998 0 0 0-.243-.792Z" clip-rule="evenodd"/><path fill="#9EA9A9" fill-rule="evenodd" d="M37 18h-7.72c-2.494 0-4.266.002-5.647.126-1.361.122-2.197.354-2.854.728a6.5 6.5 0 0 0-2.425 2.426c-.375.657-.607 1.492-.729 2.853-.11 1.233-.123 2.777-.125 4.867 0 .7 0 1.05.097 1.181.096.13.182.181.343.2.163.02.518-.18 1.229-.581a6.195 6.195 0 0 1 3.053-.8H37c.977 0 1.32-.003 1.587-.038a4.5 4.5 0 0 0 3.874-3.874c.036-.268.039-.611.039-1.588 0-.976-.003-1.319-.038-1.587a4.5 4.5 0 0 0-3.875-3.874C38.32 18.004 37.977 18 37 18Zm-7.364 12.5h-7.414a4.722 4.722 0 0 0-4.722 4.723 6.278 6.278 0 0 0 6.278 6.278H28.5c1.466 0 1.98-.008 2.378-.087a4.5 4.5 0 0 0 3.535-3.536c.08-.397.087-.933.087-2.451 0-1.391-.009-1.843-.08-2.17a3.5 3.5 0 0 0-2.676-2.676c-.328-.072-.762-.08-2.108-.08Z" clip-rule="evenodd"/></g><defs><clipPath id="q"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, TOKEN_PLACEHOLDER: b5`<svg width="60" height="60" viewBox="0 0 60 60" fill="none"><rect id="token-placeholder-fill" width="58" height="58" x="1" y="1" fill="#fff" rx="29"/><path fill="#3B4040" stroke="#fff" stroke-width="2" d="M32 10a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v5.566c0 .357.192.685.495.875a16.001 16.001 0 0 1 4.256 3.894c.667.88.33 2.113-.627 2.665l-2.494 1.44c-.956.552-2.166.204-2.913-.609a9.12 9.12 0 1 0 .064 12.267c.739-.82 1.945-1.181 2.907-.64l2.509 1.415c.962.542 1.312 1.77.654 2.658a16 16 0 0 1-4.356 4.028c-.303.19-.495.518-.495.875V50a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-2.992c0-.602-.528-1.065-1.13-1.032-.579.032-1.16.032-1.74 0-.602-.032-1.13.43-1.13 1.032V50a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-5.566c0-.357-.192-.685-.495-.875a16 16 0 0 1 0-27.118c.303-.19.495-.517.495-.875V10a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2.992c0 .601.528 1.064 1.13 1.032.58-.032 1.161-.032 1.74 0 .602.033 1.13-.43 1.13-1.032V10Z"/><rect id="token-placeholder-dash" width="58" height="58" x="1" y="1" stroke="#000" stroke-dasharray="6 6" stroke-width="2" rx="29"/></svg>`, ACCOUNT_COPY: b5`<svg width="14" height="14" fill="none" viewBox="0 0 14 14"><path fill="#fff" fill-rule="evenodd" d="M4.003 4.005c.012-1.225.074-1.936.391-2.491a3 3 0 0 1 1.12-1.12C6.204 0 7.136 0 9 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C14 2.204 14 3.136 14 5s0 2.795-.394 3.486a3 3 0 0 1-1.12 1.12c-.555.317-1.266.379-2.491.391l.002.003c-.012 1.222-.075 1.932-.391 2.486a3 3 0 0 1-1.12 1.12C7.796 14 6.864 14 5 14s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C0 11.796 0 10.864 0 9s0-2.795.394-3.486a3 3 0 0 1 1.12-1.12c.554-.316 1.264-.379 2.486-.391l.003.002ZM9 8.5c-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.045-.08-.113-.243-.154-.693C5.501 6.58 5.5 5.959 5.5 5c0-.959.001-1.58.043-2.05.04-.45.109-.613.154-.693a1.5 1.5 0 0 1 .56-.56c.08-.045.243-.113.693-.154C7.42 1.501 8.041 1.5 9 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.045.08.113.243.154.693.042.47.043 1.091.043 2.05 0 .959-.001 1.58-.043 2.05-.04.45-.109.613-.154.693a1.5 1.5 0 0 1-.56.56c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043ZM4 5.503a13.77 13.77 0 0 0-1.05.04c-.45.04-.613.109-.693.154a1.5 1.5 0 0 0-.56.56c-.045.08-.113.243-.154.693C1.501 7.42 1.5 8.041 1.5 9c0 .959.001 1.58.043 2.05.04.45.109.613.154.693a1.5 1.5 0 0 0 .56.56c.08.045.243.113.693.154.47.042 1.091.043 2.05.043.959 0 1.58-.001 2.05-.043.45-.04.613-.109.693-.154a1.5 1.5 0 0 0 .56-.56c.045-.08.113-.242.154-.693.025-.283.035-.619.04-1.05-1.534-.003-2.358-.037-2.983-.394a3 3 0 0 1-1.12-1.12c-.357-.625-.39-1.449-.394-2.983Z" clip-rule="evenodd"/></svg>`, ACCOUNT_DISCONNECT: b5`<svg width="16" height="14" fill="none" viewBox="0 0 16 14"><path fill="#fff" d="M9.677 1.5h-2.61c-1.261 0-2.107.001-2.757.06-.629.056-.926.157-1.122.268a2.5 2.5 0 0 0-.933.933c-.112.196-.212.493-.269 1.122-.058.65-.06 1.496-.06 2.757v.72c0 1.26.002 2.107.06 2.756.057.63.157.927.27 1.123a2.5 2.5 0 0 0 .932.933c.196.111.493.212 1.122.268.65.059 1.496.06 2.757.06h2.61a.75.75 0 1 1 0 1.5h-2.61c-2.467 0-3.7 0-4.622-.525a4 4 0 0 1-1.493-1.493C.427 11.06.427 9.827.427 7.36v-.72c0-2.467 0-3.7.525-4.622A4 4 0 0 1 2.445.525C3.366 0 4.6 0 7.067 0h2.61a.75.75 0 1 1 0 1.5Z"/><path fill="#fff" d="M10.896 11.03a.75.75 0 0 1 0-1.06l1.793-1.793a.25.25 0 0 0-.176-.427H8.177a.75.75 0 0 1 0-1.5h4.336a.25.25 0 0 0 .176-.427L10.896 4.03a.75.75 0 0 1 1.061-1.06l3.323 3.323a1 1 0 0 1 0 1.414l-3.323 3.323a.75.75 0 0 1-1.06 0Z"/></svg>` };
    Ft = i3`.w3m-custom-placeholder{inset:0;width:100%;position:absolute;display:block;pointer-events:none;height:100px;border-radius:calc(var(--w3m-background-border-radius) * .9)}.w3m-custom-placeholder{background-color:var(--w3m-background-color);background-image:var(--w3m-background-image-url);background-position:center;background-size:cover}.w3m-toolbar{height:38px;display:flex;position:relative;margin:5px 15px 5px 5px;justify-content:space-between;align-items:center}.w3m-toolbar img,.w3m-toolbar svg{height:28px;object-position:left center;object-fit:contain}#w3m-wc-logo path{fill:var(--w3m-accent-fill-color)}.w3m-action-btn{width:28px;height:28px;border-radius:var(--w3m-icon-button-border-radius);border:0;display:flex;justify-content:center;align-items:center;cursor:pointer;transition:background-color,.2s ease;background-color:var(--w3m-color-bg-1);box-shadow:0 0 0 1px var(--w3m-color-overlay)}.w3m-action-btn:hover{background-color:var(--w3m-color-bg-2)}.w3m-action-btn svg{display:block;object-position:center}.w3m-action-btn path{fill:var(--w3m-color-fg-1)}.w3m-actions{display:flex}.w3m-actions button:first-child{margin-right:16px}.w3m-help-active button:first-child{background-color:var(--w3m-color-fg-1)}.w3m-help-active button:first-child path{fill:var(--w3m-color-bg-1)}`;
    Kt = Object.defineProperty;
    qt = Object.getOwnPropertyDescriptor;
    ut3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? qt(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Kt(t8, o11, a9), a9;
    };
    Ie3 = class extends s6 {
      constructor() {
        super(), this.isHelp = false, this.unsubscribeRouter = void 0, this.unsubscribeRouter = g4.subscribe((e11) => {
          this.isHelp = e11.view === "Help";
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeRouter) == null || e11.call(this);
      }
      onHelp() {
        g4.push("Help");
      }
      logoTemplate() {
        var e11;
        const t8 = (e11 = B3.state.themeVariables) == null ? void 0 : e11["--w3m-logo-image-url"];
        return t8 ? x4`<img src="${t8}">` : p5.WALLET_CONNECT_LOGO;
      }
      render() {
        const e11 = { "w3m-actions": true, "w3m-help-active": this.isHelp };
        return x4`<div class="w3m-custom-placeholder"></div><div class="w3m-toolbar">${this.logoTemplate()}<div class="${o8(e11)}"><button class="w3m-action-btn" @click="${this.onHelp}">${p5.HELP_ICON}</button> <button class="w3m-action-btn" @click="${x3.close}">${p5.CROSS_ICON}</button></div></div>`;
      }
    };
    Ie3.styles = [m5.globalCss, Ft], ut3([t4()], Ie3.prototype, "isHelp", 2), Ie3 = ut3([e5("w3m-modal-backcard")], Ie3);
    Qt = i3`main{padding:20px;padding-top:0;width:100%}`;
    Yt = Object.defineProperty;
    Xt = Object.getOwnPropertyDescriptor;
    Jt = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Xt(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Yt(t8, o11, a9), a9;
    };
    He4 = class extends s6 {
      render() {
        return x4`<main><slot></slot></main>`;
      }
    };
    He4.styles = [m5.globalCss, Qt], He4 = Jt([e5("w3m-modal-content")], He4);
    ea = i3`footer{padding:10px;display:flex;flex-direction:column;align-items:inherit;justify-content:inherit;border-top:1px solid var(--w3m-color-bg-2)}`;
    ta = Object.defineProperty;
    aa = Object.getOwnPropertyDescriptor;
    oa = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? aa(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && ta(t8, o11, a9), a9;
    };
    Se3 = class extends s6 {
      render() {
        return x4`<footer><slot></slot></footer>`;
      }
    };
    Se3.styles = [m5.globalCss, ea], Se3 = oa([e5("w3m-modal-footer")], Se3);
    ra = i3`header{display:flex;justify-content:center;align-items:center;padding:20px;position:relative}.w3m-border{border-bottom:1px solid var(--w3m-color-bg-2);margin-bottom:20px}header button{padding:15px 20px;transition:opacity .2s ease}@media(hover:hover){header button:hover{opacity:.5}}.w3m-back-btn{position:absolute;left:0}.w3m-action-btn{position:absolute;right:0}path{fill:var(--w3m-accent-color)}`;
    la = Object.defineProperty;
    na = Object.getOwnPropertyDescriptor;
    me3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? na(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && la(t8, o11, a9), a9;
    };
    F4 = class extends s6 {
      constructor() {
        super(...arguments), this.title = "", this.onAction = void 0, this.actionIcon = void 0, this.border = false;
      }
      backBtnTemplate() {
        return x4`<button class="w3m-back-btn" @click="${g4.goBack}">${p5.BACK_ICON}</button>`;
      }
      actionBtnTemplate() {
        return x4`<button class="w3m-action-btn" @click="${this.onAction}">${this.actionIcon}</button>`;
      }
      render() {
        const e11 = { "w3m-border": this.border }, t8 = g4.state.history.length > 1, o11 = this.title ? x4`<w3m-text variant="big-bold">${this.title}</w3m-text>` : x4`<slot></slot>`;
        return x4`<header class="${o8(e11)}">${t8 ? this.backBtnTemplate() : null} ${o11} ${this.onAction ? this.actionBtnTemplate() : null}</header>`;
      }
    };
    F4.styles = [m5.globalCss, ra], me3([e6()], F4.prototype, "title", 2), me3([e6()], F4.prototype, "onAction", 2), me3([e6()], F4.prototype, "actionIcon", 2), me3([e6()], F4.prototype, "border", 2), F4 = me3([e5("w3m-modal-header")], F4);
    ia = { 1: "692ed6ba-e569-459a-556a-776476829e00", 42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200", 43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00", 56: "93564157-2e8e-4ce7-81df-b264dbee9b00", 250: "06b26297-fe0c-4733-5d6b-ffa5498aac00", 10: "ab9c186a-c52f-464b-2906-ca59d760a400", 137: "41d04d42-da3b-4453-8506-668cc0727900", 100: "02b53f6a-e3d4-479e-1cb4-21178987d100", 9001: "f926ff41-260d-4028-635e-91913fc28e00", 324: "b310f07f-4ef7-49f3-7073-2a0a39685800", 314: "5a73b3dd-af74-424e-cae0-0de859ee9400", 4689: "34e68754-e536-40da-c153-6ef2e7188a00", 1088: "3897a66d-40b9-4833-162f-a2c90531c900", 1284: "161038da-44ae-4ec7-1208-0ea569454b00", 1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00" };
    ie4 = ((e11) => (e11.metaMask = "metaMask", e11.trust = "trust", e11.phantom = "phantom", e11.brave = "brave", e11.spotEthWallet = "spotEthWallet", e11.exodus = "exodus", e11.tokenPocket = "tokenPocket", e11.frame = "frame", e11.tally = "tally", e11.coinbaseWallet = "coinbaseWallet", e11.core = "core", e11.bitkeep = "bitkeep", e11.mathWallet = "mathWallet", e11.opera = "opera", e11.tokenary = "tokenary", e11["1inch"] = "1inch", e11.kuCoinWallet = "kuCoinWallet", e11.ledger = "ledger", e11))(ie4 || {});
    J4 = { injectedPreset: { metaMask: { name: "MetaMask", icon: "619537c0-2ff3-4c78-9ed8-a05e7567f300", url: "https://metamask.io", isMobile: true, isInjected: true }, trust: { name: "Trust", icon: "0528ee7e-16d1-4089-21e3-bbfb41933100", url: "https://trustwallet.com", isMobile: true, isInjected: true }, spotEthWallet: { name: "Spot", icon: "1bf33a89-b049-4a1c-d1f6-4dd7419ee400", url: "https://www.spot-wallet.com", isMobile: true, isInjected: true }, phantom: { name: "Phantom", icon: "62471a22-33cb-4e65-5b54-c3d9ea24b900", url: "https://phantom.app", isInjected: true }, core: { name: "Core", icon: "35f9c46e-cc57-4aa7-315d-e6ccb2a1d600", url: "https://core.app", isMobile: true, isInjected: true }, bitkeep: { name: "BitKeep", icon: "3f7075d0-4ab7-4db5-404d-3e4c05e6fe00", url: "https://bitkeep.com", isMobile: true, isInjected: true }, tokenPocket: { name: "TokenPocket", icon: "f3119826-4ef5-4d31-4789-d4ae5c18e400", url: "https://www.tokenpocket.pro", isMobile: true, isInjected: true }, mathWallet: { name: "MathWallet", icon: "26a8f588-3231-4411-60ce-5bb6b805a700", url: "https://mathwallet.org", isMobile: true, isInjected: true }, exodus: { name: "Exodus", icon: "4c16cad4-cac9-4643-6726-c696efaf5200", url: "https://www.exodus.com", isMobile: true, isDesktop: true, isInjected: true }, kuCoinWallet: { name: "KuCoin Wallet", icon: "1e47340b-8fd7-4ad6-17e7-b2bd651fae00", url: "https://kuwallet.com", isMobile: true, isInjected: true }, ledger: { name: "Ledger", icon: "a7f416de-aa03-4c5e-3280-ab49269aef00", url: "https://www.ledger.com", isDesktop: true }, brave: { name: "Brave", icon: "125e828e-9936-4451-a8f2-949c119b7400", url: "https://brave.com/wallet", isInjected: true }, frame: { name: "Frame", icon: "cd492418-ea85-4ef1-aeed-1c9e20b58900", url: "https://frame.sh", isInjected: true }, tally: { name: "Tally", icon: "98d2620c-9fc8-4a1c-31bc-78d59d00a300", url: "https://tallyho.org", isInjected: true }, coinbaseWallet: { name: "Coinbase", icon: "f8068a7f-83d7-4190-1f94-78154a12c600", url: "https://www.coinbase.com/wallet", isInjected: true }, opera: { name: "Opera", icon: "877fa1a4-304d-4d45-ca8e-f76d1a556f00", url: "https://www.opera.com/crypto", isInjected: true }, tokenary: { name: "Tokenary", icon: "5e481041-dc3c-4a81-373a-76bbde91b800", url: "https://tokenary.io", isDesktop: true, isInjected: true }, ["1inch"]: { name: "1inch Wallet", icon: "dce1ee99-403f-44a9-9f94-20de30616500", url: "https://1inch.io/wallet", isMobile: true } }, getInjectedId(e11) {
      if (e11.toUpperCase() !== "INJECTED" && e11.length)
        return e11;
      const { ethereum: t8, spotEthWallet: o11, coinbaseWalletExtension: r7 } = window;
      return t8 ? t8.isTrust || t8.isTrustWallet ? "trust" : t8.isPhantom ? "phantom" : t8.isBraveWallet ? "brave" : o11 ? "spotEthWallet" : t8.isExodus ? "exodus" : t8.isTokenPocket ? "tokenPocket" : t8.isFrame ? "frame" : t8.isTally ? "tally" : r7 ? "coinbaseWallet" : t8.isAvalanche ? "core" : t8.isBitKeep ? "bitkeep" : t8.isMathWallet ? "mathWallet" : t8.isOpera ? "opera" : t8.isTokenary ? "tokenary" : t8.isOneInchIOSWallet || t8.isOneInchAndroidWallet ? "1inch" : t8.isKuCoinWallet ? "kuCoinWallet" : t8.isMetaMask ? "metaMask" : "injected" : "metaMask";
    }, getInjectedName(e11) {
      var t8, o11;
      if (e11.length && e11.toUpperCase() !== "INJECTED")
        return e11;
      const r7 = J4.getInjectedId("");
      return (o11 = (t8 = J4.injectedPreset[r7]) == null ? void 0 : t8.name) != null ? o11 : "Injected";
    } };
    sa = { ETH: { icon: "692ed6ba-e569-459a-556a-776476829e00" }, WETH: { icon: "692ed6ba-e569-459a-556a-776476829e00" }, AVAX: { icon: "30c46e53-e989-45fb-4549-be3bd4eb3b00" }, FTM: { icon: "06b26297-fe0c-4733-5d6b-ffa5498aac00" }, BNB: { icon: "93564157-2e8e-4ce7-81df-b264dbee9b00" }, MATIC: { icon: "41d04d42-da3b-4453-8506-668cc0727900" }, OP: { icon: "ab9c186a-c52f-464b-2906-ca59d760a400" }, xDAI: { icon: "02b53f6a-e3d4-479e-1cb4-21178987d100" }, EVMOS: { icon: "f926ff41-260d-4028-635e-91913fc28e00" }, METIS: { icon: "3897a66d-40b9-4833-162f-a2c90531c900" }, IOTX: { icon: "34e68754-e536-40da-c153-6ef2e7188a00" } };
    ca = Object.defineProperty;
    gt3 = Object.getOwnPropertySymbols;
    da = Object.prototype.hasOwnProperty;
    ma = Object.prototype.propertyIsEnumerable;
    vt2 = (e11, t8, o11) => t8 in e11 ? ca(e11, t8, { enumerable: true, configurable: true, writable: true, value: o11 }) : e11[t8] = o11;
    ha = (e11, t8) => {
      for (var o11 in t8 || (t8 = {}))
        da.call(t8, o11) && vt2(e11, o11, t8[o11]);
      if (gt3)
        for (var o11 of gt3(t8))
          ma.call(t8, o11) && vt2(e11, o11, t8[o11]);
      return e11;
    };
    s7 = { MOBILE_BREAKPOINT: 600, W3M_RECENT_WALLET: "W3M_RECENT_WALLET", EXPLORER_WALLET_URL: "https://explorer.walletconnect.com/?type=wallet", rejectStandaloneButtonComponent() {
      const { isStandalone: e11 } = i2.state;
      if (e11)
        throw new Error("Web3Modal button components are not available in standalone mode.");
    }, getShadowRootElement(e11, t8) {
      const o11 = e11.renderRoot.querySelector(t8);
      if (!o11)
        throw new Error(`${t8} not found`);
      return o11;
    }, getWalletId(e11) {
      return J4.getInjectedId(e11);
    }, getWalletIcon(e11) {
      var t8, o11;
      const r7 = (t8 = J4.injectedPreset[e11]) == null ? void 0 : t8.icon, { projectId: a9, walletImages: n8 } = S2.state;
      return (o11 = n8?.[e11]) != null ? o11 : a9 && r7 ? _3.getImageUrl(r7) : "";
    }, getWalletName(e11, t8 = false) {
      const o11 = J4.getInjectedName(e11);
      return t8 ? o11.split(" ")[0] : o11;
    }, getChainIcon(e11) {
      var t8;
      const o11 = ia[e11], { projectId: r7, chainImages: a9 } = S2.state;
      return (t8 = a9?.[e11]) != null ? t8 : r7 && o11 ? _3.getImageUrl(o11) : "";
    }, getTokenIcon(e11) {
      var t8, o11;
      const r7 = (t8 = sa[e11]) == null ? void 0 : t8.icon, { projectId: a9, tokenImages: n8 } = S2.state;
      return (o11 = n8?.[e11]) != null ? o11 : a9 && r7 ? _3.getImageUrl(r7) : "";
    }, isMobileAnimation() {
      return window.innerWidth <= s7.MOBILE_BREAKPOINT;
    }, async preloadImage(e11) {
      const t8 = new Promise((o11, r7) => {
        const a9 = new Image();
        a9.onload = o11, a9.onerror = r7, a9.src = e11;
      });
      return Promise.race([t8, d2.wait(3e3)]);
    }, getErrorMessage(e11) {
      return e11 instanceof Error ? e11.message : "Unknown Error";
    }, debounce(e11, t8 = 500) {
      let o11;
      return (...r7) => {
        function a9() {
          e11(...r7);
        }
        o11 && clearTimeout(o11), o11 = setTimeout(a9, t8);
      };
    }, async handleMobileLinking(e11) {
      d2.removeWalletConnectDeepLink();
      const { standaloneUri: t8, selectedChain: o11 } = i2.state, { links: r7, name: a9 } = e11;
      function n8(l9) {
        let w11 = "";
        r7 != null && r7.universal ? w11 = d2.formatUniversalUrl(r7.universal, l9, a9) : r7 != null && r7.native && (w11 = d2.formatNativeUrl(r7.native, l9, a9)), d2.openHref(w11, "_self");
      }
      t8 ? (s7.setRecentWallet(e11), n8(t8)) : (await p3.client().connectWalletConnect((l9) => {
        n8(l9);
      }, o11?.id), s7.setRecentWallet(e11), x3.close());
    }, async handleAndroidLinking() {
      d2.removeWalletConnectDeepLink();
      const { standaloneUri: e11, selectedChain: t8 } = i2.state;
      e11 ? d2.openHref(e11, "_self") : (await p3.client().connectWalletConnect((o11) => {
        d2.setWalletConnectAndroidDeepLink(o11), d2.openHref(o11, "_self");
      }, t8?.id), x3.close());
    }, async handleUriCopy() {
      const { standaloneUri: e11 } = i2.state;
      if (e11)
        await navigator.clipboard.writeText(e11);
      else {
        const t8 = p3.client().walletConnectUri;
        await navigator.clipboard.writeText(t8);
      }
      H5.openToast("Link copied", "success");
    }, async handleConnectorConnection(e11, t8) {
      try {
        const { selectedChain: o11 } = i2.state;
        await p3.client().connectConnector(e11, o11?.id), x3.close();
      } catch (o11) {
        console.error(o11), t8 ? t8() : H5.openToast(s7.getErrorMessage(o11), "error");
      }
    }, getCustomWallets() {
      var e11;
      const { desktopWallets: t8, mobileWallets: o11 } = S2.state;
      return (e11 = d2.isMobile() ? o11 : t8) != null ? e11 : [];
    }, getCustomImageUrls() {
      const { chainImages: e11, walletImages: t8 } = S2.state, o11 = Object.values(e11 ?? {}), r7 = Object.values(t8 ?? {});
      return Object.values([...o11, ...r7]);
    }, getConnectorImageUrls() {
      return p3.client().getConnectors().map(({ id: e11 }) => J4.getInjectedId(e11)).map((e11) => s7.getWalletIcon(e11));
    }, truncate(e11, t8 = 8) {
      return e11.length <= t8 ? e11 : `${e11.substring(0, 4)}...${e11.substring(e11.length - 4)}`;
    }, generateAvatarColors(e11) {
      var t8;
      const o11 = (t8 = e11.match(/.{1,7}/g)) == null ? void 0 : t8.splice(0, 5), r7 = [];
      o11?.forEach((n8) => {
        let l9 = 0;
        for (let g9 = 0; g9 < n8.length; g9 += 1)
          l9 = n8.charCodeAt(g9) + ((l9 << 5) - l9), l9 = l9 & l9;
        const w11 = [0, 0, 0];
        for (let g9 = 0; g9 < 3; g9 += 1) {
          const I9 = l9 >> g9 * 8 & 255;
          w11[g9] = I9;
        }
        r7.push(`rgb(${w11[0]}, ${w11[1]}, ${w11[2]})`);
      });
      const a9 = document.querySelector(":root");
      if (a9) {
        const n8 = { "--w3m-color-av-1": r7[0], "--w3m-color-av-2": r7[1], "--w3m-color-av-3": r7[2], "--w3m-color-av-4": r7[3], "--w3m-color-av-5": r7[4] };
        Object.entries(n8).forEach(([l9, w11]) => a9.style.setProperty(l9, w11));
      }
    }, setRecentWallet(e11) {
      const { walletConnectVersion: t8 } = i2.state;
      localStorage.setItem(s7.W3M_RECENT_WALLET, JSON.stringify({ [t8]: e11 }));
    }, getRecentWallet() {
      const e11 = localStorage.getItem(s7.W3M_RECENT_WALLET);
      if (e11) {
        const { walletConnectVersion: t8 } = i2.state, o11 = JSON.parse(e11);
        if (o11[t8])
          return o11[t8];
      }
    }, getExtensionWallets() {
      const e11 = [];
      for (const [t8, o11] of Object.entries(J4.injectedPreset))
        o11 != null && o11.isInjected && !o11.isDesktop && e11.push(ha({ id: t8 }, o11));
      return e11;
    }, caseSafeIncludes(e11, t8) {
      return e11.toUpperCase().includes(t8.toUpperCase());
    }, openWalletExplorerUrl() {
      d2.openHref(s7.EXPLORER_WALLET_URL, "_blank");
    } };
    wa = i3`.w3m-router{overflow:hidden;will-change:transform}.w3m-content{display:flex;flex-direction:column}`;
    pa = Object.defineProperty;
    ua = Object.getOwnPropertyDescriptor;
    Be4 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ua(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && pa(t8, o11, a9), a9;
    };
    he5 = class extends s6 {
      constructor() {
        super(), this.view = g4.state.view, this.prevView = g4.state.view, this.unsubscribe = void 0, this.oldHeight = "0px", this.resizeObserver = void 0, this.unsubscribe = g4.subscribe((e11) => {
          this.view !== e11.view && this.onChangeRoute();
        });
      }
      firstUpdated() {
        this.resizeObserver = new ResizeObserver(([e11]) => {
          const t8 = `${e11.contentRect.height}px`;
          this.oldHeight !== "0px" && (animate2(this.routerEl, { height: [this.oldHeight, t8] }, { duration: 0.2 }), animate2(this.routerEl, { opacity: [0, 1], scale: [0.99, 1] }, { duration: 0.37, delay: 0.03 })), this.oldHeight = t8;
        }), this.resizeObserver.observe(this.contentEl);
      }
      disconnectedCallback() {
        var e11, t8;
        (e11 = this.unsubscribe) == null || e11.call(this), (t8 = this.resizeObserver) == null || t8.disconnect();
      }
      get routerEl() {
        return s7.getShadowRootElement(this, ".w3m-router");
      }
      get contentEl() {
        return s7.getShadowRootElement(this, ".w3m-content");
      }
      viewTemplate() {
        switch (this.view) {
          case "ConnectWallet":
            return x4`<w3m-connect-wallet-view></w3m-connect-wallet-view>`;
          case "SelectNetwork":
            return x4`<w3m-select-network-view></w3m-select-network-view>`;
          case "InjectedConnector":
            return x4`<w3m-injected-connector-view></w3m-injected-connector-view>`;
          case "InstallConnector":
            return x4`<w3m-install-connector-view></w3m-install-connector-view>`;
          case "GetWallet":
            return x4`<w3m-get-wallet-view></w3m-get-wallet-view>`;
          case "DesktopConnector":
            return x4`<w3m-desktop-connector-view></w3m-desktop-connector-view>`;
          case "WalletExplorer":
            return x4`<w3m-wallet-explorer-view></w3m-wallet-explorer-view>`;
          case "Qrcode":
            return x4`<w3m-qrcode-view></w3m-qrcode-view>`;
          case "Help":
            return x4`<w3m-help-view></w3m-help-view>`;
          case "Account":
            return x4`<w3m-account-view></w3m-account-view>`;
          case "SwitchNetwork":
            return x4`<w3m-switch-network-view></w3m-switch-network-view>`;
          case "Connectors":
            return x4`<w3m-connectors-view></w3m-connectors-view>`;
          default:
            return x4`<div>Not Found</div>`;
        }
      }
      async onChangeRoute() {
        await animate2(this.routerEl, { opacity: [1, 0], scale: [1, 1.02] }, { duration: 0.15 }).finished, this.view = g4.state.view;
      }
      render() {
        return x4`<div class="w3m-router"><div class="w3m-content">${this.viewTemplate()}</div></div>`;
      }
    };
    he5.styles = [m5.globalCss, wa], Be4([t4()], he5.prototype, "view", 2), Be4([t4()], he5.prototype, "prevView", 2), he5 = Be4([e5("w3m-modal-router")], he5);
    ga = i3`div{height:36px;width:max-content;display:flex;justify-content:center;align-items:center;padding:10px 15px;position:absolute;top:12px;box-shadow:0 6px 14px -6px rgba(10,16,31,.3),0 10px 32px -4px rgba(10,16,31,.15);z-index:2;left:50%;transform:translateX(-50%);pointer-events:none;backdrop-filter:blur(20px) saturate(1.8);-webkit-backdrop-filter:blur(20px) saturate(1.8);border-radius:var(--w3m-notification-border-radius);border:1px solid var(--w3m-color-overlay);background-color:var(--w3m-color-overlay)}svg{margin-right:5px}@-moz-document url-prefix(){div{background-color:var(--w3m-color-bg-3)}}.w3m-success path{fill:var(--w3m-accent-color)}.w3m-error path{fill:var(--w3m-error-color)}`;
    va = Object.defineProperty;
    ba = Object.getOwnPropertyDescriptor;
    bt2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ba(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && va(t8, o11, a9), a9;
    };
    We4 = class extends s6 {
      constructor() {
        super(), this.open = false, this.unsubscribe = void 0, this.timeout = void 0, this.unsubscribe = H5.subscribe((e11) => {
          e11.open ? (this.open = true, this.timeout = setTimeout(() => H5.closeToast(), 2200)) : (this.open = false, clearTimeout(this.timeout));
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribe) == null || e11.call(this), clearTimeout(this.timeout), H5.closeToast();
      }
      render() {
        const { message: e11, variant: t8 } = H5.state, o11 = { "w3m-success": t8 === "success", "w3m-error": t8 === "error" };
        return this.open ? x4`<div class="${o8(o11)}">${t8 === "success" ? p5.CHECKMARK_ICON : null} ${t8 === "error" ? p5.CROSS_ICON : null}<w3m-text variant="small-regular">${e11}</w3m-text></div>` : null;
      }
    };
    We4.styles = [m5.globalCss, ga], bt2([t4()], We4.prototype, "open", 2), We4 = bt2([e5("w3m-modal-toast")], We4);
    fa = i3`button{padding:5px;border-radius:var(--w3m-button-hover-highlight-border-radius);transition:all .2s ease;display:flex;flex-direction:column;align-items:center;justify-content:center;width:80px;height:90px}w3m-network-image{width:54px;height:59px}w3m-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center;margin-top:5px}button:hover{background-color:var(--w3m-color-overlay)}`;
    xa = Object.defineProperty;
    ya = Object.getOwnPropertyDescriptor;
    Me3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ya(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && xa(t8, o11, a9), a9;
    };
    oe4 = class extends s6 {
      constructor() {
        super(...arguments), this.onClick = () => null, this.name = "", this.chainId = "";
      }
      render() {
        return x4`<button @click="${this.onClick}"><w3m-network-image chainId="${this.chainId}"></w3m-network-image><w3m-text variant="xsmall-regular">${this.name}</w3m-text></button>`;
      }
    };
    oe4.styles = [m5.globalCss, fa], Me3([e6()], oe4.prototype, "onClick", 2), Me3([e6()], oe4.prototype, "name", 2), Me3([e6()], oe4.prototype, "chainId", 2), oe4 = Me3([e5("w3m-network-button")], oe4);
    Ca = i3`div{width:inherit;height:inherit}.polygon-stroke{stroke:var(--w3m-color-overlay)}svg{width:100%;height:100%;margin:0}#network-placeholder-fill{fill:var(--w3m-color-bg-3)}#network-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
    ka = Object.defineProperty;
    $a = Object.getOwnPropertyDescriptor;
    ft3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? $a(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && ka(t8, o11, a9), a9;
    };
    Ee2 = class extends s6 {
      constructor() {
        super(...arguments), this.chainId = "";
      }
      render() {
        const e11 = s7.getChainIcon(this.chainId);
        return e11 ? x4`<div><svg width="54" height="59" viewBox="0 0 54 59" fill="none"><defs><clipPath id="polygon"><path d="M17.033 4.964c3.852-2.262 5.778-3.393 7.84-3.77a11.807 11.807 0 0 1 4.254 0c2.062.377 3.988 1.508 7.84 3.77l6.066 3.562c3.852 2.263 5.777 3.394 7.13 5.022a12.268 12.268 0 0 1 2.127 3.747c.71 2.006.71 4.268.71 8.793v7.124c0 4.525 0 6.787-.71 8.793a12.268 12.268 0 0 1-2.126 3.747c-1.354 1.628-3.28 2.76-7.131 5.022l-6.066 3.562c-3.852 2.262-5.778 3.393-7.84 3.771a11.814 11.814 0 0 1-4.254 0c-2.062-.378-3.988-1.509-7.84-3.77l-6.066-3.563c-3.852-2.263-5.778-3.394-7.13-5.022a12.268 12.268 0 0 1-2.127-3.747C1 40 1 37.737 1 33.212v-7.124c0-4.525 0-6.787.71-8.793a12.268 12.268 0 0 1 2.127-3.747c1.352-1.628 3.278-2.76 7.13-5.022l6.066-3.562Z"/></clipPath></defs><image clip-path="url(#polygon)" href="${e11}" width="58" height="59" x="-2" y="0"/><path class="polygon-stroke" d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z" stroke="#fff"/></svg></div>` : x4`${p5.NETWORK_PLACEHOLDER}`;
      }
    };
    Ee2.styles = [m5.globalCss, Ca], ft3([e6()], Ee2.prototype, "chainId", 2), Ee2 = ft3([e5("w3m-network-image")], Ee2);
    Oa = 0.1;
    xt2 = 2.5;
    B5 = 7;
    Wa = { generate(e11, t8, o11, r7) {
      const a9 = r7 === "light" ? "#141414" : "#fff", n8 = r7 === "light" ? "#fff" : "#141414", l9 = [], w11 = Ia(e11, "Q"), g9 = t8 / w11.length, I9 = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }];
      I9.forEach(({ x: M9, y: C10 }) => {
        const N16 = (w11.length - B5) * g9 * M9, O8 = (w11.length - B5) * g9 * C10, R5 = 0.32;
        for (let H10 = 0; H10 < I9.length; H10 += 1) {
          const te4 = g9 * (B5 - H10 * 2);
          l9.push(b5`<rect fill="${H10 % 2 === 0 ? a9 : n8}" height="${te4}" rx="${te4 * R5}" ry="${te4 * R5}" width="${te4}" x="${N16 + g9 * H10}" y="${O8 + g9 * H10}">`);
        }
      });
      const Z5 = Math.floor((o11 + 25) / g9), $10 = w11.length / 2 - Z5 / 2, W5 = w11.length / 2 + Z5 / 2 - 1, se4 = [];
      w11.forEach((M9, C10) => {
        M9.forEach((N16, O8) => {
          if (w11[C10][O8] && !(C10 < B5 && O8 < B5 || C10 > w11.length - (B5 + 1) && O8 < B5 || C10 < B5 && O8 > w11.length - (B5 + 1)) && !(C10 > $10 && C10 < W5 && O8 > $10 && O8 < W5)) {
            const R5 = C10 * g9 + g9 / 2, H10 = O8 * g9 + g9 / 2;
            se4.push([R5, H10]);
          }
        });
      });
      const z8 = {};
      return se4.forEach(([M9, C10]) => {
        z8[M9] ? z8[M9].push(C10) : z8[M9] = [C10];
      }), Object.entries(z8).map(([M9, C10]) => {
        const N16 = C10.filter((O8) => C10.every((R5) => !Ve3(O8, R5, g9)));
        return [Number(M9), N16];
      }).forEach(([M9, C10]) => {
        C10.forEach((N16) => {
          l9.push(b5`<circle cx="${M9}" cy="${N16}" fill="${a9}" r="${g9 / xt2}">`);
        });
      }), Object.entries(z8).filter(([M9, C10]) => C10.length > 1).map(([M9, C10]) => {
        const N16 = C10.filter((O8) => C10.some((R5) => Ve3(O8, R5, g9)));
        return [Number(M9), N16];
      }).map(([M9, C10]) => {
        C10.sort((O8, R5) => O8 < R5 ? -1 : 1);
        const N16 = [];
        for (const O8 of C10) {
          const R5 = N16.find((H10) => H10.some((te4) => Ve3(O8, te4, g9)));
          R5 ? R5.push(O8) : N16.push([O8]);
        }
        return [M9, N16.map((O8) => [O8[0], O8[O8.length - 1]])];
      }).forEach(([M9, C10]) => {
        C10.forEach(([N16, O8]) => {
          l9.push(b5`<line x1="${M9}" x2="${M9}" y1="${N16}" y2="${O8}" stroke="${a9}" stroke-width="${g9 / (xt2 / 2)}" stroke-linecap="round">`);
        });
      }), l9;
    } };
    Ma = i3`@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}div{position:relative;user-select:none;display:block;overflow:hidden;width:100%;aspect-ratio:1/1;animation:fadeIn ease .2s}svg:first-child,w3m-wallet-image{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%)}w3m-wallet-image{transform:translateY(-50%) translateX(-50%)}w3m-wallet-image{width:25%;height:25%;border-radius:15px}svg:first-child{transform:translateY(-50%) translateX(-50%) scale(.9)}svg:first-child path:first-child{fill:var(--w3m-accent-color)}svg:first-child path:last-child{stroke:var(--w3m-color-overlay)}`;
    Ea = Object.defineProperty;
    ja = Object.getOwnPropertyDescriptor;
    we2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ja(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ea(t8, o11, a9), a9;
    };
    K3 = class extends s6 {
      constructor() {
        super(...arguments), this.uri = "", this.size = 0, this.logoSrc = "", this.walletId = "";
      }
      svgTemplate() {
        var t8;
        const o11 = (t8 = B3.state.themeMode) != null ? t8 : "light";
        return b5`<svg height="${this.size}" width="${this.size}">${Wa.generate(this.uri, this.size, this.size / 4, o11)}</svg>`;
      }
      render() {
        return x4`<div>${this.walletId || this.logoSrc ? x4`<w3m-wallet-image walletId="${l6(this.walletId)}" src="${l6(this.logoSrc)}"></w3m-wallet-image>` : p5.WALLET_CONNECT_ICON_COLORED} ${this.svgTemplate()}</div>`;
      }
    };
    K3.styles = [m5.globalCss, Ma], we2([e6()], K3.prototype, "uri", 2), we2([e6({ type: Number })], K3.prototype, "size", 2), we2([e6()], K3.prototype, "logoSrc", 2), we2([e6()], K3.prototype, "walletId", 2), K3 = we2([e5("w3m-qrcode")], K3);
    Pa = i3`:host{position:relative;height:28px;width:80%}input{width:100%;height:100%;line-height:28px!important;border-radius:var(--w3m-input-border-radius);font-style:normal;font-family:-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',sans-serif;font-feature-settings:'case' on;font-weight:500;font-size:16px;letter-spacing:-.03em;padding:0 10px 0 34px;transition:.2s all ease;color:transparent;position:absolute;background-color:var(--w3m-color-bg-3);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay)}input::placeholder{color:transparent}svg{margin-right:4px}.w3m-placeholder{top:0;left:50%;transform:translateX(-50%);transition:.2s all ease;pointer-events:none;display:flex;align-items:center;justify-content:center;height:100%;width:fit-content;position:relative}input:focus-within+.w3m-placeholder,input:not(:placeholder-shown)+.w3m-placeholder{transform:translateX(10px);left:0}w3m-text{opacity:1;transition:.2s opacity ease}input:focus-within+.w3m-placeholder w3m-text,input:not(:placeholder-shown)+.w3m-placeholder w3m-text{opacity:0}input:focus-within,input:not(:placeholder-shown){color:var(--w3m-color-fg-1)}input:focus-within{box-shadow:inset 0 0 0 1px var(--w3m-accent-color)}path{fill:var(--w3m-color-fg-2)}`;
    Aa = Object.defineProperty;
    La = Object.getOwnPropertyDescriptor;
    yt3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? La(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Aa(t8, o11, a9), a9;
    };
    je3 = class extends s6 {
      constructor() {
        super(...arguments), this.onChange = () => null;
      }
      render() {
        const e11 = d2.isMobile() ? "Search mobile wallets" : "Search desktop wallets";
        return x4`<input type="text" @input="${this.onChange}" placeholder="${e11}"><div class="w3m-placeholder">${p5.SEARCH_ICON}<w3m-text color="secondary" variant="small-thin">${e11}</w3m-text></div>`;
      }
    };
    je3.styles = [m5.globalCss, Pa], yt3([e6()], je3.prototype, "onChange", 2), je3 = yt3([e5("w3m-search-input")], je3);
    Ta = i3`@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}svg{animation:rotate 2s linear infinite;display:flex;justify-content:center;align-items:center}svg circle{stroke-linecap:round;animation:dash 1.5s ease infinite;stroke:var(--w3m-accent-color)}`;
    Na = Object.defineProperty;
    _a = Object.getOwnPropertyDescriptor;
    Da = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? _a(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Na(t8, o11, a9), a9;
    };
    Ue2 = class extends s6 {
      render() {
        return x4`<svg viewBox="0 0 50 50" width="24" height="24"><circle cx="25" cy="25" r="20" fill="none" stroke-width="4" stroke="#fff"/></svg>`;
      }
    };
    Ue2.styles = [m5.globalCss, Ta], Ue2 = Da([e5("w3m-spinner")], Ue2);
    Ra = i3`span{font-style:normal;font-family:var(--w3m-font-family);font-feature-settings:'tnum' on,'lnum' on,'case' on}.w3m-xsmall-bold{font-family:var(--w3m-text-xsmall-bold-font-family);font-weight:var(--w3m-text-xsmall-bold-weight);font-size:var(--w3m-text-xsmall-bold-size);line-height:var(--w3m-text-xsmall-bold-line-height);letter-spacing:var(--w3m-text-xsmall-bold-letter-spacing);text-transform:var(--w3m-text-xsmall-bold-text-transform)}.w3m-xsmall-regular{font-family:var(--w3m-text-xsmall-regular-font-family);font-weight:var(--w3m-text-xsmall-regular-weight);font-size:var(--w3m-text-xsmall-regular-size);line-height:var(--w3m-text-xsmall-regular-line-height);letter-spacing:var(--w3m-text-xsmall-regular-letter-spacing);text-transform:var(--w3m-text-xsmall-regular-text-transform)}.w3m-small-thin{font-family:var(--w3m-text-small-thin-font-family);font-weight:var(--w3m-text-small-thin-weight);font-size:var(--w3m-text-small-thin-size);line-height:var(--w3m-text-small-thin-line-height);letter-spacing:var(--w3m-text-small-thin-letter-spacing);text-transform:var(--w3m-text-small-thin-text-transform)}.w3m-small-regular{font-family:var(--w3m-text-small-regular-font-family);font-weight:var(--w3m-text-small-regular-weight);font-size:var(--w3m-text-small-regular-size);line-height:var(--w3m-text-small-regular-line-height);letter-spacing:var(--w3m-text-small-regular-letter-spacing);text-transform:var(--w3m-text-small-regular-text-transform)}.w3m-medium-regular{font-family:var(--w3m-text-medium-regular-font-family);font-weight:var(--w3m-text-medium-regular-weight);font-size:var(--w3m-text-medium-regular-size);line-height:var(--w3m-text-medium-regular-line-height);letter-spacing:var(--w3m-text-medium-regular-letter-spacing);text-transform:var(--w3m-text-medium-regular-text-transform)}.w3m-big-bold{font-family:var(--w3m-text-big-bold-font-family);font-weight:var(--w3m-text-big-bold-weight);font-size:var(--w3m-text-big-bold-size);line-height:var(--w3m-text-big-bold-line-height);letter-spacing:var(--w3m-text-big-bold-letter-spacing);text-transform:var(--w3m-text-big-bold-text-transform)}:host(*){color:var(--w3m-color-fg-1)}.w3m-color-primary{color:var(--w3m-color-fg-1)}.w3m-color-secondary{color:var(--w3m-color-fg-2)}.w3m-color-tertiary{color:var(--w3m-color-fg-3)}.w3m-color-inverse{color:var(--w3m-accent-fill-color)}.w3m-color-accnt{color:var(--w3m-accent-color)}.w3m-color-error{color:var(--w3m-error-color)}`;
    Za = Object.defineProperty;
    Ha = Object.getOwnPropertyDescriptor;
    ze3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ha(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Za(t8, o11, a9), a9;
    };
    pe3 = class extends s6 {
      constructor() {
        super(...arguments), this.variant = "medium-regular", this.color = "primary";
      }
      render() {
        const e11 = { "w3m-big-bold": this.variant === "big-bold", "w3m-medium-regular": this.variant === "medium-regular", "w3m-small-regular": this.variant === "small-regular", "w3m-small-thin": this.variant === "small-thin", "w3m-xsmall-regular": this.variant === "xsmall-regular", "w3m-xsmall-bold": this.variant === "xsmall-bold", "w3m-color-primary": this.color === "primary", "w3m-color-secondary": this.color === "secondary", "w3m-color-tertiary": this.color === "tertiary", "w3m-color-inverse": this.color === "inverse", "w3m-color-accnt": this.color === "accent", "w3m-color-error": this.color === "error" };
        return x4`<span><slot class="${o8(e11)}"></slot></span>`;
      }
    };
    pe3.styles = [m5.globalCss, Ra], ze3([e6()], pe3.prototype, "variant", 2), ze3([e6()], pe3.prototype, "color", 2), pe3 = ze3([e5("w3m-text")], pe3);
    Sa = i3`div{overflow:hidden;position:relative;border-radius:50%}div::after{content:'';position:absolute;inset:0;border-radius:50%;border:1px solid var(--w3m-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}svg{width:100%;height:100%}#token-placeholder-fill{fill:var(--w3m-color-bg-3)}#token-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
    Ba = Object.defineProperty;
    Va = Object.getOwnPropertyDescriptor;
    Ct2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Va(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ba(t8, o11, a9), a9;
    };
    Pe3 = class extends s6 {
      constructor() {
        super(...arguments), this.symbol = void 0;
      }
      render() {
        var e11;
        const t8 = s7.getTokenIcon((e11 = this.symbol) != null ? e11 : "");
        return t8 ? x4`<div><img src="${t8}" alt="${this.id}"></div>` : p5.TOKEN_PLACEHOLDER;
      }
    };
    Pe3.styles = [m5.globalCss, Sa], Ct2([e6()], Pe3.prototype, "symbol", 2), Pe3 = Ct2([e5("w3m-token-image")], Pe3);
    Ua = i3`button{transition:all .2s ease;width:100%;height:100%;border-radius:var(--w3m-button-hover-highlight-border-radius);display:flex;align-items:flex-start}button:hover{background-color:var(--w3m-color-overlay)}button>div{width:80px;padding:5px 0;display:flex;flex-direction:column;align-items:center}w3m-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center}w3m-wallet-image{height:60px;width:60px;transition:all .2s ease;border-radius:var(--w3m-wallet-icon-border-radius);margin-bottom:5px}.w3m-sublabel{margin-top:2px}`;
    za = Object.defineProperty;
    Ga = Object.getOwnPropertyDescriptor;
    V4 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ga(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && za(t8, o11, a9), a9;
    };
    S5 = class extends s6 {
      constructor() {
        super(...arguments), this.onClick = () => null, this.name = "", this.walletId = "", this.label = void 0, this.src = void 0, this.installed = false, this.recent = false;
      }
      sublabelTemplate() {
        return this.recent ? x4`<w3m-text class="w3m-sublabel" variant="xsmall-bold" color="tertiary">RECENT</w3m-text>` : this.installed ? x4`<w3m-text class="w3m-sublabel" variant="xsmall-bold" color="tertiary">INSTALLED</w3m-text>` : null;
      }
      render() {
        var e11;
        return x4`<button @click="${this.onClick}"><div><w3m-wallet-image walletId="${this.walletId}" .src="${this.src}"></w3m-wallet-image><w3m-text variant="xsmall-regular">${(e11 = this.label) != null ? e11 : s7.getWalletName(this.name, true)}</w3m-text>${this.sublabelTemplate()}</div></button>`;
      }
    };
    S5.styles = [m5.globalCss, Ua], V4([e6()], S5.prototype, "onClick", 2), V4([e6()], S5.prototype, "name", 2), V4([e6()], S5.prototype, "walletId", 2), V4([e6()], S5.prototype, "label", 2), V4([e6()], S5.prototype, "src", 2), V4([e6()], S5.prototype, "installed", 2), V4([e6()], S5.prototype, "recent", 2), S5 = V4([e5("w3m-wallet-button")], S5);
    Fa = i3`div{overflow:hidden;position:relative;border-radius:inherit;width:100%;height:100%}svg{position:relative;width:100%;height:100%}div::after{content:'';position:absolute;inset:0;border-radius:inherit;border:1px solid var(--w3m-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}#wallet-placeholder-fill{fill:var(--w3m-color-bg-3)}#wallet-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
    Ka = Object.defineProperty;
    qa = Object.getOwnPropertyDescriptor;
    Ge3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? qa(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ka(t8, o11, a9), a9;
    };
    ue2 = class extends s6 {
      constructor() {
        super(...arguments), this.walletId = void 0, this.src = void 0;
      }
      render() {
        var e11;
        const t8 = s7.getWalletId((e11 = this.walletId) != null ? e11 : ""), o11 = this.src ? this.src : s7.getWalletIcon(t8);
        return x4`${o11.length ? x4`<div><img src="${o11}" alt="${this.id}"></div>` : p5.WALLET_PLACEHOLDER}`;
      }
    };
    ue2.styles = [m5.globalCss, Fa], Ge3([e6()], ue2.prototype, "walletId", 2), Ge3([e6()], ue2.prototype, "src", 2), ue2 = Ge3([e5("w3m-wallet-image")], ue2);
    Qa = Object.defineProperty;
    Ya = Object.getOwnPropertyDescriptor;
    Xa = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ya(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Qa(t8, o11, a9), a9;
    };
    kt = class extends s6 {
      constructor() {
        super(), this.unwatchAccount = void 0, A4.getAccount(), this.fetchProfile(), this.fetchBalance(), this.unwatchAccount = p3.client().watchAccount((e11) => {
          if (A4.state.isConnected && !e11.isConnected)
            x3.close();
          else {
            const { address: t8 } = A4.state;
            e11.address !== t8 && (this.fetchProfile(e11.address), this.fetchBalance(e11.address)), A4.setAddress(e11.address);
          }
          A4.setIsConnected(e11.isConnected);
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unwatchAccount) == null || e11.call(this);
      }
      async fetchProfile(e11) {
        var t8;
        const o11 = (t8 = i2.state.chains) == null ? void 0 : t8.find((r7) => r7.id === 1);
        if (S2.state.enableAccountView && o11)
          try {
            await A4.fetchProfile(s7.preloadImage, e11);
          } catch (r7) {
            console.error(r7), H5.openToast(s7.getErrorMessage(r7), "error");
          }
      }
      async fetchBalance(e11) {
        if (S2.state.enableAccountView)
          try {
            await A4.fetchBalance(e11);
          } catch (t8) {
            console.error(t8), H5.openToast(s7.getErrorMessage(t8), "error");
          }
      }
    };
    kt = Xa([e5("w3m-account-context")], kt);
    Ja = Object.defineProperty;
    eo = Object.getOwnPropertyDescriptor;
    $t = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? eo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ja(t8, o11, a9), a9;
    };
    Fe4 = class extends s6 {
      constructor() {
        super(), this.preload = true, this.preloadData();
      }
      async loadImages(e11) {
        try {
          e11 != null && e11.length && await Promise.all(e11.map(async (t8) => s7.preloadImage(t8)));
        } catch {
          console.info("Unsuccessful attempt at preloading some images", e11);
        }
      }
      async preloadListings() {
        var e11;
        if (S2.state.enableExplorer) {
          const { standaloneChains: t8, chains: o11, walletConnectVersion: r7 } = i2.state, a9 = t8?.join(",");
          await Promise.all([_3.getPreviewWallets({ page: 1, entries: 10, chains: a9, device: d2.isMobile() ? "mobile" : "desktop", version: r7 }), _3.getRecomendedWallets()]), i2.setIsDataLoaded(true);
          const { previewWallets: n8, recomendedWallets: l9 } = _3.state, w11 = (e11 = o11?.map((I9) => s7.getChainIcon(I9.id))) != null ? e11 : [], g9 = [...n8, ...l9].map((I9) => I9.image_url.lg);
          await this.loadImages([...w11, ...g9]);
        } else
          i2.setIsDataLoaded(true);
      }
      async preloadCustomImages() {
        const e11 = s7.getCustomImageUrls();
        await this.loadImages(e11);
      }
      async preloadConnectorImages() {
        if (!i2.state.isStandalone) {
          const e11 = s7.getConnectorImageUrls();
          await this.loadImages(e11);
        }
      }
      async preloadData() {
        try {
          this.preload && (this.preload = false, await Promise.all([this.preloadListings(), this.preloadCustomImages(), this.preloadConnectorImages()]));
        } catch (e11) {
          console.error(e11), H5.openToast("Failed preloading", "error");
        }
      }
    };
    $t([t4()], Fe4.prototype, "preload", 2), Fe4 = $t([e5("w3m-explorer-context")], Fe4);
    to = Object.defineProperty;
    ao = Object.getOwnPropertyDescriptor;
    Ot2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ao(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && to(t8, o11, a9), a9;
    };
    Ke3 = class extends s6 {
      constructor() {
        super(), this.activeChainId = void 0, this.unwatchNetwork = void 0;
        const e11 = i2.getSelectedChain();
        this.activeChainId = e11?.id, this.unwatchNetwork = p3.client().watchNetwork((t8) => {
          const o11 = t8.chain;
          o11 && this.activeChainId !== o11.id && (i2.setSelectedChain(o11), this.activeChainId = o11.id, A4.resetBalance(), this.fetchBalance());
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unwatchNetwork) == null || e11.call(this);
      }
      async fetchBalance() {
        if (S2.state.enableAccountView)
          try {
            await A4.fetchBalance();
          } catch (e11) {
            console.error(e11), H5.openToast(s7.getErrorMessage(e11), "error");
          }
      }
    };
    Ot2([t4()], Ke3.prototype, "activeChainId", 2), Ke3 = Ot2([e5("w3m-network-context")], Ke3);
    oo = Object.defineProperty;
    ro = Object.getOwnPropertyDescriptor;
    lo = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ro(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && oo(t8, o11, a9), a9;
    };
    It2 = class extends s6 {
      constructor() {
        super(), this.unsubscribeTheme = void 0, m5.setTheme(), this.unsubscribeTheme = B3.subscribe(m5.setTheme), this.preloadThemeImages();
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeTheme) == null || e11.call(this);
      }
      async preloadThemeImages() {
        try {
          const { themeVariables: e11 } = B3.state, t8 = [e11?.["--w3m-background-image-url"], e11?.["--w3m-logo-image-url"]].filter(Boolean);
          t8.length && await Promise.all(t8.map(async (o11) => s7.preloadImage(o11)));
        } catch {
          console.info("Unsuccessful attempt at preloading some images");
        }
      }
    };
    It2 = lo([e5("w3m-theme-context")], It2);
    no = i3`:host{all:initial}div{display:flex;align-items:center;background-color:var(--w3m-color-overlay);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);border-radius:var(--w3m-button-border-radius);padding:4px 4px 4px 8px}div button{border-radius:var(--w3m-secondary-button-border-radius);padding:4px 8px;padding-left:4px;height:auto;margin-left:10px;color:var(--w3m-accent-fill-color);background-color:var(--w3m-accent-color)}.w3m-no-avatar{padding-left:8px}button::after{content:'';inset:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--w3m-color-overlay)}button:hover::after{background-color:var(--w3m-color-overlay)}w3m-avatar{margin-right:6px}w3m-button-big w3m-avatar{margin-left:-5px}`;
    io = Object.defineProperty;
    so = Object.getOwnPropertyDescriptor;
    qe3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? so(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && io(t8, o11, a9), a9;
    };
    ge3 = class extends s6 {
      constructor() {
        super(), this.balance = "hide", this.avatar = "show", s7.rejectStandaloneButtonComponent();
      }
      onOpen() {
        const { isStandalone: e11 } = i2.state;
        e11 || x3.open({ route: "Account" });
      }
      accountTemplate() {
        const e11 = this.avatar === "show";
        return x4`${e11 ? x4`<w3m-avatar></w3m-avatar>` : null}<w3m-address-text></w3m-address-text>`;
      }
      render() {
        const e11 = this.balance === "show", t8 = { "w3m-no-avatar": this.avatar === "hide" };
        return e11 ? x4`<div><w3m-balance></w3m-balance><button @click="${this.onOpen}" class="${o8(t8)}">${this.accountTemplate()}</button></div>` : x4`<w3m-button-big @click="${this.onOpen}">${this.accountTemplate()}</w3m-button-big>`;
      }
    };
    ge3.styles = [m5.globalCss, no], qe3([e6()], ge3.prototype, "balance", 2), qe3([e6()], ge3.prototype, "avatar", 2), ge3 = qe3([e5("w3m-account-button")], ge3);
    co = i3`button{display:flex;border-radius:var(--w3m-button-hover-highlight-border-radius);flex-direction:column;transition:background-color .2s ease;justify-content:center;padding:5px;width:100px}button:hover{background-color:var(--w3m-color-overlay)}button:disabled{pointer-events:none}w3m-network-image{width:32px;height:32px}w3m-text{margin-top:4px}`;
    mo = Object.defineProperty;
    ho = Object.getOwnPropertyDescriptor;
    Qe4 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ho(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && mo(t8, o11, a9), a9;
    };
    ve = class extends s6 {
      constructor() {
        super(), this.chainId = "", this.label = "", this.unsubscribeNetwork = void 0;
        const { selectedChain: e11 } = i2.state;
        this.chainId = e11?.id.toString(), this.label = e11?.name, this.unsubscribeNetwork = i2.subscribe(({ selectedChain: t8 }) => {
          this.chainId = t8?.id.toString(), this.label = t8?.name;
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeNetwork) == null || e11.call(this);
      }
      onClick() {
        g4.push("SelectNetwork");
      }
      render() {
        const { chains: e11, selectedChain: t8 } = i2.state, o11 = e11?.map((n8) => n8.id), r7 = t8 && o11?.includes(t8.id), a9 = e11 && e11.length <= 1 && r7;
        return x4`<button @click="${this.onClick}" ?disabled="${a9}"><w3m-network-image chainId="${l6(this.chainId)}"></w3m-network-image><w3m-text variant="xsmall-regular" color="accent">${this.label}</w3m-text></button>`;
      }
    };
    ve.styles = [m5.globalCss, co], Qe4([t4()], ve.prototype, "chainId", 2), Qe4([t4()], ve.prototype, "label", 2), ve = Qe4([e5("w3m-account-network-button")], ve);
    wo = i3`@keyframes slide{0%{background-position:0 0}100%{background-position:200px 0}}w3m-text{padding:1px 0}.w3m-loading{background:linear-gradient(270deg,var(--w3m-color-fg-1) 36.33%,var(--w3m-color-fg-3) 42.07%,var(--w3m-color-fg-1) 83.3%);background-size:200px 100%;background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation-name:slide;animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear}`;
    po = Object.defineProperty;
    uo = Object.getOwnPropertyDescriptor;
    be4 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? uo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && po(t8, o11, a9), a9;
    };
    q3 = class extends s6 {
      constructor() {
        super(), this.address = void 0, this.name = void 0, this.loading = true, this.variant = "button", this.unsubscribeAccount = void 0, this.address = A4.state.address, this.name = A4.state.profileName, this.loading = !!A4.state.profileLoading, this.unsubscribeAccount = A4.subscribe(({ address: e11, profileName: t8, profileLoading: o11 }) => {
          this.address = e11, this.name = t8, this.loading = !!o11;
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeAccount) == null || e11.call(this);
      }
      render() {
        var e11;
        const t8 = this.variant === "button", o11 = { "w3m-loading": this.loading };
        return x4`<w3m-text class="${o8(o11)}" variant="${t8 ? "medium-regular" : "big-bold"}" color="${t8 ? "inverse" : "primary"}">${this.name ? this.name : s7.truncate((e11 = this.address) != null ? e11 : "")}</w3m-text>`;
      }
    };
    q3.styles = [m5.globalCss, wo], be4([t4()], q3.prototype, "address", 2), be4([t4()], q3.prototype, "name", 2), be4([t4()], q3.prototype, "loading", 2), be4([e6()], q3.prototype, "variant", 2), q3 = be4([e5("w3m-address-text")], q3);
    T2 = { allowedExplorerListings(e11) {
      const { explorerAllowList: t8, explorerDenyList: o11 } = S2.state;
      let r7 = [...e11];
      return t8 && (r7 = r7.filter((a9) => t8.includes(a9.id))), o11 && (r7 = r7.filter((a9) => !o11.includes(a9.id))), r7;
    }, walletsWithInjected(e11) {
      let t8 = [...e11 ?? []];
      if (window.ethereum) {
        const o11 = s7.getWalletName("");
        t8 = t8.filter(({ name: r7 }) => !s7.caseSafeIncludes(r7, o11));
      }
      return t8;
    }, connectorWallets() {
      const { isStandalone: e11 } = i2.state;
      if (e11)
        return [];
      let t8 = p3.client().getConnectors();
      return !window.ethereum && d2.isMobile() && (t8 = t8.filter(({ id: o11 }) => o11 !== "injected" && o11 !== ie4.metaMask)), t8;
    }, walletTemplatesWithRecent(e11, t8) {
      let o11 = [...e11];
      if (t8) {
        const r7 = s7.getRecentWallet();
        o11 = o11.filter((a9) => !a9.values.includes(r7?.name)), o11.splice(1, 0, t8);
      }
      return o11;
    }, deduplicateExplorerListingsFromConnectors(e11) {
      const { isStandalone: t8 } = i2.state;
      if (t8)
        return e11;
      const o11 = p3.client().getConnectors().map(({ name: r7 }) => r7.toUpperCase());
      return e11.filter(({ name: r7 }) => !o11.includes(r7.toUpperCase()));
    } };
    go = i3`@keyframes scroll{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(calc(-70px * 10),0,0)}}.w3m-slider{position:relative;overflow-x:hidden;padding:10px 0;margin:0 -20px}.w3m-slider::after,.w3m-slider::before{content:'';height:100%;width:50px;z-index:2;position:absolute;background:linear-gradient(to right,var(--w3m-color-bg-1) 0,transparent 100%);top:0}.w3m-slider::before{left:0}.w3m-slider::after{right:0;transform:rotateZ(180deg)}.w3m-track{display:flex;width:calc(70px * 20);animation:scroll 20s linear infinite}.w3m-action{padding:30px 0 10px 0;display:flex;justify-content:center;align-items:center;flex-direction:column}.w3m-action w3m-button-big:last-child{margin-top:10px}w3m-wallet-image{width:60px;height:60px;margin:0 5px;box-shadow:0 2px 4px -2px rgba(0,0,0,.12),0 4px 4px -2px rgba(0,0,0,.08);border-radius:15px}w3m-button-big{margin:0 5px}`;
    vo = Object.defineProperty;
    bo = Object.getOwnPropertyDescriptor;
    fo = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? bo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && vo(t8, o11, a9), a9;
    };
    Ye3 = class extends s6 {
      onGoToQrcode() {
        g4.push("Qrcode");
      }
      onGoToConnectors() {
        g4.push("Connectors");
      }
      onGoToGetWallet() {
        g4.push("GetWallet");
      }
      getConnectors() {
        let e11 = T2.connectorWallets();
        return window.ethereum || (e11 = e11.filter(({ id: t8 }) => t8 !== "injected" && t8 !== ie4.metaMask)), e11;
      }
      render() {
        const { previewWallets: e11 } = _3.state, t8 = e11.length, o11 = [...e11, ...e11], r7 = this.getConnectors().length > 0;
        return x4`<w3m-modal-header title="Connect your wallet" .onAction="${this.onGoToQrcode}" .actionIcon="${p5.QRCODE_ICON}"></w3m-modal-header><w3m-modal-content>${t8 ? x4`<div class="w3m-slider"><div class="w3m-track">${o11.map(({ image_url: a9 }) => x4`<w3m-wallet-image src="${a9.lg}"></w3m-wallet-image>`)}</div></div>` : null}<div class="w3m-action"><div><w3m-button-big @click="${s7.handleAndroidLinking}"><w3m-text variant="medium-normal" color="inverse">${r7 ? "WalletConnect" : "Select Wallet"}</w3m-text></w3m-button-big>${r7 ? x4`<w3m-button-big @click="${this.onGoToConnectors}"><w3m-text variant="medium-normal" color="inverse">Other</w3m-text></w3m-button-big>` : null}</div><w3m-button-big variant="secondary" @click="${this.onGoToGetWallet}"><w3m-text variant="medium-regular" color="accent">I don’t have a wallet</w3m-text></w3m-button-big></div></w3m-modal-content>`;
      }
    };
    Ye3.styles = [m5.globalCss, go], Ye3 = fo([e5("w3m-android-wallet-selection")], Ye3);
    xo = i3`@keyframes slide{0%{transform:translateX(-50px)}100%{transform:translateX(200px)}}.w3m-placeholder,img{border-radius:50%;box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);display:block;position:relative;overflow:hidden!important;background-color:var(--w3m-color-av-1);background-image:radial-gradient(at 66% 77%,var(--w3m-color-av-2) 0,transparent 50%),radial-gradient(at 29% 97%,var(--w3m-color-av-3) 0,transparent 50%),radial-gradient(at 99% 86%,var(--w3m-color-av-4) 0,transparent 50%),radial-gradient(at 29% 88%,var(--w3m-color-av-5) 0,transparent 50%);transform:translateZ(0)}.w3m-loader{width:50px;height:100%;background:linear-gradient(270deg,transparent 0,rgba(255,255,255,.4) 30%,transparent 100%);animation-name:slide;animation-duration:1.5s;transform:translateX(-50px);animation-iteration-count:infinite;animation-timing-function:linear;animation-delay:.55s}.w3m-small{width:24px;height:24px}.w3m-medium{width:60px;height:60px}`;
    yo = Object.defineProperty;
    Co = Object.getOwnPropertyDescriptor;
    fe2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Co(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && yo(t8, o11, a9), a9;
    };
    Q3 = class extends s6 {
      constructor() {
        super(), this.address = void 0, this.avatar = void 0, this.loading = true, this.size = "small", this.unsubscribeAccount = void 0, this.address = A4.state.address, this.avatar = A4.state.profileAvatar, this.loading = !!A4.state.profileLoading, this.unsubscribeAccount = A4.subscribe(({ address: e11, profileAvatar: t8, profileLoading: o11 }) => {
          this.address = e11, this.avatar = t8, this.loading = !!o11;
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeAccount) == null || e11.call(this);
      }
      render() {
        const e11 = { "w3m-placeholder": true, "w3m-small": this.size === "small", "w3m-medium": this.size === "medium" };
        return this.avatar ? x4`<img class="${o8(e11)}" src="${this.avatar}">` : this.address ? (s7.generateAvatarColors(this.address), x4`<div class="${o8(e11)}">${this.loading ? x4`<div class="w3m-loader"></div>` : null}</div>`) : null;
      }
    };
    Q3.styles = [m5.globalCss, xo], fe2([t4()], Q3.prototype, "address", 2), fe2([t4()], Q3.prototype, "avatar", 2), fe2([t4()], Q3.prototype, "loading", 2), fe2([e6()], Q3.prototype, "size", 2), Q3 = fe2([e5("w3m-avatar")], Q3);
    ko = i3`div{display:flex;align-items:center}w3m-token-image{width:28px;height:28px;margin-right:6px}`;
    $o = Object.defineProperty;
    Oo = Object.getOwnPropertyDescriptor;
    Xe3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Oo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && $o(t8, o11, a9), a9;
    };
    xe3 = class extends s6 {
      constructor() {
        var e11, t8;
        super(), this.symbol = void 0, this.amount = void 0, this.unsubscribeAccount = void 0, this.symbol = (e11 = A4.state.balance) == null ? void 0 : e11.symbol, this.amount = (t8 = A4.state.balance) == null ? void 0 : t8.amount, this.unsubscribeAccount = A4.subscribe(({ balance: o11 }) => {
          this.symbol = o11?.symbol, this.amount = o11?.amount;
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeAccount) == null || e11.call(this);
      }
      render() {
        let e11 = "_._";
        return this.amount === "0.0" ? e11 = 0 : typeof this.amount == "string" && this.amount.length > 6 ? e11 = parseFloat(this.amount).toFixed(3) : typeof this.amount == "string" && (e11 = parseFloat(this.amount)), x4`<div><w3m-token-image symbol="${l6(this.symbol)}"></w3m-token-image><w3m-text variant="medium-regular" color="primary">${e11} ${this.symbol}</w3m-text></div>`;
      }
    };
    xe3.styles = [m5.globalCss, ko], Xe3([t4()], xe3.prototype, "symbol", 2), Xe3([t4()], xe3.prototype, "amount", 2), xe3 = Xe3([e5("w3m-balance")], xe3);
    Io = i3`:host{all:initial}svg{width:28px;height:20px;margin:-1px 3px 0 -5px}svg path{fill:var(--w3m-accent-fill-color)}button:disabled svg path{fill:var(--w3m-color-fg-3)}w3m-spinner{margin:0 10px 0 0}`;
    Wo = Object.defineProperty;
    Mo = Object.getOwnPropertyDescriptor;
    Ae3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Mo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Wo(t8, o11, a9), a9;
    };
    re5 = class extends s6 {
      constructor() {
        super(), this.loading = false, this.label = "Connect Wallet", this.icon = "show", this.modalUnsub = void 0, s7.rejectStandaloneButtonComponent(), this.modalUnsub = x3.subscribe((e11) => {
          e11.open && (this.loading = true), e11.open || (this.loading = false);
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.modalUnsub) == null || e11.call(this);
      }
      iconTemplate() {
        return this.icon === "show" ? p5.WALLET_CONNECT_ICON : null;
      }
      onClick() {
        A4.state.isConnected ? this.onDisconnect() : this.onConnect();
      }
      onConnect() {
        this.loading = true;
        const { enableNetworkView: e11 } = S2.state, { chains: t8, selectedChain: o11 } = i2.state, r7 = t8?.length && t8.length > 1;
        e11 || r7 && !o11 ? x3.open({ route: "SelectNetwork" }) : x3.open({ route: "ConnectWallet" });
      }
      onDisconnect() {
        p3.client().disconnect(), A4.resetAccount();
      }
      render() {
        return x4`<w3m-button-big .disabled="${this.loading}" @click="${this.onClick}">${this.loading ? x4`<w3m-spinner></w3m-spinner><w3m-text variant="medium-regular" color="accent">Connecting...</w3m-text>` : x4`${this.iconTemplate()}<w3m-text variant="medium-regular" color="inverse">${this.label}</w3m-text>`}</w3m-button-big>`;
      }
    };
    re5.styles = [m5.globalCss, Io], Ae3([t4()], re5.prototype, "loading", 2), Ae3([e6()], re5.prototype, "label", 2), Ae3([e6()], re5.prototype, "icon", 2), re5 = Ae3([e5("w3m-connect-button")], re5);
    Eo = Object.defineProperty;
    jo = Object.getOwnPropertyDescriptor;
    le2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? jo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Eo(t8, o11, a9), a9;
    };
    Y4 = class extends s6 {
      constructor() {
        super(), this.isConnected = false, this.label = "Connect Wallet", this.icon = "show", this.avatar = "show", this.balance = "hide", this.unsubscribeAccount = void 0, s7.rejectStandaloneButtonComponent(), this.isConnected = A4.state.isConnected, this.unsubscribeAccount = A4.subscribe(({ isConnected: e11 }) => {
          this.isConnected = e11;
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeAccount) == null || e11.call(this);
      }
      render() {
        const { enableAccountView: e11 } = S2.state, t8 = l6(this.balance), o11 = l6(this.label), r7 = l6(this.icon), a9 = l6(this.avatar);
        return this.isConnected && e11 ? x4`<w3m-account-button balance="${t8}" avatar="${a9}"></w3m-account-button>` : x4`<w3m-connect-button label="${this.isConnected ? "Disconnect" : o11}" icon="${r7}"></w3m-connect-button>`;
      }
    };
    le2([t4()], Y4.prototype, "isConnected", 2), le2([e6()], Y4.prototype, "label", 2), le2([e6()], Y4.prototype, "icon", 2), le2([e6()], Y4.prototype, "avatar", 2), le2([e6()], Y4.prototype, "balance", 2), Y4 = le2([e5("w3m-core-button")], Y4);
    Po = i3`.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.w3m-desktop-title,.w3m-mobile-title{display:flex;align-items:center}.w3m-mobile-title{justify-content:space-between;margin-bottom:20px;margin-top:-10px}.w3m-desktop-title{margin-bottom:10px;padding:0 10px}.w3m-subtitle{display:flex;align-items:center}.w3m-subtitle:last-child path{fill:var(--w3m-color-fg-3)}.w3m-desktop-title svg,.w3m-mobile-title svg{margin-right:6px}.w3m-desktop-title path,.w3m-mobile-title path{fill:var(--w3m-accent-color)}`;
    Ao = Object.defineProperty;
    Lo = Object.getOwnPropertyDescriptor;
    To = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Lo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ao(t8, o11, a9), a9;
    };
    Je3 = class extends s6 {
      onDesktopWallet(e11) {
        g4.push("DesktopConnector", { DesktopConnector: e11 });
      }
      onInjectedWallet() {
        g4.push("InjectedConnector");
      }
      onInstallConnector() {
        g4.push("InstallConnector", { InstallConnector: { id: "metaMask", name: "MetaMask", isMobile: true, url: "https://metamask.io" } });
      }
      async onConnectorWallet(e11) {
        window.ethereum ? e11 === "injected" || e11 === ie4.metaMask ? this.onInjectedWallet() : await s7.handleConnectorConnection(e11) : this.onInstallConnector();
      }
      desktopWalletsTemplate() {
        const { desktopWallets: e11 } = S2.state;
        return e11?.map(({ id: t8, name: o11, links: { universal: r7, native: a9 } }) => x4`<w3m-wallet-button walletId="${t8}" name="${o11}" .onClick="${() => this.onDesktopWallet({ name: o11, walletId: t8, universal: r7, native: a9 })}"></w3m-wallet-button>`);
      }
      previewWalletsTemplate() {
        let e11 = T2.allowedExplorerListings(_3.state.previewWallets);
        return e11 = T2.deduplicateExplorerListingsFromConnectors(e11), e11.map(({ name: t8, desktop: { universal: o11, native: r7 }, homepage: a9, image_url: n8, id: l9 }) => x4`<w3m-wallet-button src="${n8.lg}" name="${t8}" .onClick="${() => this.onDesktopWallet({ walletId: l9, name: t8, native: r7, universal: o11 || a9, icon: n8.lg })}"></w3m-wallet-button>`);
      }
      connectorWalletsTemplate() {
        return T2.connectorWallets().map(({ id: e11, name: t8, ready: o11 }) => x4`<w3m-wallet-button .installed="${["injected", "metaMask"].includes(e11) && o11}" name="${t8}" walletId="${e11}" .onClick="${async () => this.onConnectorWallet(e11)}"></w3m-wallet-button>`);
      }
      recentWalletTemplate() {
        const e11 = s7.getRecentWallet();
        if (!e11)
          return;
        const { id: t8, name: o11, links: r7, image: a9 } = e11;
        return x4`<w3m-wallet-button .recent="${true}" name="${o11}" walletId="${l6(t8)}" src="${l6(a9)}" .onClick="${() => this.onDesktopWallet({ name: o11, walletId: t8, universal: r7?.universal, native: r7?.native, icon: a9 })}"></w3m-wallet-button>`;
      }
      render() {
        const { standaloneUri: e11 } = i2.state, t8 = this.desktopWalletsTemplate(), o11 = this.previewWalletsTemplate(), r7 = this.connectorWalletsTemplate(), a9 = this.recentWalletTemplate(), n8 = [...t8 ?? [], ...o11], l9 = [...r7, ...n8], w11 = T2.walletTemplatesWithRecent(l9, a9), g9 = T2.walletTemplatesWithRecent(n8, a9), I9 = e11 ? g9 : w11, Z5 = I9.length > 4;
        let $10 = [];
        Z5 ? $10 = I9.slice(0, 3) : $10 = I9;
        const W5 = !!$10.length;
        return x4`<w3m-modal-header border="${true}" title="Connect your wallet" .onAction="${s7.handleUriCopy}" .actionIcon="${p5.COPY_ICON}"></w3m-modal-header><w3m-modal-content><div class="w3m-mobile-title"><div class="w3m-subtitle">${p5.MOBILE_ICON}<w3m-text variant="small-regular" color="accent">Mobile</w3m-text></div><div class="w3m-subtitle">${p5.SCAN_ICON}<w3m-text variant="small-regular" color="secondary">Scan with your wallet</w3m-text></div></div><w3m-walletconnect-qr></w3m-walletconnect-qr></w3m-modal-content>${W5 ? x4`<w3m-modal-footer><div class="w3m-desktop-title">${p5.DESKTOP_ICON}<w3m-text variant="small-regular" color="accent">Desktop</w3m-text></div><div class="w3m-grid">${$10} ${Z5 ? x4`<w3m-view-all-wallets-button></w3m-view-all-wallets-button>` : null}</div></w3m-modal-footer>` : null}`;
      }
    };
    Je3.styles = [m5.globalCss, Po], Je3 = To([e5("w3m-desktop-wallet-selection")], Je3);
    No = i3`div{background-color:var(--w3m-color-bg-2);padding:10px 20px 15px 20px;border-top:1px solid var(--w3m-color-bg-3);text-align:center}a{color:var(--w3m-accent-color);text-decoration:none;transition:opacity .2s ease-in-out}a:hover{opacity:.8}`;
    _o = Object.defineProperty;
    Do = Object.getOwnPropertyDescriptor;
    Ro = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Do(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && _o(t8, o11, a9), a9;
    };
    et3 = class extends s6 {
      render() {
        const { termsOfServiceUrl: e11, privacyPolicyUrl: t8 } = S2.state;
        return e11 ?? t8 ? x4`<div><w3m-text variant="small-regular" color="secondary">By connecting your wallet to this app, you agree to the app's<br>${e11 ? x4`<a href="${e11}" target="_blank" rel="noopener noreferrer">Terms of Service</a>` : null} ${e11 && t8 ? "and" : null} ${t8 ? x4`<a href="${t8}" target="_blank" rel="noopener noreferrer">Privacy Policy</a>` : null}</w3m-text></div>` : null;
      }
    };
    et3.styles = [m5.globalCss, No], et3 = Ro([e5("w3m-legal-notice")], et3);
    Zo = i3`.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);margin:0 -10px;justify-content:space-between;row-gap:10px}`;
    Ho = Object.defineProperty;
    So = Object.getOwnPropertyDescriptor;
    Bo = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? So(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Ho(t8, o11, a9), a9;
    };
    tt3 = class extends s6 {
      onGoToQrcode() {
        g4.push("Qrcode");
      }
      async onConnectorWallet(e11) {
        await s7.handleConnectorConnection(e11);
      }
      mobileWalletsTemplate() {
        const { mobileWallets: e11 } = S2.state, t8 = T2.walletsWithInjected(e11);
        if (t8.length)
          return t8.map(({ id: o11, name: r7, links: { universal: a9, native: n8 } }) => x4`<w3m-wallet-button name="${r7}" walletId="${o11}" .onClick="${async () => s7.handleMobileLinking({ links: { native: n8, universal: a9 }, name: r7, id: o11 })}"></w3m-wallet-button>`);
      }
      previewWalletsTemplate() {
        const { previewWallets: e11 } = _3.state;
        let t8 = T2.walletsWithInjected(e11);
        return t8 = T2.allowedExplorerListings(t8), t8 = T2.deduplicateExplorerListingsFromConnectors(t8), t8.map(({ image_url: o11, name: r7, mobile: { native: a9, universal: n8 }, id: l9 }) => x4`<w3m-wallet-button name="${r7}" src="${o11.lg}" .onClick="${async () => s7.handleMobileLinking({ links: { native: a9, universal: n8 }, name: r7, id: l9, image: o11.lg })}"></w3m-wallet-button>`);
      }
      connectorWalletsTemplate() {
        let e11 = T2.connectorWallets();
        return window.ethereum || (e11 = e11.filter(({ id: t8 }) => t8 !== "injected" && t8 !== ie4.metaMask)), e11.map(({ name: t8, id: o11, ready: r7 }) => x4`<w3m-wallet-button .installed="${["injected", "metaMask"].includes(o11) && r7}" name="${t8}" walletId="${o11}" .onClick="${async () => this.onConnectorWallet(o11)}"></w3m-wallet-button>`);
      }
      recentWalletTemplate() {
        const e11 = s7.getRecentWallet();
        if (!e11)
          return;
        const { id: t8, name: o11, links: r7, image: a9 } = e11;
        return x4`<w3m-wallet-button .recent="${true}" name="${o11}" walletId="${l6(t8)}" src="${l6(a9)}" .onClick="${async () => s7.handleMobileLinking({ name: o11, id: t8, links: r7, image: a9 })}"></w3m-wallet-button>`;
      }
      render() {
        const { standaloneUri: e11 } = i2.state, t8 = this.connectorWalletsTemplate(), o11 = this.mobileWalletsTemplate(), r7 = this.previewWalletsTemplate(), a9 = this.recentWalletTemplate(), n8 = o11 ?? r7, l9 = [...t8, ...n8], w11 = T2.walletTemplatesWithRecent(l9, a9), g9 = T2.walletTemplatesWithRecent(n8, a9), I9 = e11 ? g9 : w11, Z5 = I9.length > 8;
        let $10 = [];
        Z5 ? $10 = I9.slice(0, 7) : $10 = I9;
        const W5 = $10.slice(0, 4), se4 = $10.slice(4, 8), z8 = !!$10.length;
        return x4`<w3m-modal-header title="Connect your wallet" .onAction="${this.onGoToQrcode}" .actionIcon="${p5.QRCODE_ICON}"></w3m-modal-header>${z8 ? x4`<w3m-modal-content><div class="w3m-grid">${W5} ${se4.length ? x4`${se4} ${Z5 ? x4`<w3m-view-all-wallets-button></w3m-view-all-wallets-button>` : null}` : null}</div></w3m-modal-content>` : null}`;
      }
    };
    tt3.styles = [m5.globalCss, Zo], tt3 = Bo([e5("w3m-mobile-wallet-selection")], tt3);
    Vo = i3`:host{all:initial}.w3m-overlay{inset:0;position:fixed;z-index:var(--w3m-z-index);overflow:hidden;display:flex;justify-content:center;align-items:center;background-color:rgba(0,0,0,.3);opacity:0;pointer-events:none}@media(max-height:720px) and (orientation:landscape){.w3m-overlay{overflow:scroll;align-items:flex-start}}.w3m-open{pointer-events:auto}.w3m-container{position:relative;max-width:360px;width:100%;outline:0;border-radius:var(--w3m-background-border-radius) var(--w3m-background-border-radius) var(--w3m-container-border-radius) var(--w3m-container-border-radius);border:1px solid var(--w3m-color-overlay);overflow:hidden}.w3m-card{width:100%;position:relative;border-radius:var(--w3m-container-border-radius);overflow:hidden;box-shadow:0 6px 14px -6px rgba(10,16,31,.12),0 10px 32px -4px rgba(10,16,31,.1),0 0 0 1px var(--w3m-color-overlay);background-color:var(--w3m-color-bg-1);color:var(--w3m-color-fg-1)}@media(max-width:600px){.w3m-container{max-width:440px;border-radius:var(--w3m-background-border-radius) var(--w3m-background-border-radius) 0 0}.w3m-card{border-radius:var(--w3m-container-border-radius) var(--w3m-container-border-radius) 0 0}.w3m-overlay{align-items:flex-end}}@media(max-width:440px){.w3m-container{border:0}}`;
    Uo = Object.defineProperty;
    zo = Object.getOwnPropertyDescriptor;
    Wt = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? zo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Uo(t8, o11, a9), a9;
    };
    Le4 = class extends s6 {
      constructor() {
        super(), this.open = false, this.unsubscribeModal = void 0, this.abortController = void 0, this.unsubscribeModal = x3.subscribe((e11) => {
          e11.open ? this.onOpenModalEvent() : this.onCloseModalEvent();
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeModal) == null || e11.call(this);
      }
      get overlayEl() {
        return s7.getShadowRootElement(this, ".w3m-overlay");
      }
      get containerEl() {
        return s7.getShadowRootElement(this, ".w3m-container");
      }
      toggleBodyScroll(e11) {
        if (document.querySelector("body"))
          if (e11) {
            const t8 = document.getElementById("w3m-styles");
            t8?.remove();
          } else
            document.head.insertAdjacentHTML("beforeend", '<style id="w3m-styles">html,body{touch-action:none;overflow:hidden;overscroll-behavior:contain;}</style>');
      }
      onCloseModal(e11) {
        e11.target === e11.currentTarget && x3.close();
      }
      async onOpenModalEvent() {
        this.toggleBodyScroll(false);
        const e11 = 0.2;
        await animate2(this.containerEl, { y: 0 }, { duration: 0 }).finished, animate2(this.overlayEl, { opacity: [0, 1] }, { duration: 0.2, delay: e11 }), animate2(this.containerEl, s7.isMobileAnimation() ? { y: ["50vh", 0] } : { scale: [0.98, 1] }, { scale: { easing: spring2({ velocity: 0.4 }) }, y: { easing: spring2({ mass: 0.5 }) }, delay: e11 }), this.addKeyboardEvents(), this.open = true;
      }
      async onCloseModalEvent() {
        this.toggleBodyScroll(true), this.removeKeyboardEvents(), await Promise.all([animate2(this.containerEl, s7.isMobileAnimation() ? { y: [0, "50vh"] } : { scale: [1, 0.98] }, { scale: { easing: spring2({ velocity: 0 }) }, y: { easing: spring2({ mass: 0.5 }) } }).finished, animate2(this.overlayEl, { opacity: [1, 0] }, { duration: 0.2 }).finished]), this.open = false;
      }
      addKeyboardEvents() {
        this.abortController = new AbortController(), window.addEventListener("keydown", (e11) => {
          var t8;
          e11.key === "Escape" ? x3.close() : e11.key === "Tab" && ((t8 = e11.target) != null && t8.tagName.includes("W3M-") || this.containerEl.focus());
        }, this.abortController), this.containerEl.focus();
      }
      removeKeyboardEvents() {
        var e11;
        (e11 = this.abortController) == null || e11.abort(), this.abortController = void 0;
      }
      managedModalContextTemplate() {
        const { isStandalone: e11 } = i2.state;
        return e11 ? null : x4`<w3m-account-context></w3m-account-context><w3m-network-context></w3m-network-context>`;
      }
      render() {
        const e11 = { "w3m-overlay": true, "w3m-open": this.open };
        return x4`<w3m-explorer-context></w3m-explorer-context><w3m-theme-context></w3m-theme-context>${this.managedModalContextTemplate()}<div id="w3m-modal" class="${o8(e11)}" @click="${this.onCloseModal}" role="alertdialog" aria-modal="true"><div class="w3m-container" tabindex="0">${this.open ? x4`<w3m-modal-backcard></w3m-modal-backcard><div class="w3m-card"><w3m-modal-router></w3m-modal-router><w3m-modal-toast></w3m-modal-toast></div>` : null}</div></div>`;
      }
    };
    Le4.styles = [m5.globalCss, Vo], Wt([t4()], Le4.prototype, "open", 2), Le4 = Wt([e5("w3m-modal")], Le4);
    Go = i3`:host{all:initial}w3m-network-image{margin-left:-6px;margin-right:6px;width:28px;height:28px}`;
    Fo = Object.defineProperty;
    Ko = Object.getOwnPropertyDescriptor;
    Te3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ko(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Fo(t8, o11, a9), a9;
    };
    ne5 = class extends s6 {
      constructor() {
        super(), this.chainId = "", this.label = "", this.wrongNetwork = false, this.unsubscribeNetwork = void 0, s7.rejectStandaloneButtonComponent();
        const { selectedChain: e11 } = i2.state;
        this.onSetChainData(e11), this.unsubscribeNetwork = i2.subscribe(({ selectedChain: t8 }) => {
          this.onSetChainData(t8);
        });
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.unsubscribeNetwork) == null || e11.call(this);
      }
      onSetChainData(e11) {
        if (e11) {
          const { chains: t8 } = i2.state, o11 = t8?.map((r7) => r7.id);
          this.chainId = e11.id.toString(), this.wrongNetwork = !(o11 != null && o11.includes(e11.id)), this.label = this.wrongNetwork ? "Wrong Network" : e11.name;
        }
      }
      onClick() {
        x3.open({ route: "SelectNetwork" });
      }
      render() {
        var e11;
        const { chains: t8 } = i2.state, o11 = t8 && t8.length > 1;
        return x4`<w3m-button-big @click="${this.onClick}" ?disabled="${!o11}"><w3m-network-image chainId="${l6(this.chainId)}"></w3m-network-image><w3m-text variant="medium-regular" color="inverse">${(e11 = this.label) != null && e11.length ? this.label : "Select Network"}</w3m-text></w3m-button-big>`;
      }
    };
    ne5.styles = [m5.globalCss, Go], Te3([t4()], ne5.prototype, "chainId", 2), Te3([t4()], ne5.prototype, "label", 2), Te3([t4()], ne5.prototype, "wrongNetwork", 2), ne5 = Te3([e5("w3m-network-switch")], ne5);
    qo = i3`button{display:flex;flex-direction:column;padding:5px 10px;border-radius:var(--w3m-button-hover-highlight-border-radius);transition:background-color .2s ease;height:100%;justify-content:flex-start}.w3m-icons{width:60px;height:60px;display:flex;flex-wrap:wrap;padding:7px;border-radius:var(--w3m-wallet-icon-border-radius);justify-content:space-between;align-items:center;margin-bottom:5px;background-color:var(--w3m-color-bg-2);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay)}button:hover{background-color:var(--w3m-color-overlay)}.w3m-icons img{width:21px;height:21px;object-fit:cover;object-position:center;border-radius:calc(var(--w3m-wallet-icon-border-radius)/ 2);border:1px solid var(--w3m-color-overlay)}.w3m-icons svg{width:21px;height:21px}.w3m-icons img:nth-child(1),.w3m-icons img:nth-child(2),.w3m-icons svg:nth-child(1),.w3m-icons svg:nth-child(2){margin-bottom:4px}w3m-text{width:100%;text-align:center}#wallet-placeholder-fill{fill:var(--w3m-color-bg-3)}#wallet-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
    Qo = Object.defineProperty;
    Yo = Object.getOwnPropertyDescriptor;
    Xo = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Yo(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Qo(t8, o11, a9), a9;
    };
    at3 = class extends s6 {
      onClick() {
        g4.push("WalletExplorer");
      }
      render() {
        const { previewWallets: e11 } = _3.state, t8 = s7.getCustomWallets(), o11 = [...e11, ...t8].reverse().slice(0, 4);
        return x4`<button @click="${this.onClick}"><div class="w3m-icons">${o11.map((r7) => {
          var a9;
          const n8 = (a9 = r7.image_url) == null ? void 0 : a9.lg;
          if (n8)
            return x4`<img src="${n8}">`;
          const l9 = s7.getWalletId(r7.id), w11 = s7.getWalletIcon(l9);
          return w11 ? x4`<img src="${w11}">` : p5.WALLET_PLACEHOLDER;
        })}</div><w3m-text variant="xsmall-regular">View All</w3m-text></button>`;
      }
    };
    at3.styles = [m5.globalCss, qo], at3 = Xo([e5("w3m-view-all-wallets-button")], at3);
    Jo = i3`.w3m-qr-container{width:100%;display:flex;justify-content:center;align-items:center;aspect-ratio:1/1}`;
    er2 = Object.defineProperty;
    tr2 = Object.getOwnPropertyDescriptor;
    Mt = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? tr2(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && er2(t8, o11, a9), a9;
    };
    Ne3 = class extends s6 {
      constructor() {
        super(), this.uri = "", this.createConnectionAndWait();
      }
      get overlayEl() {
        return s7.getShadowRootElement(this, ".w3m-qr-container");
      }
      async createConnectionAndWait(e11 = 0) {
        var t8;
        d2.removeWalletConnectDeepLink();
        try {
          const { standaloneUri: o11 } = i2.state;
          o11 ? setTimeout(() => this.uri = o11, 0) : (await p3.client().connectWalletConnect((r7) => this.uri = r7, (t8 = i2.state.selectedChain) == null ? void 0 : t8.id), x3.close());
        } catch (o11) {
          console.error(o11), H5.openToast("Connection request declined", "error"), e11 < 2 && this.createConnectionAndWait(e11 + 1);
        }
      }
      render() {
        return x4`<div class="w3m-qr-container">${this.uri ? x4`<w3m-qrcode size="${this.overlayEl.offsetWidth}" uri="${this.uri}"></w3m-qrcode>` : x4`<w3m-spinner></w3m-spinner>`}</div>`;
      }
    };
    Ne3.styles = [m5.globalCss, Jo], Mt([t4()], Ne3.prototype, "uri", 2), Ne3 = Mt([e5("w3m-walletconnect-qr")], Ne3);
    ar2 = i3`.w3m-profile{display:flex;justify-content:space-between;align-items:flex-start;padding-top:20px}.w3m-connection-badge{background-color:var(--w3m-color-bg-2);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);padding:6px 10px 6px 26px;position:relative;border-radius:28px}.w3m-connection-badge::before{content:'';position:absolute;width:10px;height:10px;left:10px;background-color:var(--w3m-success-color);border-radius:50%;top:50%;margin-top:-5px;box-shadow:0 1px 4px 1px var(--w3m-success-color),inset 0 0 0 1px var(--w3m-color-overlay)}.w3m-footer{display:flex;justify-content:space-between}w3m-address-text{margin-top:10px;display:block}.w3m-balance{border-top:1px solid var(--w3m-color-bg-2);padding:11px 20px}`;
    or3 = Object.defineProperty;
    rr2 = Object.getOwnPropertyDescriptor;
    lr2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? rr2(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && or3(t8, o11, a9), a9;
    };
    ot3 = class extends s6 {
      onDisconnect() {
        x3.close(), p3.client().disconnect(), A4.resetAccount();
      }
      async onCopyAddress() {
        var e11;
        await navigator.clipboard.writeText((e11 = A4.state.address) != null ? e11 : ""), H5.openToast("Address copied", "success");
      }
      render() {
        return x4`<w3m-modal-content><div class="w3m-profile"><div class="w3m-info"><w3m-avatar size="medium"></w3m-avatar><w3m-address-text variant="modal"></w3m-address-text></div><div class="w3m-connection-badge"><w3m-text variant="small-regular" color="secondary">Connected</w3m-text></div></div></w3m-modal-content><div class="w3m-balance"><w3m-balance></w3m-balance></div><w3m-modal-footer><div class="w3m-footer"><w3m-account-network-button></w3m-account-network-button><w3m-box-button label="Copy Address" .onClick="${this.onCopyAddress}" .icon="${p5.ACCOUNT_COPY}"></w3m-box-button><w3m-box-button label="Disconnect" .onClick="${this.onDisconnect}" .icon="${p5.ACCOUNT_DISCONNECT}"></w3m-box-button></div></w3m-modal-footer>`;
      }
    };
    ot3.styles = [m5.globalCss, ar2], ot3 = lr2([e5("w3m-account-view")], ot3);
    nr2 = Object.defineProperty;
    ir2 = Object.getOwnPropertyDescriptor;
    sr2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ir2(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && nr2(t8, o11, a9), a9;
    };
    rt3 = class extends s6 {
      viewTemplate() {
        return d2.isAndroid() ? x4`<w3m-android-wallet-selection></w3m-android-wallet-selection>` : d2.isMobile() ? x4`<w3m-mobile-wallet-selection></w3m-mobile-wallet-selection>` : x4`<w3m-desktop-wallet-selection></w3m-desktop-wallet-selection>`;
      }
      render() {
        return x4`${this.viewTemplate()}<w3m-legal-notice></w3m-legal-notice>`;
      }
    };
    rt3.styles = [m5.globalCss], rt3 = sr2([e5("w3m-connect-wallet-view")], rt3);
    cr2 = i3`.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}`;
    dr2 = Object.defineProperty;
    mr = Object.getOwnPropertyDescriptor;
    hr2 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? mr(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && dr2(t8, o11, a9), a9;
    };
    lt3 = class extends s6 {
      async onConnectorWallet(e11) {
        await s7.handleConnectorConnection(e11);
      }
      connectorWalletsTemplate() {
        let e11 = T2.connectorWallets();
        return window.ethereum || (e11 = e11.filter(({ id: t8 }) => t8 !== "injected" && t8 !== ie4.metaMask)), e11.map(({ name: t8, id: o11, ready: r7 }) => x4`<w3m-wallet-button .installed="${["injected", "metaMask"].includes(o11) && r7}" name="${t8}" walletId="${o11}" .onClick="${async () => this.onConnectorWallet(o11)}"></w3m-wallet-button>`);
      }
      render() {
        const e11 = this.connectorWalletsTemplate();
        return x4`<w3m-modal-header title="Other wallets"></w3m-modal-header><w3m-modal-content><div class="w3m-grid">${e11}</div></w3m-modal-content>`;
      }
    };
    lt3.styles = [m5.globalCss, cr2], lt3 = hr2([e5("w3m-connectors-view")], lt3);
    wr = i3`.w3m-wrapper{display:flex;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1;flex-direction:column}.w3m-connecting-title{display:flex;align-items:center;justify-content:center;margin-bottom:16px}w3m-spinner{margin-right:10px}w3m-wallet-image{border-radius:var(--w3m-wallet-icon-border-radius);width:25%;aspect-ratio:1/1;margin-bottom:20px}.w3m-install-actions{display:flex}.w3m-install-actions w3m-button{margin:0 5px;opacity:1}`;
    pr = Object.defineProperty;
    ur2 = Object.getOwnPropertyDescriptor;
    Et3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? ur2(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && pr(t8, o11, a9), a9;
    };
    _e2 = class extends s6 {
      constructor() {
        super(), this.uri = "", this.createConnectionAndWait();
      }
      getRouterData() {
        var e11;
        const t8 = (e11 = g4.state.data) == null ? void 0 : e11.DesktopConnector;
        if (!t8)
          throw new Error("Missing router data");
        return t8;
      }
      onFormatAndRedirect(e11) {
        const { native: t8, universal: o11, name: r7 } = this.getRouterData();
        if (t8) {
          const a9 = d2.formatNativeUrl(t8, e11, r7);
          d2.openHref(a9, "_self");
        } else if (o11) {
          const a9 = d2.formatUniversalUrl(o11, e11, r7);
          d2.openHref(a9, "_blank");
        }
      }
      async createConnectionAndWait(e11 = 0) {
        var t8;
        d2.removeWalletConnectDeepLink();
        const { standaloneUri: o11 } = i2.state, { name: r7, walletId: a9, native: n8, universal: l9, icon: w11 } = this.getRouterData(), g9 = { name: r7, id: a9, links: { native: n8, universal: l9 }, image: w11 };
        if (o11)
          s7.setRecentWallet(g9), this.onFormatAndRedirect(o11);
        else
          try {
            await p3.client().connectWalletConnect((I9) => {
              this.uri = I9, this.onFormatAndRedirect(I9);
            }, (t8 = i2.state.selectedChain) == null ? void 0 : t8.id), s7.setRecentWallet(g9), x3.close();
          } catch {
            H5.openToast("Connection request declined", "error"), e11 < 2 && this.createConnectionAndWait(e11 + 1);
          }
      }
      onConnectWithMobile() {
        g4.push("Qrcode");
      }
      onGoToWallet() {
        const { universal: e11, name: t8 } = this.getRouterData();
        if (e11) {
          const o11 = d2.formatUniversalUrl(e11, this.uri, t8);
          d2.openHref(o11, "_blank");
        }
      }
      render() {
        const { name: e11, icon: t8, universal: o11, walletId: r7 } = this.getRouterData(), a9 = s7.getWalletName(e11);
        return x4`<w3m-modal-header title="${a9}"></w3m-modal-header><w3m-modal-content><div class="w3m-wrapper">${t8 ? x4`<w3m-wallet-image src="${t8}" size="lg"></w3m-wallet-image>` : x4`<w3m-wallet-image size="lg" walletid="${l6(r7)}"></w3m-wallet-image>`}<div class="w3m-connecting-title"><w3m-spinner></w3m-spinner><w3m-text variant="big-bold" color="secondary">${`Continue in ${a9}...`}</w3m-text></div><div class="w3m-install-actions"><w3m-button .onClick="${async () => this.createConnectionAndWait()}" .iconRight="${p5.RETRY_ICON}">Retry</w3m-button>${o11 ? x4`<w3m-button .onClick="${this.onGoToWallet.bind(this)}" .iconLeft="${p5.ARROW_UP_RIGHT_ICON}">Go to Wallet</w3m-button>` : x4`<w3m-button .onClick="${this.onConnectWithMobile}" .iconLeft="${p5.MOBILE_ICON}">Connect with Mobile</w3m-button>`}</div></div></w3m-modal-content>`;
      }
    };
    _e2.styles = [m5.globalCss, wr], Et3([t4()], _e2.prototype, "uri", 2), _e2 = Et3([e5("w3m-desktop-connector-view")], _e2);
    gr2 = i3`.w3m-info-text{margin:5px 0 15px;max-width:320px;text-align:center}.w3m-wallet-item{margin:0 -20px 0 0;padding-right:20px;display:flex;align-items:center;border-bottom:1px solid var(--w3m-color-bg-2)}.w3m-wallet-item:last-child{margin-bottom:-20px;border-bottom:0}.w3m-wallet-content{margin-left:20px;height:60px;display:flex;flex:1;align-items:center;justify-content:space-between}.w3m-footer-actions{display:flex;flex-direction:column;align-items:center;padding:20px 0;border-top:1px solid var(--w3m-color-bg-2)}w3m-wallet-image{display:block;width:40px;height:40px;border-radius:10px}`;
    vr = Object.defineProperty;
    br = Object.getOwnPropertyDescriptor;
    fr = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? br(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && vr(t8, o11, a9), a9;
    };
    nt3 = class extends s6 {
      onGet(e11) {
        d2.openHref(e11, "_blank");
      }
      render() {
        const { recomendedWallets: e11 } = _3.state, t8 = s7.getCustomWallets().slice(0, 6), o11 = e11.length, r7 = t8.length;
        return x4`<w3m-modal-header title="Get a wallet"></w3m-modal-header><w3m-modal-content>${o11 ? e11.map(({ name: a9, image_url: n8, homepage: l9 }) => x4`<div class="w3m-wallet-item"><w3m-wallet-image src="${n8.lg}"></w3m-wallet-image><div class="w3m-wallet-content"><w3m-text variant="medium-regular">${a9}</w3m-text><w3m-button .iconRight="${p5.ARROW_RIGHT_ICON}" .onClick="${() => this.onGet(l9)}">Get</w3m-button></div></div>`) : null} ${r7 ? t8.map(({ name: a9, id: n8, links: l9 }) => x4`<div class="w3m-wallet-item"><w3m-wallet-image walletId="${n8}"></w3m-wallet-image><div class="w3m-wallet-content"><w3m-text variant="medium-regular">${a9}</w3m-text><w3m-button .iconRight="${p5.ARROW_RIGHT_ICON}" .onClick="${() => this.onGet(l9.universal)}">Get</w3m-button></div></div>`) : null}</w3m-modal-content><div class="w3m-footer-actions"><w3m-text variant="medium-regular">Not what you're looking for?</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">With hundreds of wallets out there, there's something for everyone</w3m-text><w3m-button .onClick="${s7.openWalletExplorerUrl}" .iconRight="${p5.ARROW_UP_RIGHT_ICON}">Explore Wallets</w3m-button></div>`;
      }
    };
    nt3.styles = [m5.globalCss, gr2], nt3 = fr([e5("w3m-get-wallet-view")], nt3);
    xr = i3`.w3m-footer-actions{display:flex;justify-content:center}.w3m-footer-actions w3m-button{margin:0 5px}.w3m-info-container{display:flex;flex-direction:column;justify-content:center;align-items:center;margin-bottom:20px}.w3m-info-container:last-child{margin-bottom:0}.w3m-info-text{margin-top:5px;text-align:center}.w3m-images svg{margin:0 2px 5px;width:55px;height:55px}.help-img-highlight{stroke:var(--w3m-color-overlay)}`;
    yr = Object.defineProperty;
    Cr = Object.getOwnPropertyDescriptor;
    kr = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Cr(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && yr(t8, o11, a9), a9;
    };
    it3 = class extends s6 {
      constructor() {
        super(...arguments), this.learnUrl = "https://ethereum.org/en/wallets/";
      }
      onGet() {
        S2.state.enableExplorer ? g4.push("GetWallet") : s7.openWalletExplorerUrl();
      }
      onLearnMore() {
        d2.openHref(this.learnUrl, "_blank");
      }
      render() {
        return x4`<w3m-modal-header title="What is a wallet?"></w3m-modal-header><w3m-modal-content><div class="w3m-info-container"><div class="w3m-images">${p5.HELP_CHART_IMG} ${p5.HELP_PAINTING_IMG} ${p5.HELP_ETH_IMG}</div><w3m-text variant="medium-regular">A home for your digital assets</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs.</w3m-text></div><div class="w3m-info-container"><div class="w3m-images">${p5.HELP_KEY_IMG} ${p5.HELP_USER_IMG} ${p5.HELP_LOCK_IMG}</div><w3m-text variant="medium-regular">One login for all of web3</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">Log in to any app by connecting your wallet. Say goodbye to countless passwords!</w3m-text></div><div class="w3m-info-container"><div class="w3m-images">${p5.HELP_COMPAS_IMG} ${p5.HELP_NOUN_IMG} ${p5.HELP_DAO_IMG}</div><w3m-text variant="medium-regular">Your gateway to a new web</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more.</w3m-text></div><div class="w3m-footer-actions"><w3m-button .onClick="${this.onGet.bind(this)}" .iconLeft="${p5.WALLET_ICON}">Get a Wallet</w3m-button><w3m-button .onClick="${this.onLearnMore.bind(this)}" .iconRight="${p5.ARROW_UP_RIGHT_ICON}">Learn More</w3m-button></div></w3m-modal-content>`;
      }
    };
    it3.styles = [m5.globalCss, xr], it3 = kr([e5("w3m-help-view")], it3);
    $r = i3`.w3m-injected-wrapper{display:flex;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1;flex-direction:column}.w3m-connecting-title{display:flex;align-items:center;justify-content:center;margin-bottom:20px}w3m-spinner{margin-right:10px}w3m-wallet-image{border-radius:var(--w3m-wallet-icon-border-radius);width:25%;aspect-ratio:1/1;margin-bottom:20px}w3m-button{opacity:0}.w3m-injected-error w3m-button{opacity:1}`;
    Or = Object.defineProperty;
    Ir = Object.getOwnPropertyDescriptor;
    st3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ir(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Or(t8, o11, a9), a9;
    };
    ye3 = class extends s6 {
      constructor() {
        super(), this.connecting = true, this.error = false, this.connector = p3.client().getConnectorById("injected"), this.onConnect();
      }
      async onConnect() {
        const { ready: e11 } = this.connector;
        e11 && (this.error = false, this.connecting = true, await s7.handleConnectorConnection("injected", () => {
          this.error = true, this.connecting = false;
        }));
      }
      render() {
        const e11 = s7.getWalletName(this.connector.name), t8 = s7.getWalletId(this.connector.id), o11 = { "w3m-injected-wrapper": true, "w3m-injected-error": this.error };
        return x4`<w3m-modal-header title="${e11}"></w3m-modal-header><w3m-modal-content><div class="${o8(o11)}"><w3m-wallet-image walletId="${t8}" size="lg"></w3m-wallet-image><div class="w3m-connecting-title">${this.connecting ? x4`<w3m-spinner></w3m-spinner>` : null}<w3m-text variant="big-bold" color="${this.error ? "error" : "secondary"}">${this.error ? "Connection declined" : `Continue in ${e11}...`}</w3m-text></div><w3m-button .onClick="${this.onConnect.bind(this)}" .disabled="${!this.error}" .iconRight="${p5.RETRY_ICON}">Try Again</w3m-button></div></w3m-modal-content>`;
      }
    };
    ye3.styles = [m5.globalCss, $r], st3([t4()], ye3.prototype, "connecting", 2), st3([t4()], ye3.prototype, "error", 2), ye3 = st3([e5("w3m-injected-connector-view")], ye3);
    Wr = i3`.w3m-injected-wrapper{display:flex;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1;flex-direction:column}.w3m-connecting-title{display:flex;align-items:center;justify-content:center;margin-bottom:16px}.w3m-install-title{display:flex;align-items:center;justify-content:center;flex-direction:column}.w3m-install-title w3m-text:last-child{margin-top:10px;max-width:240px}.w3m-install-actions{display:flex;margin-top:15px;align-items:center;flex-direction:column}@media(max-width:355px){.w3m-install-actions{flex-direction:column;align-items:center}}w3m-wallet-image{border-radius:15px;width:25%;aspect-ratio:1/1;margin-bottom:20px}w3m-button{opacity:0}.w3m-install-actions w3m-button{margin:5px;opacity:1}.w3m-info-text{text-align:center}`;
    Mr = Object.defineProperty;
    Er = Object.getOwnPropertyDescriptor;
    jr = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Er(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Mr(t8, o11, a9), a9;
    };
    ct3 = class extends s6 {
      getRouterData() {
        var e11;
        const t8 = (e11 = g4.state.data) == null ? void 0 : e11.InstallConnector;
        if (!t8)
          throw new Error("Missing router data");
        return t8;
      }
      onInstall() {
        const { url: e11 } = this.getRouterData();
        d2.openHref(e11, "_blank");
      }
      onMobile() {
        const { name: e11 } = this.getRouterData();
        g4.push("ConnectWallet"), H5.openToast(`Scan the code with ${e11}`, "success");
      }
      render() {
        const { name: e11, id: t8, isMobile: o11 } = this.getRouterData();
        return x4`<w3m-modal-header title="${e11}"></w3m-modal-header><w3m-modal-content><div class="w3m-injected-wrapper"><w3m-wallet-image walletId="${t8}" size="lg"></w3m-wallet-image><div class="w3m-install-title"><w3m-text variant="big-bold">Install ${e11}</w3m-text><w3m-text color="secondary" variant="small-thin" class="w3m-info-text">To connect ${e11}, install the browser extension.</w3m-text></div><div class="w3m-install-actions"><w3m-button .onClick="${this.onInstall.bind(this)}" .iconLeft="${p5.ARROW_DOWN_ICON}">Install Extension</w3m-button>${o11 ? x4`<w3m-button .onClick="${this.onMobile.bind(this)}" .iconLeft="${p5.MOBILE_ICON}">${e11} Mobile</w3m-button>` : null}</div></div></w3m-modal-content>`;
      }
    };
    ct3.styles = [m5.globalCss, Wr], ct3 = jr([e5("w3m-install-connector-view")], ct3);
    Pr = Object.defineProperty;
    Ar = Object.getOwnPropertyDescriptor;
    Lr = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Ar(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Pr(t8, o11, a9), a9;
    };
    dt3 = class extends s6 {
      render() {
        return x4`<w3m-modal-header title="Scan the code" .onAction="${s7.handleUriCopy}" .actionIcon="${p5.COPY_ICON}"></w3m-modal-header><w3m-modal-content><w3m-walletconnect-qr></w3m-walletconnect-qr></w3m-modal-content>`;
      }
    };
    dt3.styles = [m5.globalCss], dt3 = Lr([e5("w3m-qrcode-view")], dt3);
    Tr = i3`.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);margin:-5px -10px;justify-content:space-between}`;
    Nr = Object.defineProperty;
    _r = Object.getOwnPropertyDescriptor;
    Dr = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? _r(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Nr(t8, o11, a9), a9;
    };
    mt3 = class extends s6 {
      async onSelectChain(e11) {
        try {
          const { selectedChain: t8, walletConnectVersion: o11 } = i2.state, { isConnected: r7 } = A4.state;
          r7 ? t8?.id === e11.id ? g4.replace("Account") : o11 === 2 ? (await p3.client().switchNetwork({ chainId: e11.id }), g4.replace("Account")) : g4.push("SwitchNetwork", { SwitchNetwork: e11 }) : (g4.push("ConnectWallet"), i2.setSelectedChain(e11));
        } catch (t8) {
          console.error(t8), H5.openToast(s7.getErrorMessage(t8), "error");
        }
      }
      render() {
        const { chains: e11 } = i2.state;
        return x4`<w3m-modal-header title="Select network"></w3m-modal-header><w3m-modal-content><div class="w3m-grid">${e11?.map((t8) => x4`<w3m-network-button name="${t8.name}" chainId="${t8.id}" .onClick="${async () => this.onSelectChain(t8)}">${t8.name}</w3m-network-button>`)}</div></w3m-modal-content>`;
      }
    };
    mt3.styles = [m5.globalCss, Tr], mt3 = Dr([e5("w3m-select-network-view")], mt3);
    Rr = i3`.w3m-wrapper{display:flex;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1;flex-direction:column}.w3m-connecting-title{display:flex;align-items:center;justify-content:center;margin-bottom:16px}w3m-spinner{margin-right:10px}w3m-network-image{width:96px;height:96px;margin-bottom:20px}w3m-button{opacity:0}.w3m-error w3m-button{opacity:1}`;
    Zr = Object.defineProperty;
    Hr = Object.getOwnPropertyDescriptor;
    jt = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Hr(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Zr(t8, o11, a9), a9;
    };
    De2 = class extends s6 {
      constructor() {
        super(), this.error = false, this.onSwitchNetwork();
      }
      getRouterData() {
        var e11;
        const t8 = (e11 = g4.state.data) == null ? void 0 : e11.SwitchNetwork;
        if (!t8)
          throw new Error("Missing router data");
        return t8;
      }
      async onSwitchNetwork() {
        try {
          this.error = false;
          const e11 = this.getRouterData();
          await p3.client().switchNetwork({ chainId: e11.id }), i2.setSelectedChain(e11), g4.replace("Account");
        } catch {
          this.error = true;
        }
      }
      render() {
        const { id: e11, name: t8 } = this.getRouterData(), o11 = { "w3m-wrapper": true, "w3m-error": this.error };
        return x4`<w3m-modal-header title="${`Connect to ${t8}`}"></w3m-modal-header><w3m-modal-content><div class="${o8(o11)}"><w3m-network-image chainId="${e11}"></w3m-network-image><div class="w3m-connecting-title">${this.error ? null : x4`<w3m-spinner></w3m-spinner>`}<w3m-text variant="big-bold" color="${this.error ? "error" : "secondary"}">${this.error ? "Connection declined" : "Approve in your wallet"}</w3m-text></div><w3m-button .onClick="${this.onSwitchNetwork.bind(this)}" .disabled="${!this.error}" .iconRight="${p5.RETRY_ICON}">Try Again</w3m-button></div></w3m-modal-content>`;
      }
    };
    De2.styles = [m5.globalCss, Rr], jt([t4()], De2.prototype, "error", 2), De2 = jt([e5("w3m-switch-network-view")], De2);
    Sr = i3`w3m-modal-content{height:clamp(200px,60vh,600px);display:block;overflow:scroll;scrollbar-width:none;position:relative;margin-top:1px}.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between;margin:-15px -10px;padding-top:20px}w3m-modal-content::after,w3m-modal-content::before{content:'';position:fixed;pointer-events:none;z-index:1;width:100%;height:20px;opacity:1}w3m-modal-content::before{box-shadow:0 -1px 0 0 var(--w3m-color-bg-1);background:linear-gradient(var(--w3m-color-bg-1),rgba(255,255,255,0))}w3m-modal-content::after{box-shadow:0 1px 0 0 var(--w3m-color-bg-1);background:linear-gradient(rgba(255,255,255,0),var(--w3m-color-bg-1));top:calc(100% - 20px)}w3m-modal-content::-webkit-scrollbar{display:none}.w3m-placeholder-block{display:flex;justify-content:center;align-items:center;height:100px;overflow:hidden}.w3m-empty,.w3m-loading{display:flex}.w3m-loading .w3m-placeholder-block{height:100%}.w3m-end-reached .w3m-placeholder-block{height:0;opacity:0}.w3m-empty .w3m-placeholder-block{opacity:1;height:100%}w3m-wallet-button{margin:calc((100% - 60px)/ 3) 0}`;
    Br = Object.defineProperty;
    Vr = Object.getOwnPropertyDescriptor;
    Ce3 = (e11, t8, o11, r7) => {
      for (var a9 = r7 > 1 ? void 0 : r7 ? Vr(t8, o11) : t8, n8 = e11.length - 1, l9; n8 >= 0; n8--)
        (l9 = e11[n8]) && (a9 = (r7 ? l9(t8, o11, a9) : l9(a9)) || a9);
      return r7 && a9 && Br(t8, o11, a9), a9;
    };
    ht3 = 40;
    X4 = class extends s6 {
      constructor() {
        super(...arguments), this.loading = !_3.state.wallets.listings.length, this.firstFetch = !_3.state.wallets.listings.length, this.search = "", this.endReached = false, this.intersectionObserver = void 0, this.searchDebounce = s7.debounce((e11) => {
          e11.length >= 3 ? (this.firstFetch = true, this.endReached = false, this.search = e11, _3.resetSearch(), this.fetchWallets()) : this.search && (this.search = "", this.endReached = this.isLastPage(), _3.resetSearch());
        });
      }
      firstUpdated() {
        this.createPaginationObserver();
      }
      disconnectedCallback() {
        var e11;
        (e11 = this.intersectionObserver) == null || e11.disconnect();
      }
      get placeholderEl() {
        return s7.getShadowRootElement(this, ".w3m-placeholder-block");
      }
      createPaginationObserver() {
        this.intersectionObserver = new IntersectionObserver(([e11]) => {
          e11.isIntersecting && !(this.search && this.firstFetch) && this.fetchWallets();
        }), this.intersectionObserver.observe(this.placeholderEl);
      }
      isLastPage() {
        const { wallets: e11, search: t8 } = _3.state, { listings: o11, total: r7 } = this.search ? t8 : e11;
        return r7 <= ht3 || o11.length >= r7;
      }
      async fetchWallets() {
        var e11;
        const { wallets: t8, search: o11 } = _3.state, r7 = s7.getExtensionWallets(), { listings: a9, total: n8, page: l9 } = this.search ? o11 : t8;
        if (!this.endReached && (this.firstFetch || n8 > ht3 && a9.length < n8))
          try {
            this.loading = true;
            const w11 = (e11 = i2.state.standaloneChains) == null ? void 0 : e11.join(","), { listings: g9 } = await _3.getPaginatedWallets({ page: this.firstFetch ? 1 : l9 + 1, entries: ht3, device: d2.isMobile() ? "mobile" : "desktop", search: this.search, version: i2.state.walletConnectVersion, chains: w11 }), I9 = g9.map(({ image_url: $10 }) => $10.lg), Z5 = r7.map(({ id: $10 }) => s7.getWalletIcon($10));
            await Promise.all([...I9.map(async ($10) => s7.preloadImage($10)), ...Z5.map(async ($10) => s7.preloadImage($10)), d2.wait(300)]), this.endReached = this.isLastPage();
          } catch (w11) {
            console.error(w11), H5.openToast(s7.getErrorMessage(w11), "error");
          } finally {
            this.loading = false, this.firstFetch = false;
          }
      }
      onConnectCustom({ name: e11, id: t8, links: o11 }) {
        d2.isMobile() ? s7.handleMobileLinking({ links: o11, name: e11, id: t8 }) : g4.push("DesktopConnector", { DesktopConnector: { name: e11, walletId: t8, universal: o11.universal, native: o11.native } });
      }
      onConnectListing(e11) {
        if (d2.isMobile()) {
          const { id: t8, image_url: o11 } = e11, { native: r7, universal: a9 } = e11.mobile;
          s7.handleMobileLinking({ links: { native: r7, universal: a9 }, name: e11.name, id: t8, image: o11.lg });
        } else
          g4.push("DesktopConnector", { DesktopConnector: { name: e11.name, icon: e11.image_url.lg, universal: e11.desktop.universal || e11.homepage, native: e11.desktop.native } });
      }
      onConnectExtension(e11) {
        s7.getWalletId("") === e11.id ? g4.push("InjectedConnector") : g4.push("InstallConnector", { InstallConnector: e11 });
      }
      onSearchChange(e11) {
        const { value: t8 } = e11.target;
        this.searchDebounce(t8);
      }
      render() {
        const { wallets: e11, search: t8 } = _3.state, { isStandalone: o11 } = i2.state;
        let { listings: r7 } = this.search ? t8 : e11;
        r7 = T2.allowedExplorerListings(r7);
        const a9 = this.loading && !r7.length, n8 = this.search.length >= 3;
        let l9 = !o11 && !d2.isMobile() ? s7.getExtensionWallets() : [], w11 = s7.getCustomWallets();
        n8 && (l9 = l9.filter(({ name: $10 }) => s7.caseSafeIncludes($10, this.search)), w11 = w11.filter(({ name: $10 }) => s7.caseSafeIncludes($10, this.search)));
        const g9 = !this.loading && !r7.length && !l9.length, I9 = Math.max(l9.length, r7.length), Z5 = { "w3m-loading": a9, "w3m-end-reached": this.endReached || !this.loading, "w3m-empty": g9 };
        return x4`<w3m-modal-header><w3m-search-input .onChange="${this.onSearchChange.bind(this)}"></w3m-search-input></w3m-modal-header><w3m-modal-content class="${o8(Z5)}"><div class="w3m-grid">${a9 ? null : [...Array(I9)].map(($10, W5) => x4`${w11[W5] ? x4`<w3m-wallet-button name="${w11[W5].name}" walletId="${w11[W5].id}" .onClick="${() => this.onConnectCustom(w11[W5])}"></w3m-wallet-button>` : null} ${l9[W5] ? x4`<w3m-wallet-button name="${l9[W5].name}" walletId="${l9[W5].id}" .onClick="${() => this.onConnectExtension(l9[W5])}"></w3m-wallet-button>` : null} ${r7[W5] ? x4`<w3m-wallet-button src="${r7[W5].image_url.lg}" name="${r7[W5].name}" walletId="${r7[W5].id}" .onClick="${() => this.onConnectListing(r7[W5])}"></w3m-wallet-button>` : null}`)}</div><div class="w3m-placeholder-block">${g9 ? x4`<w3m-text variant="big-bold" color="secondary">No results found</w3m-text>` : null} ${!g9 && this.loading ? x4`<w3m-spinner></w3m-spinner>` : null}</div></w3m-modal-content>`;
      }
    };
    X4.styles = [m5.globalCss, Sr], Ce3([t4()], X4.prototype, "loading", 2), Ce3([t4()], X4.prototype, "firstFetch", 2), Ce3([t4()], X4.prototype, "search", 2), Ce3([t4()], X4.prototype, "endReached", 2), X4 = Ce3([e5("w3m-wallet-explorer-view")], X4);
  }
});

// node_modules/@web3modal/standalone/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  Web3Modal: () => f3
});
var c5, i7, d5, b6, a5, m6, f3;
var init_dist3 = __esm({
  "node_modules/@web3modal/standalone/dist/index.js"() {
    init_dist();
    c5 = Object.defineProperty;
    i7 = Object.getOwnPropertySymbols;
    d5 = Object.prototype.hasOwnProperty;
    b6 = Object.prototype.propertyIsEnumerable;
    a5 = (o11, e11, t8) => e11 in o11 ? c5(o11, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : o11[e11] = t8;
    m6 = (o11, e11) => {
      for (var t8 in e11 || (e11 = {}))
        d5.call(e11, t8) && a5(o11, t8, e11[t8]);
      if (i7)
        for (var t8 of i7(e11))
          b6.call(e11, t8) && a5(o11, t8, e11[t8]);
      return o11;
    };
    f3 = class {
      constructor(e11) {
        this.openModal = x3.open, this.closeModal = x3.close, this.subscribeModal = x3.subscribe, this.setTheme = B3.setThemeConfig, B3.setThemeConfig(e11), S2.setConfig(m6({ enableStandaloneMode: true }, e11)), this.initUi();
      }
      async initUi() {
        if (typeof window < "u") {
          await Promise.resolve().then(() => (init_dist2(), dist_exports));
          const e11 = document.createElement("w3m-modal");
          document.body.insertAdjacentElement("beforeend", e11), i2.setIsUiLoaded(true);
        }
      }
    };
  }
});

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  EthereumProvider: () => Y5,
  OPTIONAL_EVENTS: () => U3,
  OPTIONAL_METHODS: () => D4,
  REQUIRED_EVENTS: () => u6,
  REQUIRED_METHODS: () => p6,
  default: () => m7
});
function C6(a9) {
  return Number(a9[0].split(":")[1]);
}
function w7(a9) {
  return `0x${a9.toString(16)}`;
}
function V5(a9) {
  const { chains: t8, optionalChains: s11, methods: i10, optionalMethods: e11, events: n8, optionalEvents: c8, rpcMap: h11 } = a9;
  if (!I(t8))
    throw new Error("Invalid chains");
  const o11 = t8, r7 = i10 || p6, f7 = n8 || u6, M9 = { [C6(o11)]: h11[C6(o11)] }, E8 = { chains: o11, methods: r7, events: f7, rpcMap: M9 }, l9 = n8?.filter((g9) => !u6.includes(g9)), d9 = i10?.filter((g9) => !p6.includes(g9));
  if (!s11 && !c8 && !e11 && !(l9 != null && l9.length) && !(d9 != null && d9.length))
    return { required: E8 };
  const b10 = l9?.length && d9?.length || !s11, A10 = { chains: [...new Set(b10 ? o11.concat(s11 || []) : s11)], methods: [...new Set(r7.concat(e11 || []))], events: [...new Set(f7.concat(c8 || []))], rpcMap: h11 };
  return { required: E8, optional: A10 };
}
var import_events9, j3, $7, q4, N13, p6, D4, u6, U3, Q4, L4, H7, _5, G6, K4, y6, I6, O5, m7, Y5;
var init_index_es15 = __esm({
  "node_modules/@walletconnect/ethereum-provider/dist/index.es.js"() {
    import_events9 = __toESM(require_events());
    init_index_es();
    init_index_es5();
    j3 = "wc";
    $7 = "ethereum_provider";
    q4 = `${j3}@${2}:${$7}:`;
    N13 = "https://rpc.walletconnect.com/v1/";
    p6 = ["eth_sendTransaction", "personal_sign"];
    D4 = ["eth_accounts", "eth_requestAccounts", "eth_call", "eth_getBalance", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
    u6 = ["chainChanged", "accountsChanged"];
    U3 = ["message", "disconnect", "connect"];
    Q4 = Object.defineProperty;
    L4 = Object.defineProperties;
    H7 = Object.getOwnPropertyDescriptors;
    _5 = Object.getOwnPropertySymbols;
    G6 = Object.prototype.hasOwnProperty;
    K4 = Object.prototype.propertyIsEnumerable;
    y6 = (a9, t8, s11) => t8 in a9 ? Q4(a9, t8, { enumerable: true, configurable: true, writable: true, value: s11 }) : a9[t8] = s11;
    I6 = (a9, t8) => {
      for (var s11 in t8 || (t8 = {}))
        G6.call(t8, s11) && y6(a9, s11, t8[s11]);
      if (_5)
        for (var s11 of _5(t8))
          K4.call(t8, s11) && y6(a9, s11, t8[s11]);
      return a9;
    };
    O5 = (a9, t8) => L4(a9, H7(t8));
    m7 = class {
      constructor() {
        this.events = new import_events9.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = q4, this.on = (t8, s11) => (this.events.on(t8, s11), this), this.once = (t8, s11) => (this.events.once(t8, s11), this), this.removeListener = (t8, s11) => (this.events.removeListener(t8, s11), this), this.off = (t8, s11) => (this.events.off(t8, s11), this), this.parseAccount = (t8) => this.isCompatibleChainId(t8) ? this.parseAccountId(t8).address : t8, this.signer = {}, this.rpc = {};
      }
      static async init(t8) {
        const s11 = new m7();
        return await s11.initialize(t8), s11;
      }
      async request(t8) {
        return await this.signer.request(t8, this.formatChainId(this.chainId));
      }
      sendAsync(t8, s11) {
        this.signer.sendAsync(t8, s11, this.formatChainId(this.chainId));
      }
      get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : false;
      }
      get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : false;
      }
      async enable() {
        return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
      }
      async connect(t8) {
        if (!this.signer.client)
          throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(t8);
        const { required: s11, optional: i10 } = V5(this.rpc);
        try {
          const e11 = await new Promise(async (c8, h11) => {
            var o11;
            this.rpc.showQrModal && ((o11 = this.modal) == null || o11.subscribeModal((r7) => {
              !r7.open && !this.signer.session && (this.signer.abortPairingAttempt(), h11(new Error("Connection request reset. Please try again.")));
            })), await this.signer.connect(O5(I6({ namespaces: { [this.namespace]: s11 } }, i10 && { optionalNamespaces: { [this.namespace]: i10 } }), { pairingTopic: t8?.pairingTopic })).then((r7) => {
              c8(r7);
            }).catch((r7) => {
              h11(new Error(r7.message));
            });
          });
          if (!e11)
            return;
          this.setChainIds(this.rpc.chains);
          const n8 = rn(e11.namespaces, [this.namespace]);
          this.setAccounts(n8), this.events.emit("connect", { chainId: w7(this.chainId) });
        } catch (e11) {
          throw this.signer.logger.error(e11), e11;
        } finally {
          this.modal && this.modal.closeModal();
        }
      }
      async disconnect() {
        this.session && await this.signer.disconnect(), this.reset();
      }
      get isWalletConnect() {
        return true;
      }
      get session() {
        return this.signer.session;
      }
      registerEventListeners() {
        this.signer.on("session_event", (t8) => {
          const { params: s11 } = t8, { event: i10 } = s11;
          i10.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i10.data), this.events.emit("accountsChanged", this.accounts)) : i10.name === "chainChanged" ? this.setChainId(this.formatChainId(i10.data)) : this.events.emit(i10.name, i10.data), this.events.emit("session_event", t8);
        }), this.signer.on("chainChanged", (t8) => {
          const s11 = parseInt(t8);
          this.chainId = s11, this.events.emit("chainChanged", w7(this.chainId)), this.persist();
        }), this.signer.on("session_update", (t8) => {
          this.events.emit("session_update", t8);
        }), this.signer.on("session_delete", (t8) => {
          this.reset(), this.events.emit("session_delete", t8), this.events.emit("disconnect", O5(I6({}, v("USER_DISCONNECTED")), { data: t8.topic, name: "USER_DISCONNECTED" }));
        }), this.signer.on("display_uri", (t8) => {
          var s11, i10;
          this.rpc.showQrModal && ((s11 = this.modal) == null || s11.closeModal(), (i10 = this.modal) == null || i10.openModal({ uri: t8 })), this.events.emit("display_uri", t8);
        });
      }
      setHttpProvider(t8) {
        this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t8.toString(16) }] });
      }
      isCompatibleChainId(t8) {
        return typeof t8 == "string" ? t8.startsWith(`${this.namespace}:`) : false;
      }
      formatChainId(t8) {
        return `${this.namespace}:${t8}`;
      }
      parseChainId(t8) {
        return Number(t8.split(":")[1]);
      }
      setChainIds(t8) {
        const s11 = t8.filter((i10) => this.isCompatibleChainId(i10)).map((i10) => this.parseChainId(i10));
        s11.length && (this.chainId = s11[0], this.events.emit("chainChanged", w7(this.chainId)), this.persist());
      }
      setChainId(t8) {
        if (this.isCompatibleChainId(t8)) {
          const s11 = this.parseChainId(t8);
          this.chainId = s11, this.setHttpProvider(s11);
        }
      }
      parseAccountId(t8) {
        const [s11, i10, e11] = t8.split(":");
        return { chainId: `${s11}:${i10}`, address: e11 };
      }
      setAccounts(t8) {
        this.accounts = t8.filter((s11) => this.parseChainId(this.parseAccountId(s11).chainId) === this.chainId).map((s11) => this.parseAccountId(s11).address), this.events.emit("accountsChanged", this.accounts);
      }
      getRpcConfig(t8) {
        var s11, i10;
        return { chains: ((s11 = t8.chains) == null ? void 0 : s11.map((e11) => this.formatChainId(e11))) || [`${this.namespace}:1`], optionalChains: t8.optionalChains ? t8.optionalChains.map((e11) => this.formatChainId(e11)) : void 0, methods: t8?.methods || p6, events: t8?.events || u6, optionalMethods: t8?.optionalMethods || [], optionalEvents: t8?.optionalEvents || [], rpcMap: t8?.rpcMap || this.buildRpcMap(t8.chains.concat(t8.optionalChains || []), t8.projectId), showQrModal: Boolean(t8?.showQrModal), qrModalOptions: (i10 = t8?.qrModalOptions) != null ? i10 : void 0, projectId: t8.projectId, metadata: t8.metadata };
      }
      buildRpcMap(t8, s11) {
        const i10 = {};
        return t8.forEach((e11) => {
          i10[e11] = this.getRpcUrl(e11, s11);
        }), i10;
      }
      async initialize(t8) {
        if (this.rpc = this.getRpcConfig(t8), this.chainId = C6(this.rpc.chains), this.signer = await pe2.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal)
          try {
            const { Web3Modal: s11 } = await Promise.resolve().then(() => (init_dist3(), dist_exports2));
            this.modal = new s11(I6({ walletConnectVersion: 2, projectId: this.rpc.projectId, standaloneChains: this.rpc.chains }, this.rpc.qrModalOptions));
          } catch {
            throw new Error("To use QR modal, please install @web3modal/standalone package");
          }
      }
      loadConnectOpts(t8) {
        if (!t8)
          return;
        const { chains: s11, optionalChains: i10, rpcMap: e11 } = t8;
        s11 && I(s11) && (this.rpc.chains = s11.map((n8) => this.formatChainId(n8)), s11.forEach((n8) => {
          this.rpc.rpcMap[n8] = e11?.[n8] || this.getRpcUrl(n8);
        })), i10 && I(i10) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i10?.map((n8) => this.formatChainId(n8)), i10.forEach((n8) => {
          this.rpc.rpcMap[n8] = e11?.[n8] || this.getRpcUrl(n8);
        }));
      }
      getRpcUrl(t8, s11) {
        var i10;
        return ((i10 = this.rpc.rpcMap) == null ? void 0 : i10[t8]) || `${N13}?chainId=eip155:${t8}&projectId=${s11 || this.rpc.projectId}`;
      }
      async loadPersistedSession() {
        if (!this.session)
          return;
        const t8 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);
        this.setChainIds(t8 ? [this.formatChainId(t8)] : this.session.namespaces[this.namespace].accounts), this.setAccounts(this.session.namespaces[this.namespace].accounts);
      }
      reset() {
        this.chainId = 1, this.accounts = [];
      }
      persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
      }
      parseAccounts(t8) {
        return typeof t8 == "string" || t8 instanceof String ? [this.parseAccount(t8)] : t8.map((s11) => this.parseAccount(s11));
      }
    };
    Y5 = m7;
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/crypto.js
var init_crypto = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/crypto.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/errors.js
var ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_MISSING_REQUIRED, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED;
var init_errors = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/errors.js"() {
    ERROR_SESSION_CONNECTED = "Session currently connected";
    ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
    ERROR_SESSION_REJECTED = "Session Rejected";
    ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
    ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
    ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
    ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
    ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
    ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
    ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
    ERROR_INVALID_URI = "URI format is invalid";
    ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
    ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/events.js
var RESERVED_EVENTS;
var init_events2 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/events.js"() {
    RESERVED_EVENTS = [
      "session_request",
      "session_update",
      "exchange_key",
      "connect",
      "disconnect",
      "display_uri",
      "modal_closed",
      "transport_open",
      "transport_close",
      "transport_error"
    ];
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/jsonrpc.js
var WALLET_METHODS, SIGNING_METHODS;
var init_jsonrpc3 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/jsonrpc.js"() {
    WALLET_METHODS = [
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode"
    ];
    SIGNING_METHODS = [
      "eth_sendTransaction",
      "eth_signTransaction",
      "eth_sign",
      "eth_signTypedData",
      "eth_signTypedData_v1",
      "eth_signTypedData_v2",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "personal_sign",
      ...WALLET_METHODS
    ];
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/mobile.js
var MOBILE_LINK_CHOICE_KEY;
var init_mobile = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/mobile.js"() {
    MOBILE_LINK_CHOICE_KEY = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/networks.js
var INFURA_NETWORKS;
var init_networks = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/networks.js"() {
    INFURA_NETWORKS = {
      1: "mainnet",
      3: "ropsten",
      4: "rinkeby",
      5: "goerli",
      42: "kovan"
    };
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/constants/index.js
var init_constants3 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/constants/index.js"() {
    init_errors();
    init_events2();
    init_jsonrpc3();
    init_mobile();
    init_networks();
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/ethereum.js
var init_ethereum = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/ethereum.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/events.js
var init_events3 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/events.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/jsonrpc.js
var init_jsonrpc4 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/jsonrpc.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/network.js
var init_network = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/network.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/protocol.js
var init_protocol = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/protocol.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/qrcode.js
var init_qrcode = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/qrcode.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/registry.js
var init_registry = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/registry.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/socket.js
var init_socket = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/socket.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/storage.js
var init_storage = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/storage.js"() {
  }
});

// node_modules/@walletconnect/legacy-types/dist/esm/index.js
var init_esm10 = __esm({
  "node_modules/@walletconnect/legacy-types/dist/esm/index.js"() {
    init_crypto();
    init_constants3();
    init_ethereum();
    init_events3();
    init_jsonrpc4();
    init_network();
    init_protocol();
    init_qrcode();
    init_registry();
    init_socket();
    init_storage();
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray3;
    isTypedArray3.strict = isStrictTypedArray;
    isTypedArray3.loose = isLooseTypedArray;
    var toString3 = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray3(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString3.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    var isTypedArray3 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray3(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/encoding/dist/esm/index.js
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function bufferToNumber(buf) {
  return buf.readUIntBE(0, buf.length);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function arrayToNumber(arr) {
  return bufferToNumber(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function hexToUtf8(hex) {
  return bufferToUtf8(hexToBuffer(hex));
}
function hexToNumber(hex) {
  return arrayToNumber(hexToArray(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function utf8ToNumber(utf8) {
  const num = parseInt(utf8, 10);
  assert(isDefined(num), "Number can only safely store up to 53 bits");
  return num;
}
function numberToBuffer(num) {
  return binaryToBuffer(numberToBinary(num));
}
function numberToArray(num) {
  return binaryToArray(numberToBinary(num));
}
function numberToHex(num, prefixed) {
  return binaryToHex(numberToBinary(num), prefixed);
}
function numberToUtf8(num) {
  return `${num}`;
}
function numberToBinary(num) {
  const bin = (num >>> 0).toString(2);
  return sanitizeBytes(bin);
}
function binaryToBuffer(bin) {
  return arrayToBuffer(binaryToArray(bin));
}
function binaryToArray(bin) {
  return new Uint8Array(splitBytes(bin).map((x8) => parseInt(x8, 2)));
}
function binaryToHex(bin, prefixed) {
  return arrayToHex(binaryToArray(bin), prefixed);
}
function isBinaryString(str) {
  if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
    return false;
  }
  if (str.length % 8 !== 0) {
    return false;
  }
  return true;
}
function isHexString8(str, length2) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && str.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
function isBuffer(val) {
  return Buffer.isBuffer(val);
}
function isTypedArray(val) {
  return import_is_typedarray.default.strict(val) && !isBuffer(val);
}
function isArrayBuffer(val) {
  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== "undefined";
}
function getType(val) {
  if (isBuffer(val)) {
    return TYPE_BUFFER;
  } else if (isTypedArray(val)) {
    return TYPE_TYPED_ARRAY;
  } else if (isArrayBuffer(val)) {
    return TYPE_ARRAY_BUFFER;
  } else if (Array.isArray(val)) {
    return TYPE_ARRAY;
  } else {
    return typeof val;
  }
}
function getEncoding(str) {
  if (isBinaryString(str)) {
    return ENC_BIN;
  }
  if (isHexString8(str)) {
    return ENC_HEX;
  }
  return ENC_UTF8;
}
function concatBuffers(...args) {
  const result = Buffer.concat(args);
  return result;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length2, byteSize = 8) {
  const remainder = length2 % byteSize;
  return remainder ? (length2 - remainder) / byteSize * byteSize + byteSize : length2;
}
function splitBytes(str, byteSize = 8) {
  const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
  return Array.from(bytes || []);
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length2, padding = STRING_ZERO) {
  return padString(str, length2, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isDefined(value) {
  return !isUndefined(value);
}
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
function padString(str, length2, left, padding = STRING_ZERO) {
  const diff = length2 - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}
var import_is_typedarray, import_typedarray_to_buffer, ENC_HEX, ENC_UTF8, ENC_BIN, TYPE_BUFFER, TYPE_ARRAY, TYPE_TYPED_ARRAY, TYPE_ARRAY_BUFFER, STRING_ZERO;
var init_esm11 = __esm({
  "node_modules/@walletconnect/encoding/dist/esm/index.js"() {
    import_is_typedarray = __toESM(require_is_typedarray());
    import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
    ENC_HEX = "hex";
    ENC_UTF8 = "utf8";
    ENC_BIN = "binary";
    TYPE_BUFFER = "buffer";
    TYPE_ARRAY = "array";
    TYPE_TYPED_ARRAY = "typed-array";
    TYPE_ARRAY_BUFFER = "array-buffer";
    STRING_ZERO = "0";
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToUtf8(arrBuf) {
  return arrayToUtf8(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertArrayBufferToNumber(arrBuf) {
  return arrayToNumber(new Uint8Array(arrBuf));
}
function concatArrayBuffers(...args) {
  return hexToArray(args.map((b10) => arrayToHex(new Uint8Array(b10))).join("")).buffer;
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertBufferToUtf8(buf) {
  return bufferToUtf8(buf);
}
function convertBufferToHex(buf, noPrefix) {
  return bufferToHex(buf, !noPrefix);
}
function convertBufferToNumber(buf) {
  return bufferToNumber(buf);
}
function concatBuffers2(...args) {
  return concatBuffers(...args);
}
function convertUtf8ToArrayBuffer(utf8) {
  return utf8ToArray(utf8).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertUtf8ToNumber(utf8) {
  return utf8ToNumber(utf8);
}
function convertHexToBuffer(hex) {
  return hexToBuffer(hex);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertHexToUtf8(hex) {
  return hexToUtf8(hex);
}
function convertHexToNumber(hex) {
  return hexToNumber(hex);
}
function convertNumberToBuffer(num) {
  return numberToBuffer(num);
}
function convertNumberToArrayBuffer(num) {
  return numberToArray(num).buffer;
}
function convertNumberToUtf8(num) {
  return numberToUtf8(num);
}
function convertNumberToHex(num, noPrefix) {
  return numberToHex(Number(num), !noPrefix);
}
var init_encoding = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/encoding.js"() {
    init_esm11();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/window.js
var windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_window = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/window.js"() {
    windowGetters = __toESM(require_cjs2());
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/env.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("ios") || os2.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os2 = detectOS2();
  return os2 ? isAndroid() || isIOS() : false;
}
function isNode2() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser2() {
  const result = !isNode2() && !!getNavigator2();
  return result;
}
var init_env2 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/env.js"() {
    init_es();
    init_window();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json2 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/json.js"() {
    init_esm3();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/local.js
function setLocal(key, data2) {
  const raw = safeJsonStringify2(data2);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data2 = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data2 = raw ? safeJsonParse2(raw) : raw;
  return data2;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/local.js"() {
    init_json2();
    init_window();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/meta.js
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata;
var init_meta = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/meta.js"() {
    windowMetadata = __toESM(require_cjs3());
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function addHexPrefix2(hex) {
  return addHexPrefix(hex);
}
function removeHexPrefix2(hex) {
  return removeHexPrefix(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
function uuid() {
  const result = ((a9, b10) => {
    for (b10 = a9 = ""; a9++ < 36; b10 += a9 * 51 & 52 ? (a9 ^ 15 ? 8 ^ Math.random() * (a9 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b10;
  })();
  return result;
}
function logDeprecationWarning() {
  console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = INFURA_NETWORKS[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}
var payloadId2;
var init_misc3 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/misc.js"() {
    init_esm11();
    init_esm6();
    init_esm10();
    payloadId2 = payloadId;
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data2) {
  const focusUri = data2.href.split("?")[0];
  setLocal(MOBILE_LINK_CHOICE_KEY, Object.assign(Object.assign({}, data2), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
var init_mobile2 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/mobile.js"() {
    init_esm10();
    init_local();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/payload.js
function promisify(originalFn, thisArg) {
  const promisifiedFunction = async (...callArgs) => {
    return new Promise((resolve, reject) => {
      const callback = (err, data2) => {
        if (err === null || typeof err === "undefined") {
          reject(err);
        }
        resolve(data2);
      };
      originalFn.apply(thisArg, [...callArgs, callback]);
    });
  };
  return promisifiedFunction;
}
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code2 = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code2 = -32700;
        break;
      case "Invalid request":
        code2 = -32600;
        break;
      case "Method not found":
        code2 = -32601;
        break;
      case "Invalid params":
        code2 = -32602;
        break;
      case "Internal error":
        code2 = -32603;
        break;
      default:
        code2 = -32e3;
        break;
    }
  }
  const result = {
    code: code2,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}
var init_payload = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/payload.js"() {
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a2;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a2 = entry.image_url.sm) !== null && _a2 !== void 0 ? _a2 : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry2 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/registry.js"() {
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/query-string/index.js
var require_query_string2 = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode5(key, options), "[", encode5(index, options), "]=", encode5(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[]"].join("")];
            }
            return [...result, [encode5(key, options), "[]=", encode5(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode5(key, options), "=", encode5(value, options)].join("")];
            }
            return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode5(key, options)];
            }
            return [...result, [encode5(key, options), "=", encode5(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode6(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode6(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode6(item, options)) : value === null ? value : decode6(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode5(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode6(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a9, b10) => Number(a9) - Number(b10)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode6(value, options);
        formatter(decode6(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k8 of Object.keys(value)) {
            value[k8] = parseValue(value[k8], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse3;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode5(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode5(key, options) + "=" + encode5(value, options);
      }).filter((x8) => x8.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode6(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${encode5(object.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/url.js
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}
var queryStringUtils;
var init_url2 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/url.js"() {
    queryStringUtils = __toESM(require_query_string2());
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
var init_session = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/session.js"() {
    init_url2();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isBuffer2(val) {
  return isBuffer(val);
}
function isTypedArray2(val) {
  return isTypedArray(val);
}
function isArrayBuffer2(val) {
  return isArrayBuffer(val);
}
function getType2(val) {
  return getType(val);
}
function getEncoding2(val) {
  return getEncoding(val);
}
function isHexString9(value, length2) {
  return isHexString8(value, length2);
}
function isJsonRpcSubscription(object) {
  return typeof object.params === "object";
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return RESERVED_EVENTS.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (SIGNING_METHODS.includes(request.method)) {
    return false;
  }
  return true;
}
var init_validators3 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/validators.js"() {
    init_esm11();
    init_esm10();
  }
});

// node_modules/@walletconnect/legacy-utils/dist/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  addHexPrefix: () => addHexPrefix2,
  appendToQueryString: () => appendToQueryString,
  concatArrayBuffers: () => concatArrayBuffers,
  concatBuffers: () => concatBuffers2,
  convertArrayBufferToBuffer: () => convertArrayBufferToBuffer,
  convertArrayBufferToHex: () => convertArrayBufferToHex,
  convertArrayBufferToNumber: () => convertArrayBufferToNumber,
  convertArrayBufferToUtf8: () => convertArrayBufferToUtf8,
  convertBufferToArrayBuffer: () => convertBufferToArrayBuffer,
  convertBufferToHex: () => convertBufferToHex,
  convertBufferToNumber: () => convertBufferToNumber,
  convertBufferToUtf8: () => convertBufferToUtf8,
  convertHexToArrayBuffer: () => convertHexToArrayBuffer,
  convertHexToBuffer: () => convertHexToBuffer,
  convertHexToNumber: () => convertHexToNumber,
  convertHexToUtf8: () => convertHexToUtf8,
  convertNumberToArrayBuffer: () => convertNumberToArrayBuffer,
  convertNumberToBuffer: () => convertNumberToBuffer,
  convertNumberToHex: () => convertNumberToHex,
  convertNumberToUtf8: () => convertNumberToUtf8,
  convertUtf8ToArrayBuffer: () => convertUtf8ToArrayBuffer,
  convertUtf8ToBuffer: () => convertUtf8ToBuffer,
  convertUtf8ToHex: () => convertUtf8ToHex,
  convertUtf8ToNumber: () => convertUtf8ToNumber,
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  formatQueryString: () => formatQueryString,
  formatRpcError: () => formatRpcError,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getEncoding: () => getEncoding2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getInfuraRpcUrl: () => getInfuraRpcUrl,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getQueryString: () => getQueryString,
  getRpcUrl: () => getRpcUrl,
  getType: () => getType2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isArrayBuffer: () => isArrayBuffer2,
  isBrowser: () => isBrowser2,
  isBuffer: () => isBuffer2,
  isEmptyArray: () => isEmptyArray,
  isEmptyString: () => isEmptyString,
  isHexString: () => isHexString9,
  isIOS: () => isIOS,
  isInternalEvent: () => isInternalEvent,
  isJsonRpcRequest: () => isJsonRpcRequest2,
  isJsonRpcResponseError: () => isJsonRpcResponseError,
  isJsonRpcResponseSuccess: () => isJsonRpcResponseSuccess,
  isJsonRpcSubscription: () => isJsonRpcSubscription,
  isMobile: () => isMobile,
  isNode: () => isNode2,
  isReservedEvent: () => isReservedEvent,
  isSilentPayload: () => isSilentPayload,
  isTypedArray: () => isTypedArray2,
  isWalletConnectSession: () => isWalletConnectSession,
  logDeprecationWarning: () => logDeprecationWarning,
  parseQueryString: () => parseQueryString,
  parseWalletConnectUri: () => parseWalletConnectUri,
  payloadId: () => payloadId2,
  promisify: () => promisify,
  removeHexLeadingZeros: () => removeHexLeadingZeros2,
  removeHexPrefix: () => removeHexPrefix2,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  sanitizeHex: () => sanitizeHex2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal,
  uuid: () => uuid
});
var init_esm12 = __esm({
  "node_modules/@walletconnect/legacy-utils/dist/esm/index.js"() {
    init_encoding();
    init_env2();
    init_json2();
    init_local();
    init_meta();
    init_misc3();
    init_mobile2();
    init_payload();
    init_registry2();
    init_session();
    init_url2();
    init_validators3();
    init_window();
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/network.js
var NetworkMonitor, network_default;
var init_network2 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/network.js"() {
    NetworkMonitor = class {
      constructor() {
        this._eventEmitters = [];
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
          window.addEventListener("online", () => this.trigger("online"));
          window.addEventListener("offline", () => this.trigger("offline"));
        }
      }
      on(event, callback) {
        this._eventEmitters.push({
          event,
          callback
        });
      }
      trigger(event) {
        let eventEmitters = [];
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        eventEmitters.forEach((eventEmitter) => {
          eventEmitter.callback();
        });
      }
    };
    network_default = NetworkMonitor;
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/socket.js
function getWebSocketUrl(_url, protocol, version6) {
  var _a2, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser2() ? {
    protocol,
    version: version6,
    env: "browser",
    host: ((_a2 = getLocation2()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version6,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var WS3, SocketTransport, socket_default;
var init_socket2 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/socket.js"() {
    init_esm12();
    init_network2();
    WS3 = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser4();
    SocketTransport = class {
      constructor(opts) {
        this.opts = opts;
        this._queue = [];
        this._events = [];
        this._subscriptions = [];
        this._protocol = opts.protocol;
        this._version = opts.version;
        this._url = "";
        this._netMonitor = null;
        this._socket = null;
        this._nextSocket = null;
        this._subscriptions = opts.subscriptions || [];
        this._netMonitor = opts.netMonitor || new network_default();
        if (!opts.url || typeof opts.url !== "string") {
          throw new Error("Missing or invalid WebSocket url");
        }
        this._url = opts.url;
        this._netMonitor.on("online", () => this._socketCreate());
      }
      set readyState(value) {
      }
      get readyState() {
        return this._socket ? this._socket.readyState : -1;
      }
      set connecting(value) {
      }
      get connecting() {
        return this.readyState === 0;
      }
      set connected(value) {
      }
      get connected() {
        return this.readyState === 1;
      }
      set closing(value) {
      }
      get closing() {
        return this.readyState === 2;
      }
      set closed(value) {
      }
      get closed() {
        return this.readyState === 3;
      }
      open() {
        this._socketCreate();
      }
      close() {
        this._socketClose();
      }
      send(message, topic, silent) {
        if (!topic || typeof topic !== "string") {
          throw new Error("Missing or invalid topic field");
        }
        this._socketSend({
          topic,
          type: "pub",
          payload: message,
          silent: !!silent
        });
      }
      subscribe(topic) {
        this._socketSend({
          topic,
          type: "sub",
          payload: "",
          silent: true
        });
      }
      on(event, callback) {
        this._events.push({ event, callback });
      }
      _socketCreate() {
        if (this._nextSocket) {
          return;
        }
        const url = getWebSocketUrl(this._url, this._protocol, this._version);
        this._nextSocket = new WS3(url);
        if (!this._nextSocket) {
          throw new Error("Failed to create socket");
        }
        this._nextSocket.onmessage = (event) => this._socketReceive(event);
        this._nextSocket.onopen = () => this._socketOpen();
        this._nextSocket.onerror = (event) => this._socketError(event);
        this._nextSocket.onclose = () => {
          setTimeout(() => {
            this._nextSocket = null;
            this._socketCreate();
          }, 1e3);
        };
      }
      _socketOpen() {
        this._socketClose();
        this._socket = this._nextSocket;
        this._nextSocket = null;
        this._queueSubscriptions();
        this._pushQueue();
      }
      _socketClose() {
        if (this._socket) {
          this._socket.onclose = () => {
          };
          this._socket.close();
        }
      }
      _socketSend(socketMessage) {
        const message = JSON.stringify(socketMessage);
        if (this._socket && this._socket.readyState === 1) {
          this._socket.send(message);
        } else {
          this._setToQueue(socketMessage);
          this._socketCreate();
        }
      }
      async _socketReceive(event) {
        let socketMessage;
        try {
          socketMessage = JSON.parse(event.data);
        } catch (error) {
          return;
        }
        this._socketSend({
          topic: socketMessage.topic,
          type: "ack",
          payload: "",
          silent: true
        });
        if (this._socket && this._socket.readyState === 1) {
          const events = this._events.filter((event2) => event2.event === "message");
          if (events && events.length) {
            events.forEach((event2) => event2.callback(socketMessage));
          }
        }
      }
      _socketError(e11) {
        const events = this._events.filter((event) => event.event === "error");
        if (events && events.length) {
          events.forEach((event) => event.callback(e11));
        }
      }
      _queueSubscriptions() {
        const subscriptions = this._subscriptions;
        subscriptions.forEach((topic) => this._queue.push({
          topic,
          type: "sub",
          payload: "",
          silent: true
        }));
        this._subscriptions = this.opts.subscriptions || [];
      }
      _setToQueue(socketMessage) {
        this._queue.push(socketMessage);
      }
      _pushQueue() {
        const queue = this._queue;
        queue.forEach((socketMessage) => this._socketSend(socketMessage));
        this._queue = [];
      }
    };
    socket_default = SocketTransport;
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/events.js
var EventManager, events_default;
var init_events4 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/events.js"() {
    init_esm12();
    EventManager = class {
      constructor() {
        this._eventEmitters = [];
      }
      subscribe(eventEmitter) {
        this._eventEmitters.push(eventEmitter);
      }
      unsubscribe(event) {
        this._eventEmitters = this._eventEmitters.filter((x8) => x8.event !== event);
      }
      trigger(payload) {
        let eventEmitters = [];
        let event;
        if (isJsonRpcRequest2(payload)) {
          event = payload.method;
        } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
          event = `response:${payload.id}`;
        } else if (isInternalEvent(payload)) {
          event = payload.event;
        } else {
          event = "";
        }
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
        }
        eventEmitters.forEach((eventEmitter) => {
          if (isJsonRpcResponseError(payload)) {
            const error = new Error(payload.error.message);
            eventEmitter.callback(error, null);
          } else {
            eventEmitter.callback(null, payload);
          }
        });
      }
    };
    events_default = EventManager;
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/storage.js
var SessionStorage, storage_default;
var init_storage2 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/storage.js"() {
    init_esm12();
    SessionStorage = class {
      constructor(storageId = "walletconnect") {
        this.storageId = storageId;
      }
      getSession() {
        let session = null;
        const json = getLocal(this.storageId);
        if (json && isWalletConnectSession(json)) {
          session = json;
        }
        return session;
      }
      setSession(session) {
        setLocal(this.storageId, session);
        return session;
      }
      removeSession() {
        removeLocal(this.storageId);
      }
    };
    storage_default = SessionStorage;
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/url.js
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
var domain, alphanumerical, bridges;
var init_url3 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/url.js"() {
    domain = "walletconnect.org";
    alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
    bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/core.js
var Connector2, core_default;
var init_core = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/core.js"() {
    init_esm10();
    init_esm12();
    init_socket2();
    init_events4();
    init_storage2();
    init_url3();
    Connector2 = class {
      constructor(opts) {
        this.protocol = "wc";
        this.version = 1;
        this._bridge = "";
        this._key = null;
        this._clientId = "";
        this._clientMeta = null;
        this._peerId = "";
        this._peerMeta = null;
        this._handshakeId = 0;
        this._handshakeTopic = "";
        this._connected = false;
        this._accounts = [];
        this._chainId = 0;
        this._networkId = 0;
        this._rpcUrl = "";
        this._eventManager = new events_default();
        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
        this._cryptoLib = opts.cryptoLib;
        this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
        this._qrcodeModal = opts.connectorOpts.qrcodeModal;
        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
        this._signingMethods = [...SIGNING_METHODS, ...opts.connectorOpts.signingMethods || []];
        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
          throw new Error(ERROR_MISSING_REQUIRED);
        }
        if (opts.connectorOpts.bridge) {
          this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
        }
        if (opts.connectorOpts.uri) {
          this.uri = opts.connectorOpts.uri;
        }
        const session = opts.connectorOpts.session || this._getStorageSession();
        if (session) {
          this.session = session;
        }
        if (this.handshakeId) {
          this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
        }
        this._transport = opts.transport || new socket_default({
          protocol: this.protocol,
          version: this.version,
          url: this.bridge,
          subscriptions: [this.clientId]
        });
        this._subscribeToInternalEvents();
        this._initTransport();
        if (opts.connectorOpts.uri) {
          this._subscribeToSessionRequest();
        }
        if (opts.pushServerOpts) {
          this._registerPushServer(opts.pushServerOpts);
        }
      }
      set bridge(value) {
        if (!value) {
          return;
        }
        this._bridge = value;
      }
      get bridge() {
        return this._bridge;
      }
      set key(value) {
        if (!value) {
          return;
        }
        const key = convertHexToArrayBuffer(value);
        this._key = key;
      }
      get key() {
        if (this._key) {
          const key = convertArrayBufferToHex(this._key, true);
          return key;
        }
        return "";
      }
      set clientId(value) {
        if (!value) {
          return;
        }
        this._clientId = value;
      }
      get clientId() {
        let clientId = this._clientId;
        if (!clientId) {
          clientId = this._clientId = uuid();
        }
        return this._clientId;
      }
      set peerId(value) {
        if (!value) {
          return;
        }
        this._peerId = value;
      }
      get peerId() {
        return this._peerId;
      }
      set clientMeta(value) {
      }
      get clientMeta() {
        let clientMeta = this._clientMeta;
        if (!clientMeta) {
          clientMeta = this._clientMeta = getClientMeta();
        }
        return clientMeta;
      }
      set peerMeta(value) {
        this._peerMeta = value;
      }
      get peerMeta() {
        const peerMeta = this._peerMeta;
        return peerMeta;
      }
      set handshakeTopic(value) {
        if (!value) {
          return;
        }
        this._handshakeTopic = value;
      }
      get handshakeTopic() {
        return this._handshakeTopic;
      }
      set handshakeId(value) {
        if (!value) {
          return;
        }
        this._handshakeId = value;
      }
      get handshakeId() {
        return this._handshakeId;
      }
      get uri() {
        const _uri = this._formatUri();
        return _uri;
      }
      set uri(value) {
        if (!value) {
          return;
        }
        const { handshakeTopic, bridge, key } = this._parseUri(value);
        this.handshakeTopic = handshakeTopic;
        this.bridge = bridge;
        this.key = key;
      }
      set chainId(value) {
        this._chainId = value;
      }
      get chainId() {
        const chainId = this._chainId;
        return chainId;
      }
      set networkId(value) {
        this._networkId = value;
      }
      get networkId() {
        const networkId = this._networkId;
        return networkId;
      }
      set accounts(value) {
        this._accounts = value;
      }
      get accounts() {
        const accounts = this._accounts;
        return accounts;
      }
      set rpcUrl(value) {
        this._rpcUrl = value;
      }
      get rpcUrl() {
        const rpcUrl = this._rpcUrl;
        return rpcUrl;
      }
      set connected(value) {
      }
      get connected() {
        return this._connected;
      }
      set pending(value) {
      }
      get pending() {
        return !!this._handshakeTopic;
      }
      get session() {
        return {
          connected: this.connected,
          accounts: this.accounts,
          chainId: this.chainId,
          bridge: this.bridge,
          key: this.key,
          clientId: this.clientId,
          clientMeta: this.clientMeta,
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          handshakeId: this.handshakeId,
          handshakeTopic: this.handshakeTopic
        };
      }
      set session(value) {
        if (!value) {
          return;
        }
        this._connected = value.connected;
        this.accounts = value.accounts;
        this.chainId = value.chainId;
        this.bridge = value.bridge;
        this.key = value.key;
        this.clientId = value.clientId;
        this.clientMeta = value.clientMeta;
        this.peerId = value.peerId;
        this.peerMeta = value.peerMeta;
        this.handshakeId = value.handshakeId;
        this.handshakeTopic = value.handshakeTopic;
      }
      on(event, callback) {
        const eventEmitter = {
          event,
          callback
        };
        this._eventManager.subscribe(eventEmitter);
      }
      off(event) {
        this._eventManager.unsubscribe(event);
      }
      async createInstantRequest(instantRequest) {
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_instantRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              request: this._formatRequest(instantRequest)
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
        this.on("modal_closed", () => {
          throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
        });
        const endInstantRequest = () => {
          this.killSession();
        };
        try {
          const result = await this._sendCallRequest(request);
          if (result) {
            endInstantRequest();
          }
          return result;
        } catch (error) {
          endInstantRequest();
          throw error;
        }
      }
      async connect(opts) {
        if (!this._qrcodeModal) {
          throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
        }
        if (this.connected) {
          return {
            chainId: this.chainId,
            accounts: this.accounts
          };
        }
        await this.createSession(opts);
        return new Promise(async (resolve, reject) => {
          this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
          this.on("connect", (error, payload) => {
            if (error) {
              return reject(error);
            }
            resolve(payload.params[0]);
          });
        });
      }
      async createSession(opts) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        if (this.pending) {
          return;
        }
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_sessionRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              chainId: opts && opts.chainId ? opts.chainId : null
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._sendSessionRequest(request, "Session update rejected", {
          topic: this.handshakeTopic
        });
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
      }
      approveSession(sessionStatus) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl,
          peerId: this.clientId,
          peerMeta: this.clientMeta
        };
        const response = {
          id: this.handshakeId,
          jsonrpc: "2.0",
          result: sessionParams
        };
        this._sendResponse(response);
        this._connected = true;
        this._setStorageSession();
        this._eventManager.trigger({
          event: "connect",
          params: [
            {
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
      }
      rejectSession(sessionError) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
        const response = this._formatResponse({
          id: this.handshakeId,
          error: { message }
        });
        this._sendResponse(response);
        this._connected = false;
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
      }
      updateSession(sessionStatus) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        this._sendSessionRequest(request, "Session update rejected");
        this._eventManager.trigger({
          event: "session_update",
          params: [
            {
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
        this._manageStorageSession();
      }
      async killSession(sessionError) {
        const message = sessionError ? sessionError.message : "Session Disconnected";
        const sessionParams = {
          approved: false,
          chainId: null,
          networkId: null,
          accounts: null
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        await this._sendRequest(request);
        this._handleSessionDisconnect(message);
      }
      async sendTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = tx;
        const request = this._formatRequest({
          method: "eth_sendTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = tx;
        const request = this._formatRequest({
          method: "eth_signTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signPersonalMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "personal_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTypedData(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_signTypedData",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async updateChain(chainParams) {
        if (!this._connected) {
          throw new Error("Session currently disconnected");
        }
        const request = this._formatRequest({
          method: "wallet_updateChain",
          params: [chainParams]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      unsafeSend(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(request.id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (!payload) {
              throw new Error(ERROR_MISSING_JSON_RPC);
            }
            resolve(payload);
          });
        });
      }
      async sendCustomRequest(request, options) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        switch (request.method) {
          case "eth_accounts":
            return this.accounts;
          case "eth_chainId":
            return convertNumberToHex(this.chainId);
          case "eth_sendTransaction":
          case "eth_signTransaction":
            if (request.params) {
            }
            break;
          case "personal_sign":
            if (request.params) {
            }
            break;
          default:
            break;
        }
        const formattedRequest = this._formatRequest(request);
        const result = await this._sendCallRequest(formattedRequest, options);
        return result;
      }
      approveRequest(response) {
        if (isJsonRpcResponseSuccess(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_RESULT);
        }
      }
      rejectRequest(response) {
        if (isJsonRpcResponseError(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_ERROR);
        }
      }
      transportClose() {
        this._transport.close();
      }
      async _sendRequest(request, options) {
        const callRequest = this._formatRequest(request);
        const encryptionPayload = await this._encrypt(callRequest);
        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
        this._transport.send(payload, topic, silent);
      }
      async _sendResponse(response) {
        const encryptionPayload = await this._encrypt(response);
        const topic = this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = true;
        this._transport.send(payload, topic, silent);
      }
      async _sendSessionRequest(request, errorMsg, options) {
        this._sendRequest(request, options);
        this._subscribeToSessionResponse(request.id, errorMsg);
      }
      _sendCallRequest(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return this._subscribeToCallResponse(request.id);
      }
      _formatRequest(request) {
        if (typeof request.method === "undefined") {
          throw new Error(ERROR_MISSING_METHOD);
        }
        const formattedRequest = {
          id: typeof request.id === "undefined" ? payloadId2() : request.id,
          jsonrpc: "2.0",
          method: request.method,
          params: typeof request.params === "undefined" ? [] : request.params
        };
        return formattedRequest;
      }
      _formatResponse(response) {
        if (typeof response.id === "undefined") {
          throw new Error(ERROR_MISSING_ID);
        }
        const baseResponse = { id: response.id, jsonrpc: "2.0" };
        if (isJsonRpcResponseError(response)) {
          const error = formatRpcError(response.error);
          const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
          return errorResponse;
        } else if (isJsonRpcResponseSuccess(response)) {
          const successResponse = Object.assign(Object.assign({}, baseResponse), response);
          return successResponse;
        }
        throw new Error(ERROR_INVALID_RESPONSE);
      }
      _handleSessionDisconnect(errorMsg) {
        const message = errorMsg || "Session Disconnected";
        if (!this._connected) {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
          removeLocal(MOBILE_LINK_CHOICE_KEY);
        }
        if (this._connected) {
          this._connected = false;
        }
        if (this._handshakeId) {
          this._handshakeId = 0;
        }
        if (this._handshakeTopic) {
          this._handshakeTopic = "";
        }
        if (this._peerId) {
          this._peerId = "";
        }
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
        this.transportClose();
      }
      _handleSessionResponse(errorMsg, sessionParams) {
        if (sessionParams) {
          if (sessionParams.approved) {
            if (!this._connected) {
              this._connected = true;
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              if (sessionParams.peerId && !this.peerId) {
                this.peerId = sessionParams.peerId;
              }
              if (sessionParams.peerMeta && !this.peerMeta) {
                this.peerMeta = sessionParams.peerMeta;
              }
              this._eventManager.trigger({
                event: "connect",
                params: [
                  {
                    peerId: this.peerId,
                    peerMeta: this.peerMeta,
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            } else {
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              this._eventManager.trigger({
                event: "session_update",
                params: [
                  {
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            }
            this._manageStorageSession();
          } else {
            this._handleSessionDisconnect(errorMsg);
          }
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      }
      async _handleIncomingMessages(socketMessage) {
        const activeTopics = [this.clientId, this.handshakeTopic];
        if (!activeTopics.includes(socketMessage.topic)) {
          return;
        }
        let encryptionPayload;
        try {
          encryptionPayload = JSON.parse(socketMessage.payload);
        } catch (error) {
          return;
        }
        const payload = await this._decrypt(encryptionPayload);
        if (payload) {
          this._eventManager.trigger(payload);
        }
      }
      _subscribeToSessionRequest() {
        this._transport.subscribe(this.handshakeTopic);
      }
      _subscribeToResponse(id2, callback) {
        this.on(`response:${id2}`, callback);
      }
      _subscribeToSessionResponse(id2, errorMsg) {
        this._subscribeToResponse(id2, (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
            return;
          }
          if (isJsonRpcResponseSuccess(payload)) {
            this._handleSessionResponse(errorMsg, payload.result);
          } else if (payload.error && payload.error.message) {
            this._handleSessionResponse(payload.error.message);
          } else {
            this._handleSessionResponse(errorMsg);
          }
        });
      }
      _subscribeToCallResponse(id2) {
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(id2, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (isJsonRpcResponseSuccess(payload)) {
              resolve(payload.result);
            } else if (payload.error && payload.error.message) {
              reject(payload.error);
            } else {
              reject(new Error(ERROR_INVALID_RESPONSE));
            }
          });
        });
      }
      _subscribeToInternalEvents() {
        this.on("display_uri", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.open(this.uri, () => {
              this._eventManager.trigger({
                event: "modal_closed",
                params: []
              });
            }, this._qrcodeModalOptions);
          }
        });
        this.on("connect", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
        });
        this.on("call_request_sent", (error, payload) => {
          const { request } = payload.params[0];
          if (isMobile() && this._signingMethods.includes(request.method)) {
            const mobileLinkUrl = getLocal(MOBILE_LINK_CHOICE_KEY);
            if (mobileLinkUrl) {
              window.location.href = mobileLinkUrl.href;
            }
          }
        });
        this.on("wc_sessionRequest", (error, payload) => {
          if (error) {
            this._eventManager.trigger({
              event: "error",
              params: [
                {
                  code: "SESSION_REQUEST_ERROR",
                  message: error.toString()
                }
              ]
            });
          }
          this.handshakeId = payload.id;
          this.peerId = payload.params[0].peerId;
          this.peerMeta = payload.params[0].peerMeta;
          const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
          this._eventManager.trigger(internalPayload);
        });
        this.on("wc_sessionUpdate", (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
          }
          this._handleSessionResponse("Session disconnected", payload.params[0]);
        });
      }
      _initTransport() {
        this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
        this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
        this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
        this._transport.on("error", () => this._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        }));
        this._transport.open();
      }
      _formatUri() {
        const protocol = this.protocol;
        const handshakeTopic = this.handshakeTopic;
        const version6 = this.version;
        const bridge = encodeURIComponent(this.bridge);
        const key = this.key;
        const uri = `${protocol}:${handshakeTopic}@${version6}?bridge=${bridge}&key=${key}`;
        return uri;
      }
      _parseUri(uri) {
        const result = parseWalletConnectUri(uri);
        if (result.protocol === this.protocol) {
          if (!result.handshakeTopic) {
            throw Error("Invalid or missing handshakeTopic parameter value");
          }
          const handshakeTopic = result.handshakeTopic;
          if (!result.bridge) {
            throw Error("Invalid or missing bridge url parameter value");
          }
          const bridge = decodeURIComponent(result.bridge);
          if (!result.key) {
            throw Error("Invalid or missing key parameter value");
          }
          const key = result.key;
          return { handshakeTopic, bridge, key };
        } else {
          throw new Error(ERROR_INVALID_URI);
        }
      }
      async _generateKey() {
        if (this._cryptoLib) {
          const result = await this._cryptoLib.generateKey();
          return result;
        }
        return null;
      }
      async _encrypt(data2) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.encrypt(data2, key);
          return result;
        }
        return null;
      }
      async _decrypt(payload) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.decrypt(payload, key);
          return result;
        }
        return null;
      }
      _getStorageSession() {
        let result = null;
        if (this._sessionStorage) {
          result = this._sessionStorage.getSession();
        }
        return result;
      }
      _setStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.setSession(this.session);
        }
      }
      _removeStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.removeSession();
        }
      }
      _manageStorageSession() {
        if (this._connected) {
          this._setStorageSession();
        } else {
          this._removeStorageSession();
        }
      }
      _registerPushServer(pushServerOpts) {
        if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
          throw Error("Invalid or missing pushServerOpts.url parameter value");
        }
        if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
          throw Error("Invalid or missing pushServerOpts.type parameter value");
        }
        if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
          throw Error("Invalid or missing pushServerOpts.token parameter value");
        }
        const pushSubscription = {
          bridge: this.bridge,
          topic: this.clientId,
          type: pushServerOpts.type,
          token: pushServerOpts.token,
          peerName: "",
          language: pushServerOpts.language || ""
        };
        this.on("connect", async (error, payload) => {
          if (error) {
            throw error;
          }
          if (pushServerOpts.peerMeta) {
            const peerName = payload.params[0].peerMeta.name;
            pushSubscription.peerName = peerName;
          }
          try {
            const response = await fetch(`${pushServerOpts.url}/new`, {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(pushSubscription)
            });
            const json = await response.json();
            if (!json.success) {
              throw Error("Failed to register in Push Server");
            }
          } catch (error2) {
            throw Error("Failed to register in Push Server");
          }
        });
      }
    };
    core_default = Connector2;
  }
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
function randomBytes3(length2) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length2));
}
var env;
var init_browser = __esm({
  "node_modules/@walletconnect/randombytes/dist/esm/browser/index.js"() {
    env = __toESM(require_cjs7());
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0, LENGTH_1, LENGTH_16, LENGTH_32, LENGTH_64, LENGTH_128, LENGTH_256, LENGTH_512, LENGTH_1024;
var init_length = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/length.js"() {
    LENGTH_0 = 0;
    LENGTH_1 = 1;
    LENGTH_16 = 16;
    LENGTH_32 = 32;
    LENGTH_64 = 64;
    LENGTH_128 = 128;
    LENGTH_256 = 256;
    LENGTH_512 = 512;
    LENGTH_1024 = 1024;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH, HMAC_LENGTH, AES_BROWSER_ALGO, HMAC_BROWSER_ALGO, HMAC_BROWSER, SHA256_BROWSER_ALGO, SHA512_BROWSER_ALGO, AES_NODE_ALGO, HMAC_NODE_ALGO, SHA256_NODE_ALGO, SHA512_NODE_ALGO, RIPEMD160_NODE_ALGO, PREFIX_LENGTH, KEY_LENGTH, IV_LENGTH, MAC_LENGTH;
var init_default = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/default.js"() {
    init_length();
    AES_LENGTH = LENGTH_256;
    HMAC_LENGTH = LENGTH_256;
    AES_BROWSER_ALGO = "AES-CBC";
    HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
    HMAC_BROWSER = "HMAC";
    SHA256_BROWSER_ALGO = "SHA-256";
    SHA512_BROWSER_ALGO = "SHA-512";
    AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
    HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
    SHA256_NODE_ALGO = "sha256";
    SHA512_NODE_ALGO = "sha512";
    RIPEMD160_NODE_ALGO = "ripemd160";
    PREFIX_LENGTH = LENGTH_1;
    KEY_LENGTH = LENGTH_32;
    IV_LENGTH = LENGTH_16;
    MAC_LENGTH = LENGTH_32;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC, UTF8_ENC;
var init_encoding2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js"() {
    HEX_ENC = "hex";
    UTF8_ENC = "utf8";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC;
var init_error2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/error.js"() {
    ERROR_BAD_MAC = "Bad MAC";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP, DECRYPT_OP, SIGN_OP, VERIFY_OP;
var init_operations = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/operations.js"() {
    ENCRYPT_OP = "encrypt";
    DECRYPT_OP = "decrypt";
    SIGN_OP = "sign";
    VERIFY_OP = "verify";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/index.js
var init_constants4 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/index.js"() {
    init_default();
    init_encoding2();
    init_error2();
    init_length();
    init_operations();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data2) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data2) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data2) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data2);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data2) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data2);
  return new Uint8Array(signature);
}
async function browserSha256(data2) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data2);
  return new Uint8Array(result);
}
async function browserSha512(data2) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data2);
  return new Uint8Array(result);
}
var env2;
var init_browser2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/lib/browser.js"() {
    env2 = __toESM(require_cjs7());
    init_constants4();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data2) {
  return browserAesEncrypt(iv, key, data2);
}
function aesCbcDecrypt(iv, key, data2) {
  return browserAesDecrypt(iv, key, data2);
}
var init_aes = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/aes.js"() {
    init_browser2();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
var init_env3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/env.js"() {
    __reExport(env_exports2, __toESM(require_cjs7()));
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING, pkcs7;
var init_pkcs7 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js"() {
    PADDING = [
      [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
      [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
      [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
      [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
      [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
      [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
      [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
      [9, 9, 9, 9, 9, 9, 9, 9, 9],
      [8, 8, 8, 8, 8, 8, 8, 8],
      [7, 7, 7, 7, 7, 7, 7],
      [6, 6, 6, 6, 6, 6],
      [5, 5, 5, 5, 5],
      [4, 4, 4, 4],
      [3, 3, 3],
      [2, 2],
      [1]
    ];
    pkcs7 = {
      pad(plaintext) {
        const padding = PADDING[plaintext.byteLength % 16 || 0];
        const result = new Uint8Array(plaintext.byteLength + padding.length);
        result.set(plaintext);
        result.set(padding, plaintext.byteLength);
        return result;
      },
      unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
      }
    };
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
var init_types4 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/types.js"() {
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i10 = 0; i10 < arr1.length; i10++) {
    res |= arr1[i10] ^ arr2[i10];
  }
  return res === 0;
}
var init_validators4 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js"() {
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert2,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});
var init_helpers = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/index.js"() {
    init_env3();
    __reExport(helpers_exports, env_exports2);
    init_pkcs7();
    init_types4();
    init_validators4();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
var init_hmac = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js"() {
    init_browser2();
    init_helpers();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha2564(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha5123(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd1602(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}
var init_sha2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js"() {
    init_browser2();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert2,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes3,
  ripemd160: () => ripemd1602,
  sha256: () => sha2564,
  sha512: () => sha5123
});
var init_browser3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/index.js"() {
    init_browser();
    init_aes();
    init_hmac();
    init_sha2();
    init_helpers();
    __reExport(browser_exports, helpers_exports);
    init_constants4();
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/crypto.js
var crypto_exports = {};
__export(crypto_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
async function generateKey(length2) {
  const _length = (length2 || 256) / 8;
  const bytes = randomBytes3(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data2, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data2);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data2;
  try {
    data2 = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data2;
}
var init_crypto2 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/crypto.js"() {
    init_browser3();
    init_esm11();
    init_esm12();
  }
});

// node_modules/@walletconnect/legacy-client/dist/esm/index.js
var WalletConnect, esm_default3;
var init_esm13 = __esm({
  "node_modules/@walletconnect/legacy-client/dist/esm/index.js"() {
    init_core();
    init_crypto2();
    WalletConnect = class extends core_default {
      constructor(connectorOpts, pushServerOpts) {
        super({
          cryptoLib: crypto_exports,
          connectorOpts,
          pushServerOpts
        });
      }
    };
    esm_default3 = WalletConnect;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i10 = 0; i10 < selection.rangeCount; i10++) {
        ranges.push(selection.getRangeAt(i10));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e11) {
          e11.stopPropagation();
          if (options.format) {
            e11.preventDefault();
            if (typeof e11.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e11.clipboardData.clearData();
              e11.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e11.preventDefault();
            options.onCopy(e11.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/preact/dist/preact.module.js
function h8(n8, l9) {
  for (var u9 in l9)
    n8[u9] = l9[u9];
  return n8;
}
function v4(n8) {
  var l9 = n8.parentNode;
  l9 && l9.removeChild(n8);
}
function y7(l9, u9, i10) {
  var t8, r7, o11, f7 = {};
  for (o11 in u9)
    "key" == o11 ? t8 = u9[o11] : "ref" == o11 ? r7 = u9[o11] : f7[o11] = u9[o11];
  if (arguments.length > 2 && (f7.children = arguments.length > 3 ? n7.call(arguments, 2) : i10), "function" == typeof l9 && null != l9.defaultProps)
    for (o11 in l9.defaultProps)
      void 0 === f7[o11] && (f7[o11] = l9.defaultProps[o11]);
  return p7(l9, f7, t8, r7, null);
}
function p7(n8, i10, t8, r7, o11) {
  var f7 = { type: n8, props: i10, key: t8, ref: r7, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o11 ? ++u7 : o11 };
  return null == o11 && null != l7.vnode && l7.vnode(f7), f7;
}
function d6() {
  return { current: null };
}
function _6(n8) {
  return n8.children;
}
function k5(n8, l9) {
  this.props = n8, this.context = l9;
}
function b7(n8, l9) {
  if (null == l9)
    return n8.__ ? b7(n8.__, n8.__.__k.indexOf(n8) + 1) : null;
  for (var u9; l9 < n8.__k.length; l9++)
    if (null != (u9 = n8.__k[l9]) && null != u9.__e)
      return u9.__e;
  return "function" == typeof n8.type ? b7(n8) : null;
}
function g6(n8) {
  var l9, u9;
  if (null != (n8 = n8.__) && null != n8.__c) {
    for (n8.__e = n8.__c.base = null, l9 = 0; l9 < n8.__k.length; l9++)
      if (null != (u9 = n8.__k[l9]) && null != u9.__e) {
        n8.__e = n8.__c.base = u9.__e;
        break;
      }
    return g6(n8);
  }
}
function m8(n8) {
  (!n8.__d && (n8.__d = true) && t6.push(n8) && !w8.__r++ || r5 !== l7.debounceRendering) && ((r5 = l7.debounceRendering) || o9)(w8);
}
function w8() {
  var n8, l9, u9, i10, r7, o11, e11, c8;
  for (t6.sort(f4); n8 = t6.shift(); )
    n8.__d && (l9 = t6.length, i10 = void 0, r7 = void 0, e11 = (o11 = (u9 = n8).__v).__e, (c8 = u9.__P) && (i10 = [], (r7 = h8({}, o11)).__v = o11.__v + 1, L5(c8, o11, r7, u9.__n, void 0 !== c8.ownerSVGElement, null != o11.__h ? [e11] : null, i10, null == e11 ? b7(o11) : e11, o11.__h), M7(i10, o11), o11.__e != e11 && g6(o11)), t6.length > l9 && t6.sort(f4));
  w8.__r = 0;
}
function x5(n8, l9, u9, i10, t8, r7, o11, f7, e11, a9) {
  var h11, v7, y10, d9, k8, g9, m11, w11 = i10 && i10.__k || s8, x8 = w11.length;
  for (u9.__k = [], h11 = 0; h11 < l9.length; h11++)
    if (null != (d9 = u9.__k[h11] = null == (d9 = l9[h11]) || "boolean" == typeof d9 || "function" == typeof d9 ? null : "string" == typeof d9 || "number" == typeof d9 || "bigint" == typeof d9 ? p7(null, d9, null, null, d9) : Array.isArray(d9) ? p7(_6, { children: d9 }, null, null, null) : d9.__b > 0 ? p7(d9.type, d9.props, d9.key, d9.ref ? d9.ref : null, d9.__v) : d9)) {
      if (d9.__ = u9, d9.__b = u9.__b + 1, null === (y10 = w11[h11]) || y10 && d9.key == y10.key && d9.type === y10.type)
        w11[h11] = void 0;
      else
        for (v7 = 0; v7 < x8; v7++) {
          if ((y10 = w11[v7]) && d9.key == y10.key && d9.type === y10.type) {
            w11[v7] = void 0;
            break;
          }
          y10 = null;
        }
      L5(n8, d9, y10 = y10 || c6, t8, r7, o11, f7, e11, a9), k8 = d9.__e, (v7 = d9.ref) && y10.ref != v7 && (m11 || (m11 = []), y10.ref && m11.push(y10.ref, null, d9), m11.push(v7, d9.__c || k8, d9)), null != k8 ? (null == g9 && (g9 = k8), "function" == typeof d9.type && d9.__k === y10.__k ? d9.__d = e11 = A6(d9, e11, n8) : e11 = C7(n8, d9, y10, w11, k8, e11), "function" == typeof u9.type && (u9.__d = e11)) : e11 && y10.__e == e11 && e11.parentNode != n8 && (e11 = b7(y10));
    }
  for (u9.__e = g9, h11 = x8; h11--; )
    null != w11[h11] && ("function" == typeof u9.type && null != w11[h11].__e && w11[h11].__e == u9.__d && (u9.__d = $8(i10).nextSibling), S6(w11[h11], w11[h11]));
  if (m11)
    for (h11 = 0; h11 < m11.length; h11++)
      O6(m11[h11], m11[++h11], m11[++h11]);
}
function A6(n8, l9, u9) {
  for (var i10, t8 = n8.__k, r7 = 0; t8 && r7 < t8.length; r7++)
    (i10 = t8[r7]) && (i10.__ = n8, l9 = "function" == typeof i10.type ? A6(i10, l9, u9) : C7(u9, i10, i10, t8, i10.__e, l9));
  return l9;
}
function P6(n8, l9) {
  return l9 = l9 || [], null == n8 || "boolean" == typeof n8 || (Array.isArray(n8) ? n8.some(function(n9) {
    P6(n9, l9);
  }) : l9.push(n8)), l9;
}
function C7(n8, l9, u9, i10, t8, r7) {
  var o11, f7, e11;
  if (void 0 !== l9.__d)
    o11 = l9.__d, l9.__d = void 0;
  else if (null == u9 || t8 != r7 || null == t8.parentNode)
    n:
      if (null == r7 || r7.parentNode !== n8)
        n8.appendChild(t8), o11 = null;
      else {
        for (f7 = r7, e11 = 0; (f7 = f7.nextSibling) && e11 < i10.length; e11 += 1)
          if (f7 == t8)
            break n;
        n8.insertBefore(t8, r7), o11 = r7;
      }
  return void 0 !== o11 ? o11 : t8.nextSibling;
}
function $8(n8) {
  var l9, u9, i10;
  if (null == n8.type || "string" == typeof n8.type)
    return n8.__e;
  if (n8.__k) {
    for (l9 = n8.__k.length - 1; l9 >= 0; l9--)
      if ((u9 = n8.__k[l9]) && (i10 = $8(u9)))
        return i10;
  }
  return null;
}
function H8(n8, l9, u9, i10, t8) {
  var r7;
  for (r7 in u9)
    "children" === r7 || "key" === r7 || r7 in l9 || T3(n8, r7, null, u9[r7], i10);
  for (r7 in l9)
    t8 && "function" != typeof l9[r7] || "children" === r7 || "key" === r7 || "value" === r7 || "checked" === r7 || u9[r7] === l9[r7] || T3(n8, r7, l9[r7], u9[r7], i10);
}
function I7(n8, l9, u9) {
  "-" === l9[0] ? n8.setProperty(l9, null == u9 ? "" : u9) : n8[l9] = null == u9 ? "" : "number" != typeof u9 || a6.test(l9) ? u9 : u9 + "px";
}
function T3(n8, l9, u9, i10, t8) {
  var r7;
  n:
    if ("style" === l9)
      if ("string" == typeof u9)
        n8.style.cssText = u9;
      else {
        if ("string" == typeof i10 && (n8.style.cssText = i10 = ""), i10)
          for (l9 in i10)
            u9 && l9 in u9 || I7(n8.style, l9, "");
        if (u9)
          for (l9 in u9)
            i10 && u9[l9] === i10[l9] || I7(n8.style, l9, u9[l9]);
      }
    else if ("o" === l9[0] && "n" === l9[1])
      r7 = l9 !== (l9 = l9.replace(/Capture$/, "")), l9 = l9.toLowerCase() in n8 ? l9.toLowerCase().slice(2) : l9.slice(2), n8.l || (n8.l = {}), n8.l[l9 + r7] = u9, u9 ? i10 || n8.addEventListener(l9, r7 ? z5 : j4, r7) : n8.removeEventListener(l9, r7 ? z5 : j4, r7);
    else if ("dangerouslySetInnerHTML" !== l9) {
      if (t8)
        l9 = l9.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l9 && "height" !== l9 && "href" !== l9 && "list" !== l9 && "form" !== l9 && "tabIndex" !== l9 && "download" !== l9 && l9 in n8)
        try {
          n8[l9] = null == u9 ? "" : u9;
          break n;
        } catch (n9) {
        }
      "function" == typeof u9 || (null == u9 || false === u9 && "-" !== l9[4] ? n8.removeAttribute(l9) : n8.setAttribute(l9, u9));
    }
}
function j4(n8) {
  return this.l[n8.type + false](l7.event ? l7.event(n8) : n8);
}
function z5(n8) {
  return this.l[n8.type + true](l7.event ? l7.event(n8) : n8);
}
function L5(n8, u9, i10, t8, r7, o11, f7, e11, c8) {
  var s11, a9, v7, y10, p10, d9, b10, g9, m11, w11, A10, P10, C10, $10, H10, I9 = u9.type;
  if (void 0 !== u9.constructor)
    return null;
  null != i10.__h && (c8 = i10.__h, e11 = u9.__e = i10.__e, u9.__h = null, o11 = [e11]), (s11 = l7.__b) && s11(u9);
  try {
    n:
      if ("function" == typeof I9) {
        if (g9 = u9.props, m11 = (s11 = I9.contextType) && t8[s11.__c], w11 = s11 ? m11 ? m11.props.value : s11.__ : t8, i10.__c ? b10 = (a9 = u9.__c = i10.__c).__ = a9.__E : ("prototype" in I9 && I9.prototype.render ? u9.__c = a9 = new I9(g9, w11) : (u9.__c = a9 = new k5(g9, w11), a9.constructor = I9, a9.render = q5), m11 && m11.sub(a9), a9.props = g9, a9.state || (a9.state = {}), a9.context = w11, a9.__n = t8, v7 = a9.__d = true, a9.__h = [], a9._sb = []), null == a9.__s && (a9.__s = a9.state), null != I9.getDerivedStateFromProps && (a9.__s == a9.state && (a9.__s = h8({}, a9.__s)), h8(a9.__s, I9.getDerivedStateFromProps(g9, a9.__s))), y10 = a9.props, p10 = a9.state, a9.__v = u9, v7)
          null == I9.getDerivedStateFromProps && null != a9.componentWillMount && a9.componentWillMount(), null != a9.componentDidMount && a9.__h.push(a9.componentDidMount);
        else {
          if (null == I9.getDerivedStateFromProps && g9 !== y10 && null != a9.componentWillReceiveProps && a9.componentWillReceiveProps(g9, w11), !a9.__e && null != a9.shouldComponentUpdate && false === a9.shouldComponentUpdate(g9, a9.__s, w11) || u9.__v === i10.__v) {
            for (u9.__v !== i10.__v && (a9.props = g9, a9.state = a9.__s, a9.__d = false), a9.__e = false, u9.__e = i10.__e, u9.__k = i10.__k, u9.__k.forEach(function(n9) {
              n9 && (n9.__ = u9);
            }), A10 = 0; A10 < a9._sb.length; A10++)
              a9.__h.push(a9._sb[A10]);
            a9._sb = [], a9.__h.length && f7.push(a9);
            break n;
          }
          null != a9.componentWillUpdate && a9.componentWillUpdate(g9, a9.__s, w11), null != a9.componentDidUpdate && a9.__h.push(function() {
            a9.componentDidUpdate(y10, p10, d9);
          });
        }
        if (a9.context = w11, a9.props = g9, a9.__P = n8, P10 = l7.__r, C10 = 0, "prototype" in I9 && I9.prototype.render) {
          for (a9.state = a9.__s, a9.__d = false, P10 && P10(u9), s11 = a9.render(a9.props, a9.state, a9.context), $10 = 0; $10 < a9._sb.length; $10++)
            a9.__h.push(a9._sb[$10]);
          a9._sb = [];
        } else
          do {
            a9.__d = false, P10 && P10(u9), s11 = a9.render(a9.props, a9.state, a9.context), a9.state = a9.__s;
          } while (a9.__d && ++C10 < 25);
        a9.state = a9.__s, null != a9.getChildContext && (t8 = h8(h8({}, t8), a9.getChildContext())), v7 || null == a9.getSnapshotBeforeUpdate || (d9 = a9.getSnapshotBeforeUpdate(y10, p10)), H10 = null != s11 && s11.type === _6 && null == s11.key ? s11.props.children : s11, x5(n8, Array.isArray(H10) ? H10 : [H10], u9, i10, t8, r7, o11, f7, e11, c8), a9.base = u9.__e, u9.__h = null, a9.__h.length && f7.push(a9), b10 && (a9.__E = a9.__ = null), a9.__e = false;
      } else
        null == o11 && u9.__v === i10.__v ? (u9.__k = i10.__k, u9.__e = i10.__e) : u9.__e = N14(i10.__e, u9, i10, t8, r7, o11, f7, c8);
    (s11 = l7.diffed) && s11(u9);
  } catch (n9) {
    u9.__v = null, (c8 || null != o11) && (u9.__e = e11, u9.__h = !!c8, o11[o11.indexOf(e11)] = null), l7.__e(n9, u9, i10);
  }
}
function M7(n8, u9) {
  l7.__c && l7.__c(u9, n8), n8.some(function(u10) {
    try {
      n8 = u10.__h, u10.__h = [], n8.some(function(n9) {
        n9.call(u10);
      });
    } catch (n9) {
      l7.__e(n9, u10.__v);
    }
  });
}
function N14(l9, u9, i10, t8, r7, o11, f7, e11) {
  var s11, a9, h11, y10 = i10.props, p10 = u9.props, d9 = u9.type, _8 = 0;
  if ("svg" === d9 && (r7 = true), null != o11) {
    for (; _8 < o11.length; _8++)
      if ((s11 = o11[_8]) && "setAttribute" in s11 == !!d9 && (d9 ? s11.localName === d9 : 3 === s11.nodeType)) {
        l9 = s11, o11[_8] = null;
        break;
      }
  }
  if (null == l9) {
    if (null === d9)
      return document.createTextNode(p10);
    l9 = r7 ? document.createElementNS("http://www.w3.org/2000/svg", d9) : document.createElement(d9, p10.is && p10), o11 = null, e11 = false;
  }
  if (null === d9)
    y10 === p10 || e11 && l9.data === p10 || (l9.data = p10);
  else {
    if (o11 = o11 && n7.call(l9.childNodes), a9 = (y10 = i10.props || c6).dangerouslySetInnerHTML, h11 = p10.dangerouslySetInnerHTML, !e11) {
      if (null != o11)
        for (y10 = {}, _8 = 0; _8 < l9.attributes.length; _8++)
          y10[l9.attributes[_8].name] = l9.attributes[_8].value;
      (h11 || a9) && (h11 && (a9 && h11.__html == a9.__html || h11.__html === l9.innerHTML) || (l9.innerHTML = h11 && h11.__html || ""));
    }
    if (H8(l9, p10, y10, r7, e11), h11)
      u9.__k = [];
    else if (_8 = u9.props.children, x5(l9, Array.isArray(_8) ? _8 : [_8], u9, i10, t8, r7 && "foreignObject" !== d9, o11, f7, o11 ? o11[0] : i10.__k && b7(i10, 0), e11), null != o11)
      for (_8 = o11.length; _8--; )
        null != o11[_8] && v4(o11[_8]);
    e11 || ("value" in p10 && void 0 !== (_8 = p10.value) && (_8 !== l9.value || "progress" === d9 && !_8 || "option" === d9 && _8 !== y10.value) && T3(l9, "value", _8, y10.value, false), "checked" in p10 && void 0 !== (_8 = p10.checked) && _8 !== l9.checked && T3(l9, "checked", _8, y10.checked, false));
  }
  return l9;
}
function O6(n8, u9, i10) {
  try {
    "function" == typeof n8 ? n8(u9) : n8.current = u9;
  } catch (n9) {
    l7.__e(n9, i10);
  }
}
function S6(n8, u9, i10) {
  var t8, r7;
  if (l7.unmount && l7.unmount(n8), (t8 = n8.ref) && (t8.current && t8.current !== n8.__e || O6(t8, null, u9)), null != (t8 = n8.__c)) {
    if (t8.componentWillUnmount)
      try {
        t8.componentWillUnmount();
      } catch (n9) {
        l7.__e(n9, u9);
      }
    t8.base = t8.__P = null, n8.__c = void 0;
  }
  if (t8 = n8.__k)
    for (r7 = 0; r7 < t8.length; r7++)
      t8[r7] && S6(t8[r7], u9, i10 || "function" != typeof n8.type);
  i10 || null == n8.__e || v4(n8.__e), n8.__ = n8.__e = n8.__d = void 0;
}
function q5(n8, l9, u9) {
  return this.constructor(n8, u9);
}
function B6(u9, i10, t8) {
  var r7, o11, f7;
  l7.__ && l7.__(u9, i10), o11 = (r7 = "function" == typeof t8) ? null : t8 && t8.__k || i10.__k, f7 = [], L5(i10, u9 = (!r7 && t8 || i10).__k = y7(_6, null, [u9]), o11 || c6, c6, void 0 !== i10.ownerSVGElement, !r7 && t8 ? [t8] : o11 ? null : i10.firstChild ? n7.call(i10.childNodes) : null, f7, !r7 && t8 ? t8 : o11 ? o11.__e : i10.firstChild, r7), M7(f7, u9);
}
function D5(n8, l9) {
  B6(n8, l9, D5);
}
function E6(l9, u9, i10) {
  var t8, r7, o11, f7 = h8({}, l9.props);
  for (o11 in u9)
    "key" == o11 ? t8 = u9[o11] : "ref" == o11 ? r7 = u9[o11] : f7[o11] = u9[o11];
  return arguments.length > 2 && (f7.children = arguments.length > 3 ? n7.call(arguments, 2) : i10), p7(l9.type, f7, t8 || l9.key, r7 || l9.ref, null);
}
function F5(n8, l9) {
  var u9 = { __c: l9 = "__cC" + e9++, __: n8, Consumer: function(n9, l10) {
    return n9.children(l10);
  }, Provider: function(n9) {
    var u10, i10;
    return this.getChildContext || (u10 = [], (i10 = {})[l9] = this, this.getChildContext = function() {
      return i10;
    }, this.shouldComponentUpdate = function(n10) {
      this.props.value !== n10.value && u10.some(function(n11) {
        n11.__e = true, m8(n11);
      });
    }, this.sub = function(n10) {
      u10.push(n10);
      var l10 = n10.componentWillUnmount;
      n10.componentWillUnmount = function() {
        u10.splice(u10.indexOf(n10), 1), l10 && l10.call(n10);
      };
    }), n9.children;
  } };
  return u9.Provider.__ = u9.Consumer.contextType = u9;
}
var n7, l7, u7, i8, t6, r5, o9, f4, e9, c6, s8, a6;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    c6 = {};
    s8 = [];
    a6 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n7 = s8.slice, l7 = { __e: function(n8, l9, u9, i10) {
      for (var t8, r7, o11; l9 = l9.__; )
        if ((t8 = l9.__c) && !t8.__)
          try {
            if ((r7 = t8.constructor) && null != r7.getDerivedStateFromError && (t8.setState(r7.getDerivedStateFromError(n8)), o11 = t8.__d), null != t8.componentDidCatch && (t8.componentDidCatch(n8, i10 || {}), o11 = t8.__d), o11)
              return t8.__E = t8;
          } catch (l10) {
            n8 = l10;
          }
      throw n8;
    } }, u7 = 0, i8 = function(n8) {
      return null != n8 && void 0 === n8.constructor;
    }, k5.prototype.setState = function(n8, l9) {
      var u9;
      u9 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h8({}, this.state), "function" == typeof n8 && (n8 = n8(h8({}, u9), this.props)), n8 && h8(u9, n8), null != n8 && this.__v && (l9 && this._sb.push(l9), m8(this));
    }, k5.prototype.forceUpdate = function(n8) {
      this.__v && (this.__e = true, n8 && this.__h.push(n8), m8(this));
    }, k5.prototype.render = _6, t6 = [], o9 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f4 = function(n8, l9) {
      return n8.__v.__b - l9.__v.__b;
    }, w8.__r = 0, e9 = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function d7(t8, u9) {
  l7.__h && l7.__h(r6, t8, o10 || u9), o10 = 0;
  var i10 = r6.__H || (r6.__H = { __: [], __h: [] });
  return t8 >= i10.__.length && i10.__.push({ __V: c7 }), i10.__[t8];
}
function h9(n8) {
  return o10 = 1, s9(B7, n8);
}
function s9(n8, u9, i10) {
  var o11 = d7(t7++, 2);
  if (o11.t = n8, !o11.__c && (o11.__ = [i10 ? i10(u9) : B7(void 0, u9), function(n9) {
    var t8 = o11.__N ? o11.__N[0] : o11.__[0], r7 = o11.t(t8, n9);
    t8 !== r7 && (o11.__N = [r7, o11.__[1]], o11.__c.setState({}));
  }], o11.__c = r6, !r6.u)) {
    var f7 = function(n9, t8, r7) {
      if (!o11.__c.__H)
        return true;
      var u10 = o11.__c.__H.__.filter(function(n10) {
        return n10.__c;
      });
      if (u10.every(function(n10) {
        return !n10.__N;
      }))
        return !c8 || c8.call(this, n9, t8, r7);
      var i11 = false;
      return u10.forEach(function(n10) {
        if (n10.__N) {
          var t9 = n10.__[0];
          n10.__ = n10.__N, n10.__N = void 0, t9 !== n10.__[0] && (i11 = true);
        }
      }), !(!i11 && o11.__c.props === n9) && (!c8 || c8.call(this, n9, t8, r7));
    };
    r6.u = true;
    var c8 = r6.shouldComponentUpdate, e11 = r6.componentWillUpdate;
    r6.componentWillUpdate = function(n9, t8, r7) {
      if (this.__e) {
        var u10 = c8;
        c8 = void 0, f7(n9, t8, r7), c8 = u10;
      }
      e11 && e11.call(this, n9, t8, r7);
    }, r6.shouldComponentUpdate = f7;
  }
  return o11.__N || o11.__;
}
function p8(u9, i10) {
  var o11 = d7(t7++, 3);
  !l7.__s && z6(o11.__H, i10) && (o11.__ = u9, o11.i = i10, r6.__H.__h.push(o11));
}
function y8(u9, i10) {
  var o11 = d7(t7++, 4);
  !l7.__s && z6(o11.__H, i10) && (o11.__ = u9, o11.i = i10, r6.__h.push(o11));
}
function _7(n8) {
  return o10 = 5, F6(function() {
    return { current: n8 };
  }, []);
}
function A7(n8, t8, r7) {
  o10 = 6, y8(function() {
    return "function" == typeof n8 ? (n8(t8()), function() {
      return n8(null);
    }) : n8 ? (n8.current = t8(), function() {
      return n8.current = null;
    }) : void 0;
  }, null == r7 ? r7 : r7.concat(n8));
}
function F6(n8, r7) {
  var u9 = d7(t7++, 7);
  return z6(u9.__H, r7) ? (u9.__V = n8(), u9.i = r7, u9.__h = n8, u9.__V) : u9.__;
}
function T4(n8, t8) {
  return o10 = 8, F6(function() {
    return n8;
  }, t8);
}
function q6(n8) {
  var u9 = r6.context[n8.__c], i10 = d7(t7++, 9);
  return i10.c = n8, u9 ? (null == i10.__ && (i10.__ = true, u9.sub(r6)), u9.props.value) : n8.__;
}
function x6(t8, r7) {
  l7.useDebugValue && l7.useDebugValue(r7 ? r7(t8) : t8);
}
function P7(n8) {
  var u9 = d7(t7++, 10), i10 = h9();
  return u9.__ = n8, r6.componentDidCatch || (r6.componentDidCatch = function(n9, t8) {
    u9.__ && u9.__(n9, t8), i10[1](n9);
  }), [i10[0], function() {
    i10[1](void 0);
  }];
}
function V6() {
  var n8 = d7(t7++, 11);
  if (!n8.__) {
    for (var u9 = r6.__v; null !== u9 && !u9.__m && null !== u9.__; )
      u9 = u9.__;
    var i10 = u9.__m || (u9.__m = [0, 0]);
    n8.__ = "P" + i10[0] + "-" + i10[1]++;
  }
  return n8.__;
}
function b8() {
  for (var t8; t8 = f5.shift(); )
    if (t8.__P && t8.__H)
      try {
        t8.__H.__h.forEach(k6), t8.__H.__h.forEach(w9), t8.__H.__h = [];
      } catch (r7) {
        t8.__H.__h = [], l7.__e(r7, t8.__v);
      }
}
function j5(n8) {
  var t8, r7 = function() {
    clearTimeout(u9), g7 && cancelAnimationFrame(t8), setTimeout(n8);
  }, u9 = setTimeout(r7, 100);
  g7 && (t8 = requestAnimationFrame(r7));
}
function k6(n8) {
  var t8 = r6, u9 = n8.__c;
  "function" == typeof u9 && (n8.__c = void 0, u9()), r6 = t8;
}
function w9(n8) {
  var t8 = r6;
  n8.__c = n8.__(), r6 = t8;
}
function z6(n8, t8) {
  return !n8 || n8.length !== t8.length || t8.some(function(t9, r7) {
    return t9 !== n8[r7];
  });
}
function B7(n8, t8) {
  return "function" == typeof t8 ? t8(n8) : t8;
}
var t7, r6, u8, i9, o10, f5, c7, e10, a7, v5, l8, m9, g7;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o10 = 0;
    f5 = [];
    c7 = [];
    e10 = l7.__b;
    a7 = l7.__r;
    v5 = l7.diffed;
    l8 = l7.__c;
    m9 = l7.unmount;
    l7.__b = function(n8) {
      r6 = null, e10 && e10(n8);
    }, l7.__r = function(n8) {
      a7 && a7(n8), t7 = 0;
      var i10 = (r6 = n8.__c).__H;
      i10 && (u8 === r6 ? (i10.__h = [], r6.__h = [], i10.__.forEach(function(n9) {
        n9.__N && (n9.__ = n9.__N), n9.__V = c7, n9.__N = n9.i = void 0;
      })) : (i10.__h.forEach(k6), i10.__h.forEach(w9), i10.__h = [])), u8 = r6;
    }, l7.diffed = function(t8) {
      v5 && v5(t8);
      var o11 = t8.__c;
      o11 && o11.__H && (o11.__H.__h.length && (1 !== f5.push(o11) && i9 === l7.requestAnimationFrame || ((i9 = l7.requestAnimationFrame) || j5)(b8)), o11.__H.__.forEach(function(n8) {
        n8.i && (n8.__H = n8.i), n8.__V !== c7 && (n8.__ = n8.__V), n8.i = void 0, n8.__V = c7;
      })), u8 = r6 = null;
    }, l7.__c = function(t8, r7) {
      r7.some(function(t9) {
        try {
          t9.__h.forEach(k6), t9.__h = t9.__h.filter(function(n8) {
            return !n8.__ || w9(n8);
          });
        } catch (u9) {
          r7.some(function(n8) {
            n8.__h && (n8.__h = []);
          }), r7 = [], l7.__e(u9, t9.__v);
        }
      }), l8 && l8(t8, r7);
    }, l7.unmount = function(t8) {
      m9 && m9(t8);
      var r7, u9 = t8.__c;
      u9 && u9.__H && (u9.__H.__.forEach(function(n8) {
        try {
          k6(n8);
        } catch (n9) {
          r7 = n9;
        }
      }), u9.__H = void 0, r7 && l7.__e(r7, u9.__v));
    };
    g7 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => O7,
  Component: () => k5,
  Fragment: () => _6,
  PureComponent: () => w10,
  StrictMode: () => mn2,
  Suspense: () => D6,
  SuspenseList: () => V7,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => ln2,
  cloneElement: () => sn,
  createContext: () => F5,
  createElement: () => y7,
  createFactory: () => fn2,
  createPortal: () => z7,
  createRef: () => d6,
  default: () => Cn2,
  findDOMNode: () => vn2,
  flushSync: () => pn2,
  forwardRef: () => k7,
  hydrate: () => J5,
  isValidElement: () => an,
  lazy: () => M8,
  memo: () => x7,
  render: () => G7,
  startTransition: () => yn2,
  unmountComponentAtNode: () => hn2,
  unstable_batchedUpdates: () => dn2,
  useCallback: () => T4,
  useContext: () => q6,
  useDebugValue: () => x6,
  useDeferredValue: () => _n2,
  useEffect: () => p8,
  useErrorBoundary: () => P7,
  useId: () => V6,
  useImperativeHandle: () => A7,
  useInsertionEffect: () => Sn,
  useLayoutEffect: () => y8,
  useMemo: () => F6,
  useReducer: () => s9,
  useRef: () => _7,
  useState: () => h9,
  useSyncExternalStore: () => gn2,
  useTransition: () => bn2,
  version: () => cn
});
function g8(n8, t8) {
  for (var e11 in t8)
    n8[e11] = t8[e11];
  return n8;
}
function C8(n8, t8) {
  for (var e11 in n8)
    if ("__source" !== e11 && !(e11 in t8))
      return true;
  for (var r7 in t8)
    if ("__source" !== r7 && n8[r7] !== t8[r7])
      return true;
  return false;
}
function E7(n8, t8) {
  return n8 === t8 && (0 !== n8 || 1 / n8 == 1 / t8) || n8 != n8 && t8 != t8;
}
function w10(n8) {
  this.props = n8;
}
function x7(n8, e11) {
  function r7(n9) {
    var t8 = this.props.ref, r8 = t8 == n9.ref;
    return !r8 && t8 && (t8.call ? t8(null) : t8.current = null), e11 ? !e11(this.props, n9) || !r8 : C8(this.props, n9);
  }
  function u9(e12) {
    return this.shouldComponentUpdate = r7, y7(n8, e12);
  }
  return u9.displayName = "Memo(" + (n8.displayName || n8.name) + ")", u9.prototype.isReactComponent = true, u9.__f = true, u9;
}
function k7(n8) {
  function t8(t9) {
    var e11 = g8({}, t9);
    return delete e11.ref, n8(e11, t9.ref || null);
  }
  return t8.$$typeof = N15, t8.render = t8, t8.prototype.isReactComponent = t8.__f = true, t8.displayName = "ForwardRef(" + (n8.displayName || n8.name) + ")", t8;
}
function L6(n8, t8, e11) {
  return n8 && (n8.__c && n8.__c.__H && (n8.__c.__H.__.forEach(function(n9) {
    "function" == typeof n9.__c && n9.__c();
  }), n8.__c.__H = null), null != (n8 = g8({}, n8)).__c && (n8.__c.__P === e11 && (n8.__c.__P = t8), n8.__c = null), n8.__k = n8.__k && n8.__k.map(function(n9) {
    return L6(n9, t8, e11);
  })), n8;
}
function U4(n8, t8, e11) {
  return n8 && (n8.__v = null, n8.__k = n8.__k && n8.__k.map(function(n9) {
    return U4(n9, t8, e11);
  }), n8.__c && n8.__c.__P === t8 && (n8.__e && e11.insertBefore(n8.__e, n8.__d), n8.__c.__e = true, n8.__c.__P = e11)), n8;
}
function D6() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F7(n8) {
  var t8 = n8.__.__c;
  return t8 && t8.__a && t8.__a(n8);
}
function M8(n8) {
  var e11, r7, u9;
  function o11(o12) {
    if (e11 || (e11 = n8()).then(function(n9) {
      r7 = n9.default || n9;
    }, function(n9) {
      u9 = n9;
    }), u9)
      throw u9;
    if (!r7)
      throw e11;
    return y7(r7, o12);
  }
  return o11.displayName = "Lazy", o11.__f = true, o11;
}
function V7() {
  this.u = null, this.o = null;
}
function P8(n8) {
  return this.getChildContext = function() {
    return n8.context;
  }, n8.children;
}
function j6(n8) {
  var e11 = this, r7 = n8.i;
  e11.componentWillUnmount = function() {
    B6(null, e11.l), e11.l = null, e11.i = null;
  }, e11.i && e11.i !== r7 && e11.componentWillUnmount(), n8.__v ? (e11.l || (e11.i = r7, e11.l = { nodeType: 1, parentNode: r7, childNodes: [], appendChild: function(n9) {
    this.childNodes.push(n9), e11.i.appendChild(n9);
  }, insertBefore: function(n9, t8) {
    this.childNodes.push(n9), e11.i.appendChild(n9);
  }, removeChild: function(n9) {
    this.childNodes.splice(this.childNodes.indexOf(n9) >>> 1, 1), e11.i.removeChild(n9);
  } }), B6(y7(P8, { context: e11.context }, n8.__v), e11.l)) : e11.l && e11.componentWillUnmount();
}
function z7(n8, e11) {
  var r7 = y7(j6, { __v: n8, i: e11 });
  return r7.containerInfo = e11, r7;
}
function G7(n8, t8, e11) {
  return null == t8.__k && (t8.textContent = ""), B6(n8, t8), "function" == typeof e11 && e11(), n8 ? n8.__c : null;
}
function J5(n8, t8, e11) {
  return D5(n8, t8), "function" == typeof e11 && e11(), n8 ? n8.__c : null;
}
function Q5() {
}
function X5() {
  return this.cancelBubble;
}
function nn() {
  return this.defaultPrevented;
}
function fn2(n8) {
  return y7.bind(null, n8);
}
function an(n8) {
  return !!n8 && n8.$$typeof === B8;
}
function sn(n8) {
  return an(n8) ? E6.apply(null, arguments) : n8;
}
function hn2(n8) {
  return !!n8.__k && (B6(null, n8), true);
}
function vn2(n8) {
  return n8 && (n8.base || 1 === n8.nodeType && n8) || null;
}
function yn2(n8) {
  n8();
}
function _n2(n8) {
  return n8;
}
function bn2() {
  return [false, yn2];
}
function gn2(n8, t8) {
  var e11 = t8(), r7 = h9({ h: { __: e11, v: t8 } }), u9 = r7[0].h, o11 = r7[1];
  return y8(function() {
    u9.__ = e11, u9.v = t8, E7(u9.__, t8()) || o11({ h: u9 });
  }, [n8, e11, t8]), p8(function() {
    return E7(u9.__, u9.v()) || o11({ h: u9 }), n8(function() {
      E7(u9.__, u9.v()) || o11({ h: u9 });
    });
  }, [n8]), e11;
}
var R4, N15, A8, O7, T5, I8, W4, B8, H9, Z4, Y6, $9, q7, K5, tn, en, rn2, un2, on, ln2, cn, dn2, pn2, mn2, Sn, Cn2;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_preact_module();
    init_preact_module();
    init_hooks_module();
    init_hooks_module();
    (w10.prototype = new k5()).isPureReactComponent = true, w10.prototype.shouldComponentUpdate = function(n8, t8) {
      return C8(this.props, n8) || C8(this.state, t8);
    };
    R4 = l7.__b;
    l7.__b = function(n8) {
      n8.type && n8.type.__f && n8.ref && (n8.props.ref = n8.ref, n8.ref = null), R4 && R4(n8);
    };
    N15 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
    A8 = function(n8, t8) {
      return null == n8 ? null : P6(P6(n8).map(t8));
    };
    O7 = { map: A8, forEach: A8, count: function(n8) {
      return n8 ? P6(n8).length : 0;
    }, only: function(n8) {
      var t8 = P6(n8);
      if (1 !== t8.length)
        throw "Children.only";
      return t8[0];
    }, toArray: P6 };
    T5 = l7.__e;
    l7.__e = function(n8, t8, e11, r7) {
      if (n8.then) {
        for (var u9, o11 = t8; o11 = o11.__; )
          if ((u9 = o11.__c) && u9.__c)
            return null == t8.__e && (t8.__e = e11.__e, t8.__k = e11.__k), u9.__c(n8, t8);
      }
      T5(n8, t8, e11, r7);
    };
    I8 = l7.unmount;
    l7.unmount = function(n8) {
      var t8 = n8.__c;
      t8 && t8.__R && t8.__R(), t8 && true === n8.__h && (n8.type = null), I8 && I8(n8);
    }, (D6.prototype = new k5()).__c = function(n8, t8) {
      var e11 = t8.__c, r7 = this;
      null == r7.t && (r7.t = []), r7.t.push(e11);
      var u9 = F7(r7.__v), o11 = false, i10 = function() {
        o11 || (o11 = true, e11.__R = null, u9 ? u9(l9) : l9());
      };
      e11.__R = i10;
      var l9 = function() {
        if (!--r7.__u) {
          if (r7.state.__a) {
            var n9 = r7.state.__a;
            r7.__v.__k[0] = U4(n9, n9.__c.__P, n9.__c.__O);
          }
          var t9;
          for (r7.setState({ __a: r7.__b = null }); t9 = r7.t.pop(); )
            t9.forceUpdate();
        }
      }, c8 = true === t8.__h;
      r7.__u++ || c8 || r7.setState({ __a: r7.__b = r7.__v.__k[0] }), n8.then(i10, i10);
    }, D6.prototype.componentWillUnmount = function() {
      this.t = [];
    }, D6.prototype.render = function(n8, e11) {
      if (this.__b) {
        if (this.__v.__k) {
          var r7 = document.createElement("div"), o11 = this.__v.__k[0].__c;
          this.__v.__k[0] = L6(this.__b, r7, o11.__O = o11.__P);
        }
        this.__b = null;
      }
      var i10 = e11.__a && y7(_6, null, n8.fallback);
      return i10 && (i10.__h = null), [y7(_6, null, e11.__a ? null : n8.children), i10];
    };
    W4 = function(n8, t8, e11) {
      if (++e11[1] === e11[0] && n8.o.delete(t8), n8.props.revealOrder && ("t" !== n8.props.revealOrder[0] || !n8.o.size))
        for (e11 = n8.u; e11; ) {
          for (; e11.length > 3; )
            e11.pop()();
          if (e11[1] < e11[0])
            break;
          n8.u = e11 = e11[2];
        }
    };
    (V7.prototype = new k5()).__a = function(n8) {
      var t8 = this, e11 = F7(t8.__v), r7 = t8.o.get(n8);
      return r7[0]++, function(u9) {
        var o11 = function() {
          t8.props.revealOrder ? (r7.push(u9), W4(t8, n8, r7)) : u9();
        };
        e11 ? e11(o11) : o11();
      };
    }, V7.prototype.render = function(n8) {
      this.u = null, this.o = /* @__PURE__ */ new Map();
      var t8 = P6(n8.children);
      n8.revealOrder && "b" === n8.revealOrder[0] && t8.reverse();
      for (var e11 = t8.length; e11--; )
        this.o.set(t8[e11], this.u = [1, 0, this.u]);
      return n8.children;
    }, V7.prototype.componentDidUpdate = V7.prototype.componentDidMount = function() {
      var n8 = this;
      this.o.forEach(function(t8, e11) {
        W4(n8, e11, t8);
      });
    };
    B8 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    H9 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    Z4 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
    Y6 = /[A-Z0-9]/g;
    $9 = "undefined" != typeof document;
    q7 = function(n8) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n8);
    };
    k5.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t8) {
      Object.defineProperty(k5.prototype, t8, { configurable: true, get: function() {
        return this["UNSAFE_" + t8];
      }, set: function(n8) {
        Object.defineProperty(this, t8, { configurable: true, writable: true, value: n8 });
      } });
    });
    K5 = l7.event;
    l7.event = function(n8) {
      return K5 && (n8 = K5(n8)), n8.persist = Q5, n8.isPropagationStopped = X5, n8.isDefaultPrevented = nn, n8.nativeEvent = n8;
    };
    en = { enumerable: false, configurable: true, get: function() {
      return this.class;
    } };
    rn2 = l7.vnode;
    l7.vnode = function(n8) {
      "string" == typeof n8.type && function(n9) {
        var t8 = n9.props, e11 = n9.type, u9 = {};
        for (var o11 in t8) {
          var i10 = t8[o11];
          if (!("value" === o11 && "defaultValue" in t8 && null == i10 || $9 && "children" === o11 && "noscript" === e11 || "class" === o11 || "className" === o11)) {
            var l9 = o11.toLowerCase();
            "defaultValue" === o11 && "value" in t8 && null == t8.value ? o11 = "value" : "download" === o11 && true === i10 ? i10 = "" : "ondoubleclick" === l9 ? o11 = "ondblclick" : "onchange" !== l9 || "input" !== e11 && "textarea" !== e11 || q7(t8.type) ? "onfocus" === l9 ? o11 = "onfocusin" : "onblur" === l9 ? o11 = "onfocusout" : Z4.test(o11) ? o11 = l9 : -1 === e11.indexOf("-") && H9.test(o11) ? o11 = o11.replace(Y6, "-$&").toLowerCase() : null === i10 && (i10 = void 0) : l9 = o11 = "oninput", "oninput" === l9 && u9[o11 = l9] && (o11 = "oninputCapture"), u9[o11] = i10;
          }
        }
        "select" == e11 && u9.multiple && Array.isArray(u9.value) && (u9.value = P6(t8.children).forEach(function(n10) {
          n10.props.selected = -1 != u9.value.indexOf(n10.props.value);
        })), "select" == e11 && null != u9.defaultValue && (u9.value = P6(t8.children).forEach(function(n10) {
          n10.props.selected = u9.multiple ? -1 != u9.defaultValue.indexOf(n10.props.value) : u9.defaultValue == n10.props.value;
        })), t8.class && !t8.className ? (u9.class = t8.class, Object.defineProperty(u9, "className", en)) : (t8.className && !t8.class || t8.class && t8.className) && (u9.class = u9.className = t8.className), n9.props = u9;
      }(n8), n8.$$typeof = B8, rn2 && rn2(n8);
    };
    un2 = l7.__r;
    l7.__r = function(n8) {
      un2 && un2(n8), tn = n8.__c;
    };
    on = l7.diffed;
    l7.diffed = function(n8) {
      on && on(n8);
      var t8 = n8.props, e11 = n8.__e;
      null != e11 && "textarea" === n8.type && "value" in t8 && t8.value !== e11.value && (e11.value = null == t8.value ? "" : t8.value), tn = null;
    };
    ln2 = { ReactCurrentDispatcher: { current: { readContext: function(n8) {
      return tn.__n[n8.__c].props.value;
    } } } };
    cn = "17.0.2";
    dn2 = function(n8, t8) {
      return n8(t8);
    };
    pn2 = function(n8, t8) {
      return n8(t8);
    };
    mn2 = _6;
    Sn = y8;
    Cn2 = { useState: h9, useId: V6, useReducer: s9, useEffect: p8, useLayoutEffect: y8, useInsertionEffect: Sn, useTransition: bn2, useDeferredValue: _n2, useSyncExternalStore: gn2, startTransition: yn2, useRef: _7, useImperativeHandle: A7, useMemo: F6, useCallback: T4, useContext: q6, useDebugValue: x6, version: "17.0.2", Children: O7, render: G7, hydrate: J5, unmountComponentAtNode: hn2, createPortal: z7, createElement: y7, createContext: F5, createFactory: fn2, cloneElement: sn, createRef: d6, Fragment: _6, isValidElement: an, findDOMNode: vn2, Component: k5, PureComponent: w10, memo: x7, forwardRef: k7, flushSync: pn2, unstable_batchedUpdates: dn2, StrictMode: mn2, Suspense: D6, SuspenseList: V7, lazy: M8, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ln2 };
  }
});

// node_modules/@walletconnect/legacy-modal/dist/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@walletconnect/legacy-modal/dist/cjs/index.js"(exports, module) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var legacyUtils = (init_esm12(), __toCommonJS(esm_exports6));
    var QRCode = _interopDefault(require_browser5());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e11) {
        return recover(e11);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3EWalletConnect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3E %3Cpath d='M61.4385429,36.2562612 C110.349767,-11.6319051 189.65053,-11.6319051 238.561752,36.2562612 L244.448297,42.0196786 C246.893858,44.4140867 246.893858,48.2961898 244.448297,50.690599 L224.311602,70.406102 C223.088821,71.6033071 221.106302,71.6033071 219.883521,70.406102 L211.782937,62.4749541 C177.661245,29.0669724 122.339051,29.0669724 88.2173582,62.4749541 L79.542302,70.9685592 C78.3195204,72.1657633 76.337001,72.1657633 75.1142214,70.9685592 L54.9775265,51.2530561 C52.5319653,48.8586469 52.5319653,44.9765439 54.9775265,42.5821357 L61.4385429,36.2562612 Z M280.206339,77.0300061 L298.128036,94.5769031 C300.573585,96.9713 300.573599,100.85338 298.128067,103.247793 L217.317896,182.368927 C214.872352,184.763353 210.907314,184.76338 208.461736,182.368989 C208.461726,182.368979 208.461714,182.368967 208.461704,182.368957 L151.107561,126.214385 C150.496171,125.615783 149.504911,125.615783 148.893521,126.214385 C148.893517,126.214389 148.893514,126.214393 148.89351,126.214396 L91.5405888,182.368927 C89.095052,184.763359 85.1300133,184.763399 82.6844276,182.369014 C82.6844133,182.369 82.684398,182.368986 82.6843827,182.36897 L1.87196327,103.246785 C-0.573596939,100.852377 -0.573596939,96.9702735 1.87196327,94.5758653 L19.7936929,77.028998 C22.2392531,74.6345898 26.2042918,74.6345898 28.6498531,77.028998 L86.0048306,133.184355 C86.6162214,133.782957 87.6074796,133.782957 88.2188704,133.184355 C88.2188796,133.184346 88.2188878,133.184338 88.2188969,133.184331 L145.571,77.028998 C148.016505,74.6345347 151.981544,74.6344449 154.427161,77.028798 C154.427195,77.0288316 154.427229,77.0288653 154.427262,77.028899 L211.782164,133.184331 C212.393554,133.782932 213.384814,133.782932 213.996204,133.184331 L271.350179,77.0300061 C273.79574,74.6355969 277.760778,74.6355969 280.206339,77.0300061 Z' id='WalletConnect'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg width='8' height='18' viewBox='0 0 8 18' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0.586301 0.213898C0.150354 0.552968 0.0718197 1.18124 0.41089 1.61719L5.2892 7.88931C5.57007 8.25042 5.57007 8.75608 5.2892 9.11719L0.410889 15.3893C0.071819 15.8253 0.150353 16.4535 0.586301 16.7926C1.02225 17.1317 1.65052 17.0531 1.98959 16.6172L6.86791 10.3451C7.7105 9.26174 7.7105 7.74476 6.86791 6.66143L1.98959 0.38931C1.65052 -0.0466374 1.02225 -0.125172 0.586301 0.213898Z' fill='%233C4252'/%3E %3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name2), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name2));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = legacyUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_8, index2) {
        return index2 + 1 >= range[0] && index2 + 1 <= range[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e11) {
        setInput(e11.target.value);
        clearTimeout(filterTimeout);
        if (e11.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e11.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name2 = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = legacyUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          legacyUtils.saveMobileLinkInfo({
            name: name2,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name: name2,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name2,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          legacyUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_8, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data2) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data2, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e11) {
        return Promise.reject(e11);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e11) {
          Promise.reject(e11);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification, {
        message: notification
      }));
    }
    function Modal(props) {
      var android = legacyUtils.isAndroid();
      var mobile = legacyUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : legacyUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform = mobile ? "mobile" : "desktop";
                    var _links = legacyUtils.getMobileLinkRegistry(legacyUtils.formatMobileRegistry(registry, platform), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(legacyUtils.formatIOSMobile(props.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e11) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e11);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e11) {
              return Promise.reject(e11);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return legacyUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
        links,
        errorMessage
      })))));
    }
    var de3 = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en2 = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es3 = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr2 = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko2 = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt4 = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa2 = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de: de3,
      en: en2,
      es: es3,
      fr: fr2,
      ko: ko2,
      pt: pt4,
      zh,
      fa: fa2
    };
    function injectStyleSheet() {
      var doc = legacyUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style2 = doc.createElement("style");
      style2.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style2.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style2);
    }
    function renderWrapper() {
      var doc = legacyUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = legacyUtils.getDocumentOrThrow();
      var modal2 = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal2) {
        modal2.className = modal2.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = legacyUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// node_modules/@walletconnect/legacy-provider/dist/esm/signer.js
var import_events11, import_legacy_modal, SignerConnection;
var init_signer = __esm({
  "node_modules/@walletconnect/legacy-provider/dist/esm/signer.js"() {
    import_events11 = __toESM(require_events());
    init_esm13();
    import_legacy_modal = __toESM(require_cjs8());
    init_esm5();
    init_esm6();
    SignerConnection = class extends IJsonRpcConnection {
      constructor(opts) {
        super();
        this.events = new import_events11.default();
        this.accounts = [];
        this.chainId = 1;
        this.pending = false;
        this.bridge = "https://bridge.walletconnect.org";
        this.qrcode = true;
        this.qrcodeModalOptions = void 0;
        this.opts = opts;
        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
        this.wc = this.register(opts);
      }
      get connected() {
        return typeof this.wc !== "undefined" && this.wc.connected;
      }
      get connecting() {
        return this.pending;
      }
      get connector() {
        this.wc = this.register(this.opts);
        return this.wc;
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      async open(chainId) {
        if (this.connected) {
          this.onOpen();
          return;
        }
        return new Promise((resolve, reject) => {
          this.on("error", (err) => {
            reject(err);
          });
          this.on("open", () => {
            resolve();
          });
          this.create(chainId);
        });
      }
      async close() {
        if (typeof this.wc === "undefined")
          return;
        if (this.wc.connected) {
          this.wc.killSession();
        }
        this.onClose();
      }
      async send(payload) {
        this.wc = this.register(this.opts);
        if (!this.connected)
          await this.open();
        this.sendPayload(payload).then((res) => this.events.emit("payload", res)).catch((e11) => this.events.emit("payload", formatJsonRpcError(payload.id, e11.message)));
      }
      register(opts) {
        if (this.wc)
          return this.wc;
        this.opts = opts || this.opts;
        this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
        this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
        this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
        this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
        const connectorOpts = {
          bridge: this.bridge,
          qrcodeModal: this.qrcode ? import_legacy_modal.default : void 0,
          qrcodeModalOptions: this.qrcodeModalOptions,
          storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
          signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
          clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
        };
        this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new esm_default3(connectorOpts);
        if (typeof this.wc === "undefined") {
          throw new Error("Failed to register WalletConnect connector");
        }
        if (this.wc.accounts.length) {
          this.accounts = this.wc.accounts;
        }
        if (this.wc.chainId) {
          this.chainId = this.wc.chainId;
        }
        this.registerConnectorEvents();
        return this.wc;
      }
      onOpen(wc) {
        this.pending = false;
        if (wc) {
          this.wc = wc;
        }
        this.events.emit("open");
      }
      onClose() {
        this.pending = false;
        if (this.wc) {
          this.wc = void 0;
        }
        this.events.emit("close");
      }
      onError(payload, message = "Failed or Rejected Request", code2 = -32e3) {
        const errorPayload = {
          id: payload.id,
          jsonrpc: payload.jsonrpc,
          error: { code: code2, message }
        };
        this.events.emit("payload", errorPayload);
        return errorPayload;
      }
      create(chainId) {
        this.wc = this.register(this.opts);
        this.chainId = chainId || this.chainId;
        if (this.connected || this.pending)
          return;
        this.pending = true;
        this.registerConnectorEvents();
        this.wc.createSession({ chainId: this.chainId }).then(() => this.events.emit("created")).catch((e11) => this.events.emit("error", e11));
      }
      registerConnectorEvents() {
        this.wc = this.register(this.opts);
        this.wc.on("connect", (err) => {
          var _a2, _b;
          if (err) {
            this.events.emit("error", err);
            return;
          }
          this.accounts = ((_a2 = this.wc) === null || _a2 === void 0 ? void 0 : _a2.accounts) || [];
          this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;
          this.onOpen();
        });
        this.wc.on("disconnect", (err) => {
          if (err) {
            this.events.emit("error", err);
            return;
          }
          this.onClose();
        });
        this.wc.on("modal_closed", () => {
          this.events.emit("error", new Error("User closed modal"));
        });
        this.wc.on("session_update", (error, payload) => {
          const { accounts, chainId } = payload.params[0];
          if (!this.accounts || accounts && this.accounts !== accounts) {
            this.accounts = accounts;
            this.events.emit("accountsChanged", accounts);
          }
          if (!this.chainId || chainId && this.chainId !== chainId) {
            this.chainId = chainId;
            this.events.emit("chainChanged", chainId);
          }
        });
      }
      async sendPayload(payload) {
        this.wc = this.register(this.opts);
        try {
          const response = await this.wc.unsafeSend(payload);
          return this.sanitizeResponse(response);
        } catch (error) {
          return this.onError(payload, error.message);
        }
      }
      sanitizeResponse(response) {
        return typeof response.error !== "undefined" && typeof response.error.code === "undefined" ? formatJsonRpcError(response.id, response.error.message, response.error.data) : response;
      }
    };
  }
});

// node_modules/@walletconnect/legacy-provider/dist/esm/index.js
var esm_exports7 = {};
__export(esm_exports7, {
  default: () => esm_default4
});
var import_events12, WalletConnectProvider, esm_default4;
var init_esm14 = __esm({
  "node_modules/@walletconnect/legacy-provider/dist/esm/index.js"() {
    import_events12 = __toESM(require_events());
    init_esm7();
    init_esm9();
    init_esm10();
    init_esm12();
    init_signer();
    WalletConnectProvider = class {
      constructor(opts) {
        this.events = new import_events12.default();
        this.rpc = { infuraId: opts === null || opts === void 0 ? void 0 : opts.infuraId, custom: opts === null || opts === void 0 ? void 0 : opts.rpc };
        this.signer = new JsonRpcProvider2(new SignerConnection(opts));
        const chainId = this.signer.connection.chainId || (opts === null || opts === void 0 ? void 0 : opts.chainId) || 1;
        this.http = this.setHttpProvider(chainId);
        this.registerEventListeners();
      }
      get connected() {
        return this.signer.connection.connected;
      }
      get connector() {
        return this.signer.connection.connector;
      }
      get accounts() {
        return this.signer.connection.accounts;
      }
      get chainId() {
        return this.signer.connection.chainId;
      }
      get rpcUrl() {
        var _a2;
        return ((_a2 = this.http) === null || _a2 === void 0 ? void 0 : _a2.connection).url || "";
      }
      async request(args) {
        switch (args.method) {
          case "eth_requestAccounts":
            await this.connect();
            return this.signer.connection.accounts;
          case "eth_accounts":
            return this.signer.connection.accounts;
          case "eth_chainId":
            return this.signer.connection.chainId;
          default:
            break;
        }
        if (SIGNING_METHODS.includes(args.method)) {
          return this.signer.request(args);
        }
        if (typeof this.http === "undefined") {
          throw new Error(`Cannot request JSON-RPC method (${args.method}) without provided rpc url`);
        }
        return this.http.request(args);
      }
      sendAsync(args, callback) {
        this.request(args).then((response) => callback(null, response)).catch((error) => callback(error, void 0));
      }
      async enable() {
        const accounts = await this.request({ method: "eth_requestAccounts" });
        return accounts;
      }
      async connect() {
        if (!this.signer.connection.connected) {
          await this.signer.connect();
        }
      }
      async disconnect() {
        if (this.signer.connection.connected) {
          await this.signer.disconnect();
        }
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      get isWalletConnect() {
        return true;
      }
      registerEventListeners() {
        this.signer.connection.on("accountsChanged", (accounts) => {
          this.events.emit("accountsChanged", accounts);
        });
        this.signer.connection.on("chainChanged", (chainId) => {
          this.http = this.setHttpProvider(chainId);
          this.events.emit("chainChanged", chainId);
        });
        this.signer.on("disconnect", () => {
          this.events.emit("disconnect");
        });
      }
      setHttpProvider(chainId) {
        const rpcUrl = getRpcUrl(chainId, this.rpc);
        if (typeof rpcUrl === "undefined")
          return void 0;
        const http = new JsonRpcProvider2(new HttpConnection(rpcUrl));
        return http;
      }
    };
    esm_default4 = WalletConnectProvider;
  }
});

// node_modules/@wagmi/chains/dist/index.mjs
var arbitrum = {
  id: 42161,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-mainnet.infura.io/v3"],
      webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
    default: { name: "Arbiscan", url: "https://arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
};
var arbitrumGoerli = {
  id: 421613,
  name: "Arbitrum Goerli",
  network: "arbitrum-goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-goerli.infura.io/v3"],
      webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" },
    default: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
};
var aurora = {
  id: 1313161554,
  name: "Aurora",
  network: "aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
    default: { http: ["https://mainnet.aurora.dev"] },
    public: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
    default: { name: "Aurorascan", url: "https://aurorascan.dev" }
  }
};
var auroraTestnet = {
  id: 1313161555,
  name: "Aurora Testnet",
  network: "aurora-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    infura: { http: ["https://aurora-testnet.infura.io/v3"] },
    default: { http: ["https://testnet.aurora.dev"] },
    public: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
    default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
  },
  testnet: true
};
var avalanche = {
  id: 43114,
  name: "Avalanche",
  network: "avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
    public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
    default: { name: "SnowTrace", url: "https://snowtrace.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
};
var avalancheFuji = {
  id: 43113,
  name: "Avalanche Fuji",
  network: "avalanche-fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
    public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
    default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
};
var baseGoerli = {
  id: 84531,
  network: "base-goerli",
  name: "Base Goerli",
  nativeCurrency: { name: "Base Goerli", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.base.org"]
    },
    public: {
      http: ["https://goerli.base.org"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Basescan",
      url: "https://goerli.basescan.org"
    },
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org"
    }
  },
  testnet: true
};
var boba = {
  id: 288,
  name: "Boba Network",
  network: "boba",
  nativeCurrency: {
    decimals: 18,
    name: "Boba",
    symbol: "BOBA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] },
    public: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
    default: { name: "BOBAScan", url: "https://bobascan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
};
var bronos = {
  id: 1039,
  name: "Bronos",
  network: "bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] },
    public: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: { name: "BronoScan", url: "https://broscan.bronos.org" }
  }
};
var bronosTestnet = {
  id: 1038,
  name: "Bronos Testnet",
  network: "bronos-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] },
    public: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
  },
  testnet: true
};
var bsc = {
  id: 56,
  name: "BNB Smart Chain",
  network: "bsc",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/bsc"] },
    public: { http: ["https://rpc.ankr.com/bsc"] }
  },
  blockExplorers: {
    etherscan: { name: "BscScan", url: "https://bscscan.com" },
    default: { name: "BscScan", url: "https://bscscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
};
var bscTestnet = {
  id: 97,
  name: "Binance Smart Chain Testnet",
  network: "bsc-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] },
    public: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] }
  },
  blockExplorers: {
    etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
    default: { name: "BscScan", url: "https://testnet.bscscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
};
var canto = {
  id: 7700,
  name: "Canto",
  network: "canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.slingshot.finance"] },
    public: { http: ["https://canto.slingshot.finance"] }
  },
  blockExplorers: {
    default: {
      name: "Canto EVM Explorer (Blockscout)",
      url: "https://evm.explorer.canto.io"
    }
  }
};
var celo = {
  id: 42220,
  name: "Celo",
  network: "celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] },
    infura: {
      http: ["https://celo-mainnet.infura.io/v3"]
    },
    public: {
      http: ["https://forno.celo.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://explorer.celo.org/mainnet"
    },
    etherscan: { name: "CeloScan", url: "https://celoscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
};
var celoAlfajores = {
  id: 44787,
  name: "Alfajores",
  network: "celo-alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    },
    infura: {
      http: ["https://celo-alfajores.infura.io/v3"]
    },
    public: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://explorer.celo.org/alfajores"
    },
    etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    }
  },
  testnet: true
};
var cronos = {
  id: 25,
  name: "Cronos",
  network: "cronos",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://node.croswap.com/rpc"] },
    public: { http: ["https://node.croswap.com/rpc"] }
  },
  blockExplorers: {
    etherscan: { name: "CronosScan", url: "https://cronoscan.com" },
    default: { name: "CronosScan", url: "https://cronoscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
};
var crossbell = {
  id: 3737,
  network: "crossbell",
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    },
    public: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: { name: "CrossScan", url: "https://scan.crossbell.io" }
  },
  contracts: {
    multicall3: {
      address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
      blockCreated: 23499787
    }
  }
};
var dfk = {
  id: 53935,
  name: "DFK Chain",
  network: "dfk",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    },
    public: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    },
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  }
};
var dogechain = {
  id: 2e3,
  name: "Dogechain",
  network: "dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Dogechain",
    symbol: "DC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] },
    public: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    etherscan: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog"
    },
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog"
    }
  }
};
var evmos = {
  id: 9001,
  name: "Evmos",
  network: "evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] },
    public: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: { name: "Evmos Block Explorer", url: "https://escan.live/" }
  }
};
var evmosTestnet = {
  id: 9e3,
  name: "Evmos Testnet",
  network: "evmos-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] },
    public: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
};
var fantom = {
  id: 250,
  name: "Fantom",
  network: "fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/fantom"] },
    public: { http: ["https://rpc.ankr.com/fantom"] }
  },
  blockExplorers: {
    etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
    default: { name: "FTMScan", url: "https://ftmscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
};
var fantomTestnet = {
  id: 4002,
  name: "Fantom Testnet",
  network: "fantom-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] },
    public: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
    default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  }
};
var filecoin = {
  id: 314,
  name: "Filecoin Mainnet",
  network: "filecoin-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] },
    public: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: { name: "Filfox", url: "https://filfox.info/en" },
    filscan: { name: "Filscan", url: "https://filscan.io" },
    filscout: { name: "Filscout", url: "https://filscout.io/en" },
    glif: { name: "Glif", url: "https://explorer.glif.io" }
  }
};
var filecoinHyperspace = {
  id: 3141,
  name: "Filecoin Hyperspace",
  network: "filecoin-hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
    public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
    filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
  }
};
var foundry = {
  id: 31337,
  name: "Foundry",
  network: "foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] },
    public: { http: ["http://127.0.0.1:8545"] }
  }
};
var iotex = {
  id: 4689,
  name: "IoTeX",
  network: "iotex",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    },
    public: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: { name: "IoTeXScan", url: "https://iotexscan.io" }
  }
};
var iotexTestnet = {
  id: 4690,
  name: "IoTeX Testnet",
  network: "iotex-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    },
    public: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
  }
};
var goerli = {
  id: 5,
  network: "goerli",
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://goerli.infura.io/v3"],
      webSocket: ["wss://goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    },
    public: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xA292E2E58d4ddEb29C33c63173d0E8B7a2A4c62e",
      blockCreated: 8610406
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
};
var gnosis = {
  id: 100,
  name: "Gnosis",
  network: "gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gnosischain.com"] },
    public: { http: ["https://rpc.gnosischain.com"] }
  },
  blockExplorers: {
    etherscan: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io/"
    },
    default: {
      name: "Gnosis Chain Explorer",
      url: "https://blockscout.com/xdai/mainnet/"
    }
  }
};
var gnosisChiado = {
  id: 10200,
  name: "Gnosis Chiado",
  network: "chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.chiadochain.net"] },
    public: { http: ["https://rpc.chiadochain.net"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net"
    }
  }
};
var hardhat = {
  id: 31337,
  name: "Hardhat",
  network: "hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] },
    public: { http: ["http://127.0.0.1:8545"] }
  }
};
var harmonyOne = {
  id: 16666e5,
  name: "Harmony One",
  network: "harmony",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    public: { http: ["https://rpc.ankr.com/harmony"] },
    default: { http: ["https://rpc.ankr.com/harmony"] }
  },
  blockExplorers: {
    default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
};
var klaytn = {
  id: 8217,
  name: "Klaytn",
  network: "klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://cypress.fautor.app/archive"] },
    public: { http: ["https://cypress.fautor.app/archive"] }
  },
  blockExplorers: {
    etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
    default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
  }
};
var localhost = {
  id: 1337,
  name: "Localhost",
  network: "localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] },
    public: { http: ["http://127.0.0.1:8545"] }
  }
};
var mainnet = {
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://mainnet.infura.io/v3"],
      webSocket: ["wss://mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://cloudflare-eth.com"]
    },
    public: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da",
      blockCreated: 16773775
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
};
var metis = {
  id: 1088,
  name: "Metis",
  network: "andromeda",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://andromeda.metis.io/?owner=1088"] },
    public: { http: ["https://andromeda.metis.io/?owner=1088"] }
  },
  blockExplorers: {
    default: {
      name: "Andromeda Explorer",
      url: "https://andromeda-explorer.metis.io"
    }
  }
};
var metisGoerli = {
  id: 599,
  name: "Metis Goerli",
  network: "metis-goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] },
    public: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link"
    }
  }
};
var moonbaseAlpha = {
  id: 1287,
  name: "Moonbase Alpha",
  network: "moonbase-alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    },
    public: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io"
    },
    etherscan: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: true
};
var moonbeam = {
  id: 1284,
  name: "Moonbeam",
  network: "moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    public: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    },
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io"
    },
    etherscan: {
      name: "Moonscan",
      url: "https://moonscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: false
};
var moonriver = {
  id: 1285,
  name: "Moonriver",
  network: "moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    public: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    },
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io"
    },
    etherscan: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: false
};
var okc = {
  id: 66,
  name: "OKC",
  network: "okc",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] },
    public: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: { name: "oklink", url: "https://www.oklink.com/okc" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
};
var optimism = {
  id: 10,
  name: "Optimism",
  network: "optimism",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://optimism-mainnet.infura.io/v3"],
      webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://mainnet.optimism.io"]
    },
    public: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://optimistic.etherscan.io"
    },
    default: {
      name: "Optimism Explorer",
      url: "https://explorer.optimism.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    }
  }
};
var optimismGoerli = {
  id: 420,
  name: "Optimism Goerli",
  network: "optimism-goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://optimism-goerli.infura.io/v3"],
      webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://goerli.optimism.io"]
    },
    public: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    }
  },
  testnet: true
};
var polygon = {
  id: 137,
  name: "Polygon",
  network: "matic",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mainnet.infura.io/v3"],
      webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://polygon-rpc.com"]
    },
    public: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
};
var polygonMumbai = {
  id: 80001,
  name: "Polygon Mumbai",
  network: "maticmum",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mumbai.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mumbai.infura.io/v3"],
      webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
    },
    default: {
      http: ["https://matic-mumbai.chainstacklabs.com"]
    },
    public: {
      http: ["https://matic-mumbai.chainstacklabs.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
};
var polygonZkEvmTestnet = {
  id: 1442,
  name: "Polygon zkEVM Testnet",
  network: "polygon-zkevm-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    },
    public: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.public.zkevm-test.net"
    }
  },
  testnet: true
};
var scrollTestnet = {
  id: 534353,
  name: "Scroll Testnet",
  network: "scroll-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://alpha-rpc.scroll.io/l2"],
      webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
    },
    public: {
      http: ["https://alpha-rpc.scroll.io/l2"],
      webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.scroll.io"
    }
  },
  testnet: true
};
var sepolia = {
  id: 11155111,
  network: "sepolia",
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
  rpcUrls: {
    infura: {
      http: ["https://sepolia.infura.io/v3"],
      webSocket: ["wss://sepolia.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.sepolia.org"]
    },
    public: {
      http: ["https://rpc.sepolia.org"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
};
var skaleBlockBrawlers = {
  id: 391845894,
  name: "SKALE | Block Brawlers",
  network: "skale-brawl",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleCalypso = {
  id: 1564830818,
  name: "SKALE | Calypso NFT Hub",
  network: "skale-calypso",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleCalypsoTestnet = {
  id: 344106930,
  name: "SKALE | Calypso NFT Hub Testnet",
  network: "skale-calypso-testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
      ]
    },
    public: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
      ]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
    }
  },
  contracts: {},
  testnet: true
};
var skaleChaosTestnet = {
  id: 1351057110,
  name: "SKALE | Chaos Testnet",
  network: "skale-chaos-testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
      ]
    },
    public: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
      ]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
    }
  },
  contracts: {},
  testnet: true
};
var skaleCryptoBlades = {
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  network: "skale-cryptoblades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleCryptoColosseum = {
  id: 2046399126,
  name: "SKALE | Crypto Colosseum",
  network: "skale-crypto-coloseeum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleEuropa = {
  id: 2046399126,
  name: "SKALE | Europa Liquidity Hub",
  network: "skale-europa",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleEuropaTestnet = {
  id: 476158412,
  name: "SKALE | Europa Liquidity Hub Testnet",
  network: "skale-europa-testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
    },
    public: {
      http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
    }
  },
  contracts: {},
  testnet: true
};
var skaleExorde = {
  id: 2139927552,
  name: "SKALE | Exorde",
  network: "skale-exorde",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleHumanProtocol = {
  id: 1273227453,
  name: "SKALE | Human Protocol",
  network: "skale-human-protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleNebula = {
  id: 1482601649,
  name: "SKALE | Nebula Gaming Hub",
  network: "skale-nebula",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleNebulaTestnet = {
  id: 503129905,
  name: "SKALE | Nebula Gaming Hub Testnet",
  network: "skale-nebula-testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
    },
    public: {
      http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
    }
  },
  contracts: {},
  testnet: true
};
var skaleRazor = {
  id: 278611351,
  name: "SKALE | Razor Network",
  network: "skale-razor",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleTitan = {
  id: 1350216234,
  name: "SKALE | Titan Community Hub",
  network: "skale-titan",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
    },
    public: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
};
var skaleTitanTestnet = {
  id: 1517929550,
  name: "SKALE | Titan Community Hub Testnet",
  network: "skale-titan-testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
      ]
    },
    public: {
      http: [
        "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
      ]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "SKALE Explorer",
      url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
    },
    default: {
      name: "SKALE Explorer",
      url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
    }
  },
  contracts: {},
  testnet: true
};
var shardeumSphinx = {
  id: 8082,
  name: "Shardeum Sphinx",
  network: "shmSphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    },
    public: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: true
};
var taraxa = {
  id: 841,
  name: "Taraxa Mainnet",
  network: "taraxa",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    },
    public: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
};
var taraxaTestnet = {
  id: 842,
  name: "Taraxa Testnet",
  network: "taraxa-testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    },
    public: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: true
};
var telos = {
  id: 40,
  name: "Telos",
  network: "telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.telos.net/evm"] },
    public: { http: ["https://mainnet.telos.net/evm"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
};
var telosTestnet = {
  id: 41,
  name: "Telos",
  network: "telosTestnet",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://testnet.telos.net/evm"] },
    public: { http: ["https://testnet.telos.net/evm"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: true
};
var wanchain = {
  id: 888,
  name: "Wanchain",
  network: "wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    },
    public: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "WanScan",
      url: "https://wanscan.org"
    },
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
};
var wanchainTestnet = {
  id: 999,
  name: "Wanchain Testnet",
  network: "wanchainTestnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    },
    public: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    },
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: true
};
var zhejiang = {
  id: 1337803,
  network: "zhejiang",
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    },
    public: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    beaconchain: {
      name: "Etherscan",
      url: "https://zhejiang.beaconcha.in"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://blockscout.com/eth/zhejiang-testnet"
    },
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: true
};
var zkSync = {
  id: 324,
  name: "zkSync",
  network: "zksync",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://zksync2-mainnet.zksync.io"],
      webSocket: ["wss://zksync2-mainnet.zksync.io/ws"]
    },
    public: {
      http: ["https://zksync2-mainnet.zksync.io"],
      webSocket: ["wss://zksync2-mainnet.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkExplorer",
      url: "https://explorer.zksync.io"
    }
  }
};
var zkSyncTestnet = {
  id: 280,
  name: "zkSync Testnet",
  network: "zksync-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zksync2-testnet.zksync.dev"],
      webSocket: ["wss://zksync2-testnet.zksync.dev/ws"]
    },
    public: {
      http: ["https://zksync2-testnet.zksync.dev"],
      webSocket: ["wss://zksync2-testnet.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkExplorer",
      url: "https://goerli.explorer.zksync.io"
    }
  },
  testnet: true
};

// node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/@wagmi/connectors/dist/chunk-5NCTPR6C.js
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var Connector = class extends import_eventemitter3.default {
  constructor({
    chains = [mainnet, goerli],
    options
  }) {
    super();
    __publicField(this, "chains");
    __publicField(this, "options");
    this.chains = chains;
    this.options = options;
  }
  getBlockExplorerUrls(chain) {
    const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
    if (blockExplorer)
      return [
        blockExplorer.url,
        ...Object.values(blockExplorers).map((x8) => x8.url)
      ];
  }
  isChainUnsupported(chainId) {
    return !this.chains.some((x8) => x8.id === chainId);
  }
};

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => import_bignumber7.BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => import_bignumber7.FixedNumber,
  Signer: () => import_abstract_signer3.Signer,
  VoidSigner: () => import_abstract_signer3.VoidSigner,
  Wallet: () => import_wallet2.Wallet,
  Wordlist: () => import_wordlists.Wordlist,
  constants: () => constants,
  errors: () => import_logger20.ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger18,
  providers: () => lib_exports,
  utils: () => utils_exports,
  version: () => version4,
  wordlists: () => import_wordlists.wordlists
});

// node_modules/@ethersproject/contracts/lib.esm/index.js
var import_abi = __toESM(require_lib13());
var import_abstract_provider = __toESM(require_lib14());
var import_abstract_signer = __toESM(require_lib15());
var import_address = __toESM(require_lib7());
var import_bignumber = __toESM(require_lib3());
var import_bytes = __toESM(require_lib2());
var import_properties = __toESM(require_lib4());
var import_transactions = __toESM(require_lib17());
var import_logger = __toESM(require_lib());

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version = "contracts/5.7.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger = new import_logger.Logger(version);
var allowedTransactionKeys = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return (0, import_address.getAddress)(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", import_logger.Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v7) => resolveAddresses(resolver, v7, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = (0, import_properties.shallowCopy)(args.pop());
    }
    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = (0, import_properties.resolveProperties)({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter(this, void 0, void 0, function* () {
          if ((0, import_address.getAddress)(check.signer) !== check.override) {
            logger.throwError("Contract with a Signer cannot override from", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield (0, import_properties.resolveProperties)({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: (0, import_properties.resolveProperties)(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro2 = resolved.overrides;
    if (ro2.nonce != null) {
      tx.nonce = import_bignumber.BigNumber.from(ro2.nonce).toNumber();
    }
    if (ro2.gasLimit != null) {
      tx.gasLimit = import_bignumber.BigNumber.from(ro2.gasLimit);
    }
    if (ro2.gasPrice != null) {
      tx.gasPrice = import_bignumber.BigNumber.from(ro2.gasPrice);
    }
    if (ro2.maxFeePerGas != null) {
      tx.maxFeePerGas = import_bignumber.BigNumber.from(ro2.maxFeePerGas);
    }
    if (ro2.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = import_bignumber.BigNumber.from(ro2.maxPriorityFeePerGas);
    }
    if (ro2.from != null) {
      tx.from = ro2.from;
    }
    if (ro2.type != null) {
      tx.type = ro2.type;
    }
    if (ro2.accessList != null) {
      tx.accessList = (0, import_transactions.accessListify)(ro2.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = (0, import_bytes.arrayify)(data2);
      for (let i10 = 0; i10 < bytes.length; i10++) {
        intrinsic += 4;
        if (bytes[i10]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = import_bignumber.BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro2.value) {
      const roValue = import_bignumber.BigNumber.from(ro2.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro2.customData) {
      tx.customData = (0, import_properties.shallowCopy)(ro2.customData);
    }
    if (ro2.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro2.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map((l9) => JSON.stringify(l9)).join(",")}`, import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = (0, import_properties.deepCopy)(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e11) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = (0, import_properties.shallowCopy)(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === import_logger.Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter) {
    (0, import_properties.defineReadOnly)(this, "tag", tag);
    (0, import_properties.defineReadOnly)(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i10) => i10.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag(filter), filter);
    (0, import_properties.defineReadOnly)(this, "address", address);
    (0, import_properties.defineReadOnly)(this, "interface", contractInterface);
    (0, import_properties.defineReadOnly)(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data2, topics) => {
      return this.interface.decodeEventLog(this.fragment, data2, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors2 = (0, import_abi.checkResultErrors)(event.args);
    if (errors2.length) {
      throw errors2[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    (0, import_properties.defineReadOnly)(this, "address", address);
    (0, import_properties.defineReadOnly)(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    (0, import_properties.defineReadOnly)(this, "interface", (0, import_properties.getStatic)(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      (0, import_properties.defineReadOnly)(this, "provider", null);
      (0, import_properties.defineReadOnly)(this, "signer", null);
    } else if (import_abstract_signer.Signer.isSigner(signerOrProvider)) {
      (0, import_properties.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
      (0, import_properties.defineReadOnly)(this, "signer", signerOrProvider);
    } else if (import_abstract_provider.Provider.isProvider(signerOrProvider)) {
      (0, import_properties.defineReadOnly)(this, "provider", signerOrProvider);
      (0, import_properties.defineReadOnly)(this, "signer", null);
    } else {
      logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    (0, import_properties.defineReadOnly)(this, "callStatic", {});
    (0, import_properties.defineReadOnly)(this, "estimateGas", {});
    (0, import_properties.defineReadOnly)(this, "functions", {});
    (0, import_properties.defineReadOnly)(this, "populateTransaction", {});
    (0, import_properties.defineReadOnly)(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        (0, import_properties.defineReadOnly)(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          (0, import_properties.defineReadOnly)(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    (0, import_properties.defineReadOnly)(this, "_runningEvents", {});
    (0, import_properties.defineReadOnly)(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    (0, import_properties.defineReadOnly)(this, "address", addressOrName);
    if (this.provider) {
      (0, import_properties.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        (0, import_properties.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, import_address.getAddress)(addressOrName)));
      } catch (error) {
        logger.throwError("provider is required to use ENS name as contract address", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e11) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature) => {
      const fragment = this.interface.functions[signature];
      if (uniqueSignatures[signature]) {
        logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
        return;
      }
      uniqueSignatures[signature] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature);
      }
      if (this[signature] == null) {
        (0, import_properties.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
      }
      if (this.functions[signature] == null) {
        (0, import_properties.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature] == null) {
        (0, import_properties.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature] == null) {
        (0, import_properties.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature] == null) {
        (0, import_properties.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature = signatures[0];
      try {
        if (this[name2] == null) {
          (0, import_properties.defineReadOnly)(this, name2, this[signature]);
        }
      } catch (e11) {
      }
      if (this.functions[name2] == null) {
        (0, import_properties.defineReadOnly)(this.functions, name2, this.functions[signature]);
      }
      if (this.callStatic[name2] == null) {
        (0, import_properties.defineReadOnly)(this.callStatic, name2, this.callStatic[signature]);
      }
      if (this.populateTransaction[name2] == null) {
        (0, import_properties.defineReadOnly)(this.populateTransaction, name2, this.populateTransaction[signature]);
      }
      if (this.estimateGas[name2] == null) {
        (0, import_properties.defineReadOnly)(this.estimateGas, name2, this.estimateGas[signature]);
      }
    });
  }
  static getContractAddress(transaction) {
    return (0, import_address.getContractAddress)(transaction);
  }
  static getInterface(contractInterface) {
    if (import_abi.Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new import_abi.Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger.throwError("contract not deployed", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger.throwError("sending a transactions require a signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = (0, import_properties.shallowCopy)(overrides || {});
    ["from", "to"].forEach(function(key) {
      if (tx[key] == null) {
        return;
      }
      logger.throwError("cannot override " + key, import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new import_abstract_signer.VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      (0, import_properties.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return import_abi.Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = (0, import_properties.deepCopy)(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger.throwError("events require a provider or a signer with a provider", import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = (0, import_properties.shallowCopy)(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && (0, import_bytes.isHexString)(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key) => {
        return accum + this._runningEvents[key].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if ((0, import_bytes.isBytes)(bytecode)) {
      bytecodeHex = (0, import_bytes.hexlify)(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!(0, import_bytes.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {
      logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !import_abstract_signer.Signer.isSigner(signer)) {
      logger.throwArgumentError("invalid signer", "signer", signer);
    }
    (0, import_properties.defineReadOnly)(this, "bytecode", bytecodeHex);
    (0, import_properties.defineReadOnly)(this, "interface", (0, import_properties.getStatic)(new.target, "getInterface")(contractInterface));
    (0, import_properties.defineReadOnly)(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = (0, import_properties.shallowCopy)(args.pop());
      for (const key in tx) {
        if (!allowedTransactionKeys[key]) {
          throw new Error("unknown transaction override " + key);
        }
      }
    }
    ["data", "from", "to"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      logger.throwError("cannot override " + key, import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
    });
    if (tx.value) {
      const value = import_bignumber.BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger.throwError("non-payable constructor cannot override value", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = (0, import_bytes.hexlify)((0, import_bytes.concat)([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = (0, import_properties.getStatic)(this.constructor, "getContractAddress")(tx);
      const contract = (0, import_properties.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      (0, import_properties.defineReadOnly)(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger.throwError("missing compiler output", import_logger.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return (0, import_address.getContractAddress)(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// node_modules/ethers/lib.esm/ethers.js
var import_bignumber7 = __toESM(require_lib3());
var import_abstract_signer3 = __toESM(require_lib15());
var import_wallet2 = __toESM(require_lib25());
var constants = __toESM(require_lib8());

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => import_abstract_provider4.Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
var import_abstract_provider4 = __toESM(require_lib14());

// node_modules/@ethersproject/networks/lib.esm/index.js
var import_logger2 = __toESM(require_lib());

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version2 = "networks/5.7.1";

// node_modules/@ethersproject/networks/lib.esm/index.js
var logger2 = new import_logger2.Logger(version2);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger2.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger2.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_abstract_provider2 = __toESM(require_lib14());
var import_base64 = __toESM(require_lib10());
var import_basex = __toESM(require_lib18());
var import_bignumber3 = __toESM(require_lib3());
var import_bytes3 = __toESM(require_lib2());
var import_constants2 = __toESM(require_lib8());
var import_hash = __toESM(require_lib12());
var import_properties3 = __toESM(require_lib4());
var import_sha2 = __toESM(require_lib19());
var import_strings = __toESM(require_lib9());
var import_web = __toESM(require_lib26());
var import_bech32 = __toESM(require_bech32());
var import_logger4 = __toESM(require_lib());

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version3 = "providers/5.7.2";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
var import_address2 = __toESM(require_lib7());
var import_bignumber2 = __toESM(require_lib3());
var import_bytes2 = __toESM(require_lib2());
var import_constants = __toESM(require_lib8());
var import_properties2 = __toESM(require_lib4());
var import_transactions2 = __toESM(require_lib17());
var import_logger3 = __toESM(require_lib());
var logger3 = new import_logger3.Logger(version3);
var Formatter = class {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v7) => {
      return this.data(v7, true);
    };
    formats.transaction = {
      hash,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash,
      address,
      topics: Formatter.arrayOf(hash),
      data: data2,
      logIndex: number,
      blockHash: hash
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash,
      transactionHash: hash,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash),
      parentHash: hash,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = (0, import_properties2.shallowCopy)(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash),
      transactionHash: hash,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return (0, import_transactions2.accessListify)(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return import_bignumber2.BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return import_bignumber2.BigNumber.from(number).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return import_bignumber2.BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if ((0, import_bytes2.isHexString)(value)) {
        return value.toLowerCase();
      }
    }
    return logger3.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return (0, import_address2.getAddress)(value);
  }
  callAddress(value) {
    if (!(0, import_bytes2.isHexString)(value, 32)) {
      return null;
    }
    const address = (0, import_address2.getAddress)((0, import_bytes2.hexDataSlice)(value, 12));
    return address === import_constants.AddressZero ? null : address;
  }
  contractAddress(value) {
    return (0, import_address2.getContractAddress)(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || (0, import_bytes2.isHexString)(blockTag)) {
      return (0, import_bytes2.hexValue)(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if ((0, import_bytes2.hexDataLength)(result) !== 32) {
      return logger3.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v7 = import_bignumber2.BigNumber.from(value);
    try {
      return v7.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!(0, import_bytes2.isHexString)(value)) {
      throw new Error("invalid uint256");
    }
    return (0, import_bytes2.hexZeroPad)(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : import_bignumber2.BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && import_bignumber2.BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if ((0, import_bytes2.isHexString)(chainId)) {
        chainId = import_bignumber2.BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if ((0, import_bytes2.isHexString)(chainId)) {
        chainId = import_bignumber2.BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return (0, import_transactions2.parse)(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = import_bignumber2.BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger3.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v7) => this.topics(v7));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key in format) {
      try {
        const value = format[key](object[key]);
        if (value !== void 0) {
          result[key] = value;
        }
      } catch (error) {
        error.checkKey = key;
        error.checkValue = object[key];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter2 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger4 = new import_logger4.Logger(version3);
var MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if ((0, import_bytes3.hexDataLength)(topic) !== 32) {
    logger4.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if ((0, import_bytes3.hexDataLength)(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (import_abstract_provider2.ForkEvent.isForkEvent(eventName)) {
    logger4.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    (0, import_properties3.defineReadOnly)(this, "tag", tag);
    (0, import_properties3.defineReadOnly)(this, "listener", listener);
    (0, import_properties3.defineReadOnly)(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return (0, import_bytes3.hexZeroPad)(import_bignumber3.BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return import_basex.Base58.encode((0, import_bytes3.concat)([data2, (0, import_bytes3.hexDataSlice)((0, import_sha2.sha256)((0, import_sha2.sha256)(data2)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return (0, import_strings.toUtf8String)(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(result, start, start + 32)).toNumber();
  const length2 = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(result, offset, offset + 32)).toNumber();
  return (0, import_bytes3.hexDataSlice)(result, offset + 32, offset + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger4.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = (0, import_bytes3.arrayify)(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i10 = 0; i10 < datas.length; i10++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i10 = 0; i10 < datas.length; i10++) {
    const data2 = (0, import_bytes3.arrayify)(datas[i10]);
    result[i10] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return (0, import_bytes3.hexConcat)(result);
}
var Resolver = class {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name2, resolvedAddress) {
    (0, import_properties3.defineReadOnly)(this, "provider", provider);
    (0, import_properties3.defineReadOnly)(this, "name", name2);
    (0, import_properties3.defineReadOnly)(this, "address", provider.formatter.address(address));
    (0, import_properties3.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return import_bignumber3.BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter2(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: (0, import_bytes3.hexConcat)([selector, (0, import_hash.namehash)(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = (0, import_bytes3.hexConcat)(["0x9061b923", encodeBytes([(0, import_hash.dnsEncode)(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if ((0, import_bytes3.arrayify)(result).length % 32 === 4) {
          logger4.throwError("resolver threw error", import_logger4.Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter2(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger4.throwError(`unsupported coin type: ${coinType}`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = (0, import_bytes3.arrayify)(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode((0, import_bytes3.concat)([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode((0, import_bytes3.concat)([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes[1];
      let version6 = bytes[0];
      if (version6 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version6 = -1;
        }
      } else {
        version6 = -1;
      }
      if (version6 >= 0 && bytes.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words = import_bech32.default.toWords(bytes.slice(2));
        words.unshift(version6);
        return import_bech32.default.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === import_constants2.HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger4.throwError(`invalid or unsupported coin data`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter2(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i10 = 0; i10 < matchers.length; i10++) {
          const match = avatar.match(matchers[i10]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = (0, import_bytes3.hexZeroPad)(import_bignumber3.BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: (0, import_bytes3.hexConcat)(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = import_bignumber3.BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: (0, import_bytes3.hexConcat)(["0x00fdd58e", (0, import_bytes3.hexZeroPad)(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: (0, import_bytes3.hexConcat)([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield (0, import_web.fetchJson)(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter2(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + import_basex.Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + import_basex.Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash = (0, import_base64.encode)("0x" + skynet[1]).replace(/[=+\/]/g, (a9) => urlSafe[a9]);
          return "sia://" + hash;
        }
      }
      return logger4.throwError(`invalid or unsupported content hash data`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key) {
    return __awaiter2(this, void 0, void 0, function* () {
      let keyBytes = (0, import_strings.toUtf8Bytes)(key);
      keyBytes = (0, import_bytes3.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = (0, import_bytes3.concat)([keyBytes, (0, import_bytes3.hexZeroPad)("0x", 32 - key.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", (0, import_bytes3.hexlify)(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return (0, import_strings.toUtf8String)(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends import_abstract_provider2.Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    (0, import_properties3.defineReadOnly)(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = (0, import_properties3.getStatic)(new.target, "getNetwork")(network);
      if (knownNetwork) {
        (0, import_properties3.defineReadOnly)(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger4.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger4.throwError("no network detected", import_logger4.Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            (0, import_properties3.defineReadOnly)(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return (0, import_web.poll)(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === import_logger4.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data2 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i10 = 0; i10 < urls.length; i10++) {
        const url = urls[i10];
        const href = url.replace("{sender}", sender).replace("{data}", data2);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
        const result = yield (0, import_web.fetchJson)({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger4.throwError(`response not found during CCIP fetch: ${errorMessage}`, import_logger4.Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger4.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m11) => JSON.stringify(m11)).join(", ")}`, import_logger4.Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = (0, import_properties3.resolveProperties)({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = import_bignumber3.BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter2(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger4.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger4.makeError("network block skew detected", import_logger4.Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i10 = this._emitted.block + 1; i10 <= blockNumber; i10++) {
          this.emit("block", i10);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key) => {
          if (key === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash = event.hash;
            let runner = this.getTransactionReceipt(hash).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash] = receipt.blockNumber;
              this.emit(hash, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter = event.filter;
              filter.fromBlock = event._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter.fromBlock) {
                filter.fromBlock = minFromBlock;
              }
              if (filter.fromBlock < 0) {
                filter.fromBlock = 0;
              }
              const runner = this.getLogs(filter).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      return logger4.throwError("provider does not support network detection", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger4.makeError("underlying network changed", import_logger4.Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter2(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter2(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter2(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger4.makeError("transaction was replaced", import_logger4.Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger4.makeError("timeout exceeded", import_logger4.Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return import_bignumber3.BigNumber.from(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return import_bignumber3.BigNumber.from(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return import_bignumber3.BigNumber.from(result).toNumber();
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return (0, import_bytes3.hexlify)(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p10) => (0, import_bytes3.hexValue)(p10))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return (0, import_bytes3.hexlify)(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash, startBlock) {
    if (hash != null && (0, import_bytes3.hexDataLength)(hash) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash != null && tx.hash !== hash) {
      logger4.throwError("Transaction hash mismatch from Provider.sendTransaction.", import_logger4.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });
    }
    result.wait = (confirms, timeout) => __awaiter2(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger4.throwError("transaction failed", import_logger4.Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t8) => (0, import_bytes3.hexlify)(t8));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? this._getAddress(v7) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? import_bignumber3.BigNumber.from(v7) : null);
      });
      ["type"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v7) => v7 != null ? v7 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? (0, import_bytes3.hexlify)(v7) : null);
      });
      return this.formatter.transactionRequest(yield (0, import_properties3.resolveProperties)(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter2(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key) => {
        if (filter[key] == null) {
          return;
        }
        result[key] = filter[key];
      });
      ["fromBlock", "toBlock"].forEach((key) => {
        if (filter[key] == null) {
          return;
        }
        result[key] = this._getBlockTag(filter[key]);
      });
      return this.formatter.filter(yield (0, import_properties3.resolveProperties)(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger4.throwError("CCIP read exceeded maximum redirections", import_logger4.Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, import_bytes3.hexDataLength)(result) % 32 === 4) {
        try {
          const data2 = (0, import_bytes3.hexDataSlice)(result, 4);
          const sender = (0, import_bytes3.hexDataSlice)(data2, 0, 32);
          if (!import_bignumber3.BigNumber.from(sender).eq(txSender)) {
            logger4.throwError("CCIP Read sender did not match", import_logger4.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data2, 32, 64)).toNumber();
          const urlsLength = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data2, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = (0, import_bytes3.hexDataSlice)(data2, urlsOffset + 32);
          for (let u9 = 0; u9 < urlsLength; u9++) {
            const url = _parseString(urlsData, u9 * 32);
            if (url == null) {
              logger4.throwError("CCIP Read contained corrupt URL string", import_logger4.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data2, 64);
          if (!import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data2, 100, 128)).isZero()) {
            logger4.throwError("CCIP Read callback selector included junk", import_logger4.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = (0, import_bytes3.hexDataSlice)(data2, 96, 100);
          const extraData = _parseBytes(data2, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger4.throwError("CCIP Read disabled or provided no URLs", import_logger4.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: (0, import_bytes3.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === import_logger4.Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return (0, import_bytes3.hexlify)(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield (0, import_properties3.resolveProperties)({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return import_bignumber3.BigNumber.from(result);
      } catch (error) {
        return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter2(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger4.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger4.throwError("ENS name not configured", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if ((0, import_bytes3.isHexString)(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if ((0, import_bytes3.isHexString)(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger4.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return (0, import_web.poll)(() => __awaiter2(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i10 = 0; i10 < block.transactions.length; i10++) {
            const tx = block.transactions[i10];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return (0, import_web.poll)(() => __awaiter2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return (0, import_web.poll)(() => __awaiter2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0, import_properties3.resolveProperties)({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger4.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter2(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger4.throwError("network does not support ENS", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + (0, import_hash.namehash)(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter2(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if ((0, import_bytes3.isHexString)(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger4.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter2(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + (0, import_hash.namehash)(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter2(this, void 0, void 0, function* () {
      let resolver = null;
      if ((0, import_bytes3.isHexString)(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== import_logger4.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + (0, import_hash.namehash)(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== import_logger4.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger4.throwError(method + " not implemented", import_logger4.Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e11) => e11.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e11) => e11.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var import_properties7 = __toESM(require_lib4());

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var import_bignumber5 = __toESM(require_lib3());
var import_properties5 = __toESM(require_lib4());

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var import_abstract_signer2 = __toESM(require_lib15());
var import_bignumber4 = __toESM(require_lib3());
var import_bytes4 = __toESM(require_lib2());
var import_hash2 = __toESM(require_lib12());
var import_properties4 = __toESM(require_lib4());
var import_strings2 = __toESM(require_lib9());
var import_transactions3 = __toESM(require_lib17());
var import_web2 = __toESM(require_lib26());
var import_logger5 = __toESM(require_lib());
var __awaiter3 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new import_logger5.Logger(version3);
var errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = (0, import_bytes4.isHexString)(value.data) ? value.data : null;
    if (!requireData || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunk(value[key], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger5.throwError("missing revert data in call exception; Transaction reverted without a reason string", import_logger5.Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger5.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger5.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === import_logger5.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger5.throwError("insufficient funds for intrinsic transaction cost", import_logger5.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger5.throwError("nonce has already been used", import_logger5.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger5.throwError("replacement fee too low", import_logger5.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger5.throwError("legacy pre-eip-155 transactions not supported", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger5.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger5.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard = {};
var JsonRpcSigner = class extends import_abstract_signer2.Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    (0, import_properties4.defineReadOnly)(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      (0, import_properties4.defineReadOnly)(this, "_address", this.provider.formatter.address(addressOrIndex));
      (0, import_properties4.defineReadOnly)(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      (0, import_properties4.defineReadOnly)(this, "_index", addressOrIndex);
      (0, import_properties4.defineReadOnly)(this, "_address", null);
    } else {
      logger5.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger5.throwError("cannot alter JSON-RPC Signer connection", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger5.throwError("unknown account #" + this._index, import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = (0, import_properties4.shallowCopy)(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = (0, import_properties4.shallowCopy)(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to2) => __awaiter3(this, void 0, void 0, function* () {
        if (to2 == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to2);
        if (address == null) {
          logger5.throwArgumentError("provided ENS name resolves to null", "tx.to", to2);
        }
        return address;
      }));
    }
    return (0, import_properties4.resolveProperties)({
      tx: (0, import_properties4.resolveProperties)(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger5.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash) => {
        return hash;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger5.throwError("user rejected transaction", import_logger5.Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger5.throwError("signing transactions is unsupported", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield (0, import_web2.poll)(() => __awaiter3(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter3(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? (0, import_strings2.toUtf8Bytes)(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [(0, import_bytes4.hexlify)(data2), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter3(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? (0, import_strings2.toUtf8Bytes)(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), (0, import_bytes4.hexlify)(data2)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain2, types, value) {
    return __awaiter3(this, void 0, void 0, function* () {
      const populated = yield import_hash2._TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(import_hash2._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter3(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash) => {
      return {
        hash,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = (0, import_properties4.getStatic)(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      (0, import_properties4.defineReadOnly)(this, "connection", Object.freeze({
        url
      }));
    } else {
      (0, import_properties4.defineReadOnly)(this, "connection", Object.freeze((0, import_properties4.shallowCopy)(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter3(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork4 = (0, import_properties4.getStatic)(this.constructor, "getNetwork");
        try {
          return getNetwork4(import_bignumber4.BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger5.throwError("could not detect network", import_logger5.Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger5.throwError("could not detect network", import_logger5.Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a9) => this.formatter.address(a9));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: (0, import_properties4.deepCopy)(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = (0, import_web2.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), (0, import_bytes4.hexZeroPad)(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = (0, import_properties4.getStatic)(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = (0, import_properties4.getStatic)(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && import_bignumber4.BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = (0, import_properties4.shallowCopy)(params);
              params.transaction = (0, import_properties4.shallowCopy)(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger5.throwError(method + " not implemented", import_logger5.Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll5() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes2) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes2.forEach(function(hash) {
            self2._emitted["t:" + hash.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll5();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll5();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = (0, import_properties4.shallowCopy)(allowedTransactionKeys2);
    if (allowExtra) {
      for (const key in allowExtra) {
        if (allowExtra[key]) {
          allowed[key] = true;
        }
      }
    }
    (0, import_properties4.checkProperties)(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      const value = (0, import_bytes4.hexValue)(import_bignumber4.BigNumber.from(transaction[key]));
      if (key === "gasLimit") {
        key = "gas";
      }
      result[key] = value;
    });
    ["from", "to", "data"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      result[key] = (0, import_bytes4.hexlify)(transaction[key]);
    });
    if (transaction.accessList) {
      result["accessList"] = (0, import_transactions3.accessListify)(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ws.js
var import_logger6 = __toESM(require_lib());
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger19 = new import_logger6.Logger(version3);
  WS = function() {
    logger19.throwError("WebSockets not supported in this environment", import_logger6.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var import_logger7 = __toESM(require_lib());
var __awaiter4 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger6 = new import_logger7.Logger(version3);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger6.throwError("WebSocketProvider does not support 'any' network yet", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      (0, import_properties5.defineReadOnly)(this, "_websocket", new WS(this.connection.url));
    } else {
      (0, import_properties5.defineReadOnly)(this, "_websocket", url);
    }
    (0, import_properties5.defineReadOnly)(this, "_requests", {});
    (0, import_properties5.defineReadOnly)(this, "_subs", {});
    (0, import_properties5.defineReadOnly)(this, "_subIds", {});
    (0, import_properties5.defineReadOnly)(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data2 = messageEvent.data;
      const result = JSON.parse(data2);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            (0, import_properties5.defineReadOnly)(error, "code", result.error.code || null);
            (0, import_properties5.defineReadOnly)(error, "response", data2);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger6.throwError("cannot reset events block on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger6.throwError("cannot set polling interval on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter4(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger6.throwError("cannot set polling on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter4(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = import_bignumber5.BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash = event2.hash;
          this.getTransactionReceipt(hash).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e11) => e11.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e11) => e11.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var import_logger9 = __toESM(require_lib());

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var import_properties6 = __toESM(require_lib4());
var import_logger8 = __toESM(require_lib());
var __awaiter5 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger7 = new import_logger8.Logger(version3);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter5(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger7.throwError("no network detected", import_logger8.Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          (0, import_properties6.defineReadOnly)(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger7.checkAbstract(new.target, UrlJsonRpcProvider);
    network = (0, import_properties6.getStatic)(new.target, "getNetwork")(network);
    apiKey = (0, import_properties6.getStatic)(new.target, "getApiKey")(apiKey);
    const connection = (0, import_properties6.getStatic)(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      (0, import_properties6.defineReadOnly)(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key) => {
        (0, import_properties6.defineReadOnly)(this, key, apiKey[key]);
      });
    }
  }
  _startPending() {
    logger7.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger7.throwError("API provider does not support signing", import_logger8.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger7.throwError("not implemented; sub-classes must override getUrl", import_logger8.Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger8 = new import_logger9.Logger(version3);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    (0, import_properties7.defineReadOnly)(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger8.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger8.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
var import_logger10 = __toESM(require_lib());
var logger9 = new import_logger10.Logger(version3);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name2) {
  switch (name2) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger9.throwArgumentError("unsupported network", "name", name2);
}
var AnkrProvider = class extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
};

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var import_logger11 = __toESM(require_lib());
var __awaiter6 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger10 = new import_logger11.Logger(version3);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger10.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger10.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter6(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
var import_bytes5 = __toESM(require_lib2());
var import_properties8 = __toESM(require_lib4());
var import_transactions4 = __toESM(require_lib17());
var import_web3 = __toESM(require_lib26());
var import_logger12 = __toESM(require_lib());
var __awaiter7 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger11 = new import_logger12.Logger(version3);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key in transaction) {
    if (transaction[key] == null) {
      continue;
    }
    let value = transaction[key];
    if (key === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
      value = (0, import_bytes5.hexValue)((0, import_bytes5.hexlify)(value));
    } else if (key === "accessList") {
      value = "[" + (0, import_transactions4.accessListify)(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = (0, import_bytes5.hexlify)(value);
    }
    result[key] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === import_logger12.Logger.errors.SERVER_ERROR) {
    const e11 = error.error;
    if (e11 && (e11.message.match(/reverted/i) || e11.message.match(/VM execution error/i))) {
      let data2 = e11.data;
      if (data2) {
        data2 = "0x" + data2.replace(/^.*0x/i, "");
      }
      if ((0, import_bytes5.isHexString)(data2)) {
        return data2;
      }
      logger11.throwError("missing revert data in call exception", import_logger12.Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === import_logger12.Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger11.throwError("insufficient funds for intrinsic transaction cost", import_logger12.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger11.throwError("nonce has already been used", import_logger12.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger11.throwError("replacement fee too low", import_logger12.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger11.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger12.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    (0, import_properties8.defineReadOnly)(this, "baseUrl", this.getBaseUrl());
    (0, import_properties8.defineReadOnly)(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    return logger11.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter7(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key) => {
          return `${key}=${payload[key]}`;
        }).join("&");
      }
      const result = yield (0, import_web3.fetchJson)(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: (0, import_properties8.deepCopy)(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter7(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger11.throwError("unsupported topic count", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger11.throwError("unsupported topic format", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i10 = 0; i10 < logs.length; i10++) {
            const log = logs[i10];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter7(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key) {
          if (tx[key] == "") {
            delete tx[key];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var import_abstract_provider3 = __toESM(require_lib14());
var import_bignumber6 = __toESM(require_lib3());
var import_bytes6 = __toESM(require_lib2());
var import_properties9 = __toESM(require_lib4());
var import_random = __toESM(require_lib23());
var import_web4 = __toESM(require_lib26());
var import_logger13 = __toESM(require_lib());
var __awaiter8 = function(thisArg, _arguments, P10, generator) {
  function adopt(value) {
    return value instanceof P10 ? value : new P10(function(resolve) {
      resolve(value);
    });
  }
  return new (P10 || (P10 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger12 = new import_logger13.Logger(version3);
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i10 = 0; i10 < networks2.length; i10++) {
    const network = networks2[i10];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger12.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a9 = values[middle - 1], b10 = values[middle];
  if (maxDelta != null && Math.abs(a9 - b10) > maxDelta) {
    return null;
  }
  return (a9 + b10) / 2;
}
function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (import_bignumber6.BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i10) => serialize(i10)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key) => {
      let v7 = value[key];
      if (typeof v7 === "function") {
        v7 = "[function]";
      } else {
        v7 = serialize(v7);
      }
      return JSON.stringify(key) + ":" + v7;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  import_logger13.Logger.errors.CALL_EXCEPTION,
  import_logger13.Logger.errors.INSUFFICIENT_FUNDS,
  import_logger13.Logger.errors.NONCE_EXPIRED,
  import_logger13.Logger.errors.REPLACEMENT_UNDERPRICED,
  import_logger13.Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c8) => {
      const value = normalize(c8.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c8.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i10 = 0; i10 < keys.length; i10++) {
      const check = tally[keys[i10]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c8) => c8.result);
        let blockNumber = median(configs.map((c8) => c8.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c8) => c8.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c8) => c8.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = (0, import_properties9.shallowCopy)(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = (0, import_properties9.shallowCopy)(block);
          block.transactions = block.transactions.map((tx) => {
            tx = (0, import_properties9.shallowCopy)(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config, blockNumber) {
  return __awaiter8(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return (0, import_web4.poll)(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter8(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && (0, import_bytes6.isHexString)(filter.fromBlock) || filter.toBlock && (0, import_bytes6.isHexString)(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger12.throwError("unknown method error", import_logger13.Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger12.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (import_abstract_provider3.Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config = (0, import_properties9.shallowCopy)(configOrProvider);
      if (config.priority == null) {
        config.priority = 1;
      }
      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config.weight == null) {
        config.weight = 1;
      }
      const weight = config.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger12.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c8) => accum + c8.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger12.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c8) => c8.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    (0, import_properties9.defineReadOnly)(this, "providerConfigs", Object.freeze(providerConfigs));
    (0, import_properties9.defineReadOnly)(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter8(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c8) => c8.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results2 = yield Promise.all(this.providerConfigs.map((c8) => {
          return c8.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i11 = 0; i11 < results2.length; i11++) {
          const result = results2[i11];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results2[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = (0, import_random.shuffled)(this.providerConfigs.map(import_properties9.shallowCopy));
      configs.sort((a9, b10) => a9.priority - b10.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i10 = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c8) => c8.runner && t0 - c8.start < c8.stallTimeout).reduce((accum, c8) => accum + c8.weight, 0);
        while (inflightWeight < this.quorum && i10 < configs.length) {
          const config = configs[i10++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall2(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
            config.done = true;
            config.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: (0, import_properties9.deepCopy)(params) },
                provider: this
              });
            }
          }, (error) => {
            config.done = true;
            config.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: (0, import_properties9.deepCopy)(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config, null),
              request: { method, params: (0, import_properties9.deepCopy)(params) },
              provider: this
            });
          }
          inflightWeight += config.weight;
        }
        const waiting = [];
        configs.forEach((c8) => {
          if (c8.done || !c8.runner) {
            return;
          }
          waiting.push(c8.runner);
          if (c8.staller) {
            waiting.push(c8.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results2 = configs.filter((c8) => c8.done && c8.error == null);
        if (results2.length >= this.quorum) {
          const result = processFunc(results2);
          if (result !== void 0) {
            configs.forEach((c8) => {
              if (c8.staller) {
                c8.staller.cancel();
              }
              c8.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall2(100).getPromise();
          }
          first = false;
        }
        const errors2 = configs.reduce((accum, c8) => {
          if (!c8.done || c8.error == null) {
            return accum;
          }
          const code2 = c8.error.code;
          if (ForwardErrors.indexOf(code2) >= 0) {
            if (!accum[code2]) {
              accum[code2] = { error: c8.error, weight: 0 };
            }
            accum[code2].weight += c8.weight;
          }
          return accum;
        }, {});
        Object.keys(errors2).forEach((errorCode) => {
          const tally = errors2[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c8) => {
            if (c8.staller) {
              c8.staller.cancel();
            }
            c8.cancelled = true;
          });
          const e11 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e11[name2] == null) {
              return;
            }
            props[name2] = e11[name2];
          });
          logger12.throwError(e11.reason || e11.message, errorCode, props);
        });
        if (configs.filter((c8) => !c8.done).length === 0) {
          break;
        }
      }
      configs.forEach((c8) => {
        if (c8.staller) {
          c8.staller.cancel();
        }
        c8.cancelled = true;
      });
      return logger12.throwError("failed to meet quorum", import_logger13.Logger.errors.SERVER_ERROR, {
        method,
        params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map((c8) => exposeDebugConfig(c8)),
        provider: this
      });
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var import_properties10 = __toESM(require_lib4());
var import_logger14 = __toESM(require_lib());
var logger13 = new import_logger14.Logger(version3);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger13.throwError("INFURA WebSocket project secrets unsupported", import_logger14.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    (0, import_properties10.defineReadOnly)(this, "apiKey", provider.projectId);
    (0, import_properties10.defineReadOnly)(this, "projectId", provider.projectId);
    (0, import_properties10.defineReadOnly)(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger13.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger13.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger13.throwError("unsupported network", import_logger14.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var import_properties11 = __toESM(require_lib4());
var import_web5 = __toESM(require_lib26());
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: (0, import_properties11.deepCopy)(request2),
          provider: this
        });
        return (0, import_web5.fetchJson)(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var import_logger15 = __toESM(require_lib());
var logger14 = new import_logger15.Logger(version3);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger14.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger14.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger14.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var import_logger16 = __toESM(require_lib());
var logger15 = new import_logger16.Logger(version3);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
var PocketProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger15.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger15.throwError("unsupported network", import_logger16.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
var import_properties12 = __toESM(require_lib4());
var import_logger17 = __toESM(require_lib());
var logger16 = new import_logger17.Logger(version3);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: (0, import_properties12.deepCopy)(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: (0, import_properties12.deepCopy)(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger16.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger16.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    (0, import_properties12.defineReadOnly)(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    (0, import_properties12.defineReadOnly)(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@ethersproject/providers/lib.esm/index.js
var import_logger18 = __toESM(require_lib());
var logger17 = new import_logger18.Logger(version3);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger17.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n8 = getNetwork(network);
  if (!n8 || !n8._defaultProvider) {
    logger17.throwError("unsupported getDefaultProvider network", import_logger18.Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n8._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/ethers/lib.esm/ethers.js
var import_wordlists = __toESM(require_lib21());

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => import_abi2.AbiCoder,
  ConstructorFragment: () => import_abi2.ConstructorFragment,
  ErrorFragment: () => import_abi2.ErrorFragment,
  EventFragment: () => import_abi2.EventFragment,
  FormatTypes: () => import_abi2.FormatTypes,
  Fragment: () => import_abi2.Fragment,
  FunctionFragment: () => import_abi2.FunctionFragment,
  HDNode: () => import_hdnode.HDNode,
  Indexed: () => import_abi2.Indexed,
  Interface: () => import_abi2.Interface,
  LogDescription: () => import_abi2.LogDescription,
  Logger: () => import_logger19.Logger,
  ParamType: () => import_abi2.ParamType,
  RLP: () => RLP,
  SigningKey: () => import_signing_key.SigningKey,
  SupportedAlgorithm: () => import_sha23.SupportedAlgorithm,
  TransactionDescription: () => import_abi2.TransactionDescription,
  TransactionTypes: () => import_transactions5.TransactionTypes,
  UnicodeNormalizationForm: () => import_strings4.UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => import_strings3.Utf8ErrorFuncs,
  Utf8ErrorReason: () => import_strings4.Utf8ErrorReason,
  _TypedDataEncoder: () => import_hash3._TypedDataEncoder,
  _fetchData: () => import_web6._fetchData,
  _toEscapedUtf8String: () => import_strings3._toEscapedUtf8String,
  accessListify: () => import_transactions5.accessListify,
  arrayify: () => import_bytes7.arrayify,
  base58: () => import_basex2.Base58,
  base64: () => base64,
  checkProperties: () => import_properties13.checkProperties,
  checkResultErrors: () => import_abi2.checkResultErrors,
  commify: () => import_units.commify,
  computeAddress: () => import_transactions5.computeAddress,
  computeHmac: () => import_sha22.computeHmac,
  computePublicKey: () => import_signing_key.computePublicKey,
  concat: () => import_bytes7.concat,
  deepCopy: () => import_properties13.deepCopy,
  defaultAbiCoder: () => import_abi2.defaultAbiCoder,
  defaultPath: () => import_hdnode.defaultPath,
  defineReadOnly: () => import_properties13.defineReadOnly,
  dnsEncode: () => import_hash3.dnsEncode,
  entropyToMnemonic: () => import_hdnode.entropyToMnemonic,
  fetchJson: () => import_web6.fetchJson,
  formatBytes32String: () => import_strings3.formatBytes32String,
  formatEther: () => import_units.formatEther,
  formatUnits: () => import_units.formatUnits,
  getAccountPath: () => import_hdnode.getAccountPath,
  getAddress: () => import_address3.getAddress,
  getContractAddress: () => import_address3.getContractAddress,
  getCreate2Address: () => import_address3.getCreate2Address,
  getIcapAddress: () => import_address3.getIcapAddress,
  getJsonWalletAddress: () => import_json_wallets.getJsonWalletAddress,
  getStatic: () => import_properties13.getStatic,
  hashMessage: () => import_hash3.hashMessage,
  hexConcat: () => import_bytes7.hexConcat,
  hexDataLength: () => import_bytes7.hexDataLength,
  hexDataSlice: () => import_bytes7.hexDataSlice,
  hexStripZeros: () => import_bytes7.hexStripZeros,
  hexValue: () => import_bytes7.hexValue,
  hexZeroPad: () => import_bytes7.hexZeroPad,
  hexlify: () => import_bytes7.hexlify,
  id: () => import_hash3.id,
  isAddress: () => import_address3.isAddress,
  isBytes: () => import_bytes7.isBytes,
  isBytesLike: () => import_bytes7.isBytesLike,
  isHexString: () => import_bytes7.isHexString,
  isValidMnemonic: () => import_hdnode.isValidMnemonic,
  isValidName: () => import_hash3.isValidName,
  joinSignature: () => import_bytes7.joinSignature,
  keccak256: () => import_keccak256.keccak256,
  mnemonicToEntropy: () => import_hdnode.mnemonicToEntropy,
  mnemonicToSeed: () => import_hdnode.mnemonicToSeed,
  namehash: () => import_hash3.namehash,
  nameprep: () => import_strings3.nameprep,
  parseBytes32String: () => import_strings3.parseBytes32String,
  parseEther: () => import_units.parseEther,
  parseTransaction: () => import_transactions5.parse,
  parseUnits: () => import_units.parseUnits,
  poll: () => import_web6.poll,
  randomBytes: () => import_random2.randomBytes,
  recoverAddress: () => import_transactions5.recoverAddress,
  recoverPublicKey: () => import_signing_key.recoverPublicKey,
  resolveProperties: () => import_properties13.resolveProperties,
  ripemd160: () => import_sha22.ripemd160,
  serializeTransaction: () => import_transactions5.serialize,
  sha256: () => import_sha22.sha256,
  sha512: () => import_sha22.sha512,
  shallowCopy: () => import_properties13.shallowCopy,
  shuffled: () => import_random2.shuffled,
  solidityKeccak256: () => import_solidity.keccak256,
  solidityPack: () => import_solidity.pack,
  soliditySha256: () => import_solidity.sha256,
  splitSignature: () => import_bytes7.splitSignature,
  stripZeros: () => import_bytes7.stripZeros,
  toUtf8Bytes: () => import_strings3.toUtf8Bytes,
  toUtf8CodePoints: () => import_strings3.toUtf8CodePoints,
  toUtf8String: () => import_strings3.toUtf8String,
  verifyMessage: () => import_wallet.verifyMessage,
  verifyTypedData: () => import_wallet.verifyTypedData,
  zeroPad: () => import_bytes7.zeroPad
});
var import_abi2 = __toESM(require_lib13());
var import_address3 = __toESM(require_lib7());
var base64 = __toESM(require_lib10());
var import_basex2 = __toESM(require_lib18());
var import_bytes7 = __toESM(require_lib2());
var import_hash3 = __toESM(require_lib12());
var import_hdnode = __toESM(require_lib22());
var import_json_wallets = __toESM(require_lib24());
var import_keccak256 = __toESM(require_lib5());
var import_logger19 = __toESM(require_lib());
var import_sha22 = __toESM(require_lib19());
var import_solidity = __toESM(require_lib27());
var import_random2 = __toESM(require_lib23());
var import_properties13 = __toESM(require_lib4());
var RLP = __toESM(require_lib6());
var import_signing_key = __toESM(require_lib16());
var import_strings3 = __toESM(require_lib9());
var import_transactions5 = __toESM(require_lib17());
var import_units = __toESM(require_lib28());
var import_wallet = __toESM(require_lib25());
var import_web6 = __toESM(require_lib26());
var import_sha23 = __toESM(require_lib19());
var import_strings4 = __toESM(require_lib9());

// node_modules/ethers/lib.esm/ethers.js
var import_logger20 = __toESM(require_lib());

// node_modules/ethers/lib.esm/_version.js
var version4 = "ethers/5.7.2";

// node_modules/ethers/lib.esm/ethers.js
var logger18 = new import_logger20.Logger(version4);

// node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal = window;
  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/@wagmi/connectors/dist/chunk-V2FVPXGH.js
var import_utils = __toESM(require_utils5(), 1);
function getInjectedName(ethereum) {
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isApexWallet)
      return "Apex Wallet";
    if (provider.isAvalanche)
      return "Core Wallet";
    if (provider.isBackpack)
      return "Backpack";
    if (provider.isBifrost)
      return "Bifrost Wallet";
    if (provider.isBitKeep)
      return "BitKeep";
    if (provider.isBitski)
      return "Bitski";
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isDawn)
      return "Dawn Wallet";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFrame)
      return "Frame";
    if (provider.isFrontier)
      return "Frontier Wallet";
    if (provider.isGamestop)
      return "GameStop Wallet";
    if (provider.isHyperPay)
      return "HyperPay Wallet";
    if (provider.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider.isMathWallet)
      return "MathWallet";
    if (provider.isOkxWallet || provider.isOKExWallet)
      return "OKX Wallet";
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider.isOpera)
      return "Opera";
    if (provider.isPhantom)
      return "Phantom";
    if (provider.isPortal)
      return "Ripio Portal";
    if (provider.isRainbow)
      return "Rainbow";
    if (provider.isStatus)
      return "Status";
    if (provider.isTally)
      return "Tally";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust || provider.isTrustWallet)
      return "Trust Wallet";
    if (provider.isXDEFI)
      return "XDEFI Wallet";
    if (provider.isZerion)
      return "Zerion";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if (ethereum.providers?.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name2 = getName(provider);
      if (!name2) {
        name2 = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name2);
    }
    const names = [...nameSet];
    if (names.length)
      return names;
    return names[0] ?? "Injected";
  }
  return getName(ethereum) ?? "Injected";
}
var _provider;
var InjectedConnector = class extends Connector {
  constructor({
    chains,
    options: options_
  } = {}) {
    const options = {
      shimDisconnect: true,
      getProvider: () => typeof window !== "undefined" ? window.ethereum : void 0,
      ...options_
    };
    super({ chains, options });
    __publicField(this, "id", "injected");
    __publicField(this, "name");
    __publicField(this, "ready");
    __privateAdd2(this, _provider, void 0);
    __publicField(this, "shimDisconnectKey", `${this.id}.shimDisconnect`);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils.getAddress)(accounts[0])
        });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    });
    __publicField(this, "onDisconnect", async (error) => {
      if (error.code === 1013) {
        const provider2 = await this.getProvider();
        if (provider2) {
          const isAuthorized = await this.getAccount();
          if (isAuthorized)
            return;
        }
      }
      this.emit("disconnect");
      if (this.options.shimDisconnect)
        getClient().storage?.removeItem(this.shimDisconnectKey);
    });
    const provider = options.getProvider();
    if (typeof options.name === "string")
      this.name = options.name;
    else if (provider) {
      const detectedName = getInjectedName(provider);
      if (options.name)
        this.name = options.name(detectedName);
      else {
        if (typeof detectedName === "string")
          this.name = detectedName;
        else
          this.name = detectedName[0];
      }
    } else
      this.name = "Injected";
    this.ready = !!provider;
  }
  async connect({ chainId } = {}) {
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = (0, import_utils.getAddress)(accounts[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain = await this.switchChain(chainId);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if (this.options.shimDisconnect)
        getClient().storage?.setItem(this.shimDisconnectKey, true);
      return { account, chain: { id: id2, unsupported }, provider };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    if (!provider?.removeListener)
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if (this.options.shimDisconnect)
      getClient().storage?.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return (0, import_utils.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({ method: "eth_chainId" }).then(normalizeChainId);
  }
  async getProvider() {
    const provider = this.options.getProvider();
    if (provider)
      __privateSet2(this, _provider, provider);
    return __privateGet2(this, _provider);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    return new lib_exports.Web3Provider(
      provider,
      chainId
    ).getSigner(account);
  }
  async isAuthorized() {
    try {
      if (this.options.shimDisconnect && !getClient().storage?.getItem(this.shimDisconnectKey))
        return false;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id2 = (0, import_utils.hexValue)(chainId);
    try {
      await Promise.all([
        provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: id2 }]
        }),
        new Promise(
          (res) => this.on("change", ({ chain }) => {
            if (chain?.id === chainId)
              res();
          })
        )
      ]);
      return this.chains.find((x8) => x8.id === chainId) ?? {
        id: chainId,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: { default: { http: [""] }, public: { http: [""] } }
      };
    } catch (error) {
      const chain = this.chains.find((x8) => x8.id === chainId);
      if (!chain)
        throw new ChainNotConfiguredError({ chainId, connectorId: this.id });
      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id2,
                chainName: chain.name,
                nativeCurrency: chain.nativeCurrency,
                rpcUrls: [chain.rpcUrls.public?.http[0] ?? ""],
                blockExplorerUrls: this.getBlockExplorerUrls(chain)
              }
            ]
          });
          const currentChainId = await this.getChainId();
          if (currentChainId !== chainId)
            throw new ProviderRpcError(
              "User rejected switch after adding network.",
              { code: 4001 }
            );
          return chain;
        } catch (addError) {
          if (this.isUserRejectedRequestError(addError))
            throw new UserRejectedRequestError(error);
          throw new AddChainError();
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
_provider = /* @__PURE__ */ new WeakMap();

// node_modules/zustand/esm/middleware.mjs
var subscribeWithSelectorImpl = (fn3) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn3(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage) {
  let storage;
  try {
    storage = getStorage();
  } catch (e11) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a2;
      const parse3 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2);
      };
      const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
      if (str instanceof Promise) {
        return str.then(parse3);
      }
      return parse3(str);
    },
    setItem: (name2, newValue) => storage.setItem(name2, JSON.stringify(newValue)),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
var toThenable = (fn3) => (input) => {
  try {
    const result = fn3(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e11) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e11);
      }
    };
  }
};
var oldImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e11) {
  }
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e11) => {
      errorInSync = e11;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a2 = options.onRehydrateStorage) == null ? void 0 : _a2.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e11) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e11);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
var newImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a2 = options.onRehydrateStorage) == null ? void 0 : _a2.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e11) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e11);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
var persistImpl = (config, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
var persist = persistImpl;

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe2 = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe: subscribe2, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@wagmi/core/dist/chunk-55IO54NW.js
var import_utils2 = __toESM(require_utils5(), 1);
var import_utils3 = __toESM(require_utils5(), 1);
var import_utils4 = __toESM(require_utils5(), 1);

// node_modules/zustand/esm/shallow.mjs
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i10 = 0; i10 < keysA.length; i10++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i10]) || !Object.is(objA[keysA[i10]], objB[keysA[i10]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@wagmi/core/dist/chunk-55IO54NW.js
var import_utils5 = __toESM(require_utils5(), 1);
var import_utils6 = __toESM(require_utils5(), 1);
var import_utils7 = __toESM(require_utils5(), 1);
var import_utils8 = __toESM(require_utils5(), 1);
function configureChains(defaultChains, providers2, {
  minQuorum = 1,
  pollingInterval = 4e3,
  targetQuorum = 1,
  stallTimeout
} = {}) {
  if (!defaultChains.length)
    throw new Error("must have at least one chain");
  if (targetQuorum < minQuorum)
    throw new Error("quorum cannot be lower than minQuorum");
  let chains = [];
  const providers_ = {};
  const webSocketProviders_ = {};
  for (const chain of defaultChains) {
    let configExists = false;
    for (const provider of providers2) {
      const apiConfig = provider(chain);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains.some(({ id: id2 }) => id2 === chain.id)) {
        chains = [...chains, apiConfig.chain];
      }
      providers_[chain.id] = [
        ...providers_[chain.id] || [],
        apiConfig.provider
      ];
      if (apiConfig.webSocketProvider) {
        webSocketProviders_[chain.id] = [
          ...webSocketProviders_[chain.id] || [],
          apiConfig.webSocketProvider
        ];
      }
    }
    if (!configExists) {
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${chain.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/core/providers/jsonRpc"
        ].join("\n")
      );
    }
  }
  return {
    chains,
    provider: ({ chainId }) => {
      const activeChain = chains.find((x8) => x8.id === chainId) ?? defaultChains[0];
      const chainProviders = providers_[activeChain.id];
      if (!chainProviders || !chainProviders[0])
        throw new Error(`No providers configured for chain "${activeChain.id}"`);
      let provider;
      if (chainProviders.length === 1) {
        provider = chainProviders[0]();
      } else {
        provider = fallbackProvider(targetQuorum, minQuorum, chainProviders, {
          stallTimeout
        });
      }
      if (activeChain.id === 42220) {
        provider.formatter.formats.block = {
          ...provider.formatter.formats.block,
          difficulty: () => 0,
          gasLimit: () => 0
        };
      }
      return Object.assign(provider, {
        chains,
        pollingInterval
      });
    },
    webSocketProvider: ({ chainId }) => {
      const activeChain = chains.find((x8) => x8.id === chainId) ?? defaultChains[0];
      const chainWebSocketProviders = webSocketProviders_[activeChain.id];
      if (!chainWebSocketProviders)
        return void 0;
      const provider = chainWebSocketProviders[0]?.();
      if (provider && activeChain.id === 42220) {
        provider.formatter.formats.block = {
          ...provider.formatter.formats.block,
          difficulty: () => 0,
          gasLimit: () => 0
        };
      }
      return Object.assign(provider || {}, {
        chains
      });
    }
  };
}
function fallbackProvider(targetQuorum, minQuorum, providers_, { stallTimeout }) {
  try {
    return new lib_exports.FallbackProvider(
      providers_.map((chainProvider, index) => {
        const provider = chainProvider();
        return {
          provider,
          priority: provider.priority ?? index,
          stallTimeout: provider.stallTimeout ?? stallTimeout,
          weight: provider.weight
        };
      }),
      targetQuorum
    );
  } catch (error) {
    if (error?.message?.includes(
      "quorum will always fail; larger than total weight"
    )) {
      if (targetQuorum === minQuorum)
        throw error;
      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {
        stallTimeout
      });
    }
    throw error;
  }
}
function assertActiveChain({
  chainId,
  signer
}) {
  const { chain: activeChain, chains } = getNetwork2();
  const activeChainId = activeChain?.id;
  if (activeChainId && chainId !== activeChainId) {
    throw new ChainMismatchError({
      activeChain: chains.find((x8) => x8.id === activeChainId)?.name ?? `Chain ${activeChainId}`,
      targetChain: chains.find((x8) => x8.id === chainId)?.name ?? `Chain ${chainId}`
    });
  }
  if (signer) {
    const signerChainId = signer.provider?.network?.chainId;
    if (signerChainId && chainId !== signerChainId) {
      const connector = getClient().connector;
      throw new ChainNotConfiguredError({
        chainId,
        connectorId: connector?.id ?? "unknown"
      });
    }
  }
}
function debounce(fn3, waitTime = 0) {
  let timeout;
  return function(...args) {
    if (!waitTime)
      return fn3(...args);
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      fn3(...args);
    }, waitTime);
  };
}
var findAndReplace = (cacheRef, {
  find,
  replace
}) => {
  if (cacheRef && find(cacheRef)) {
    return replace(cacheRef);
  }
  if (typeof cacheRef !== "object") {
    return cacheRef;
  }
  if (Array.isArray(cacheRef)) {
    return cacheRef.map((item) => findAndReplace(item, { find, replace }));
  }
  if (cacheRef instanceof Object) {
    return Object.entries(cacheRef).reduce(
      (curr, [key, value]) => ({
        ...curr,
        [key]: findAndReplace(value, { find, replace })
      }),
      {}
    );
  }
  return cacheRef;
};
function deserialize(cachedString) {
  const cache = JSON.parse(cachedString);
  const deserializedCacheWithBigNumbers = findAndReplace(cache, {
    find: (data2) => data2.type === "BigNumber",
    replace: (data2) => import_bignumber7.BigNumber.from(data2.hex)
  });
  return deserializedCacheWithBigNumbers;
}
function normalizeFunctionName({
  contract,
  functionName,
  args = []
}) {
  if (functionName in contract.functions)
    return functionName;
  const argsLength = args?.length ?? 0;
  const overloadFunctions = Object.keys(contract.functions).filter((x8) => x8.startsWith(`${functionName}(`)).map((x8) => ({ name: x8, fragment: import_utils2.FunctionFragment.fromString(x8) })).filter((x8) => argsLength === x8.fragment.inputs.length);
  for (const overloadFunction of overloadFunctions) {
    const matched = args.every((arg, index) => {
      const abiParameter = overloadFunction.fragment.inputs[index];
      return isArgOfType(arg, abiParameter);
    });
    if (matched)
      return overloadFunction.name;
  }
  return functionName;
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return (0, import_utils2.isAddress)(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every(
          (component, index) => {
            return isArgOfType(
              Object.values(arg)[index],
              component
            );
          }
        );
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
        abiParameterType
      ))
        return argType === "number" || argType === "bigint" || import_bignumber7.BigNumber.isBigNumber(arg);
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every(
          (x8) => isArgOfType(x8, {
            ...abiParameter,
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          })
        );
      }
      return false;
    }
  }
}
function logWarn(message) {
  getClient()?.config.logger?.warn?.(message);
}
function normalizeChainId(chainId) {
  if (typeof chainId === "string")
    return Number.parseInt(
      chainId,
      chainId.trim().substring(0, 2) === "0x" ? 16 : 10
    );
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length: length2 } = array;
  for (let index = 0; index < length2; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(
            this,
            key,
            value,
            getReferenceKey(keys, valueCutoff)
          ) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize2(value, replacer, indent, circularReplacer) {
  return JSON.stringify(
    value,
    createReplacer(replacer, circularReplacer),
    indent ?? void 0
  );
}
var noopStorage = {
  getItem: (_key) => "",
  setItem: (_key, _value) => null,
  removeItem: (_key) => null
};
function createStorage({
  deserialize: deserialize2 = deserialize,
  key: prefix = "wagmi",
  serialize: serialize22 = serialize2,
  storage
}) {
  return {
    ...storage,
    getItem: (key, defaultState = null) => {
      const value = storage.getItem(`${prefix}.${key}`);
      try {
        return value ? deserialize2(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem(`${prefix}.${key}`);
      } else {
        try {
          storage.setItem(`${prefix}.${key}`, serialize22(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key) => storage.removeItem(`${prefix}.${key}`)
  };
}
var storeKey = "store";
var _isAutoConnecting;
var _lastUsedConnector;
var _addEffects;
var addEffects_fn;
var Client = class {
  constructor({
    autoConnect = false,
    connectors = [new InjectedConnector()],
    provider,
    storage = createStorage({
      storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }),
    logger: logger19 = {
      warn: console.warn
    },
    webSocketProvider
  }) {
    __privateAdd(this, _addEffects);
    this.providers = /* @__PURE__ */ new Map();
    this.webSocketProviders = /* @__PURE__ */ new Map();
    __privateAdd(this, _isAutoConnecting, void 0);
    __privateAdd(this, _lastUsedConnector, void 0);
    this.config = {
      autoConnect,
      connectors,
      logger: logger19,
      provider,
      storage,
      webSocketProvider
    };
    let status = "disconnected";
    let chainId;
    if (autoConnect) {
      try {
        const rawState = storage.getItem(storeKey);
        const data2 = rawState?.state?.data;
        status = data2?.account ? "reconnecting" : "connecting";
        chainId = data2?.chain?.id;
      } catch (_error) {
      }
    }
    this.store = createStore(
      subscribeWithSelector(
        persist(
          () => ({
            connectors: typeof connectors === "function" ? connectors() : connectors,
            provider: this.getProvider({ chainId }),
            status,
            webSocketProvider: this.getWebSocketProvider({ chainId })
          }),
          {
            name: storeKey,
            storage,
            partialize: (state) => ({
              ...autoConnect && {
                data: {
                  account: state?.data?.account,
                  chain: state?.data?.chain
                }
              },
              chains: state?.chains
            }),
            version: 2
          }
        )
      )
    );
    this.storage = storage;
    __privateSet(this, _lastUsedConnector, storage?.getItem("wallet"));
    __privateMethod(this, _addEffects, addEffects_fn).call(this);
    if (autoConnect && typeof window !== "undefined")
      setTimeout(async () => await this.autoConnect(), 0);
  }
  get chains() {
    return this.store.getState().chains;
  }
  get connectors() {
    return this.store.getState().connectors;
  }
  get connector() {
    return this.store.getState().connector;
  }
  get data() {
    return this.store.getState().data;
  }
  get error() {
    return this.store.getState().error;
  }
  get lastUsedChainId() {
    return this.data?.chain?.id;
  }
  get provider() {
    return this.store.getState().provider;
  }
  get status() {
    return this.store.getState().status;
  }
  get subscribe() {
    return this.store.subscribe;
  }
  get webSocketProvider() {
    return this.store.getState().webSocketProvider;
  }
  setState(updater) {
    const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }
  clearState() {
    this.setState((x8) => ({
      ...x8,
      chains: void 0,
      connector: void 0,
      data: void 0,
      error: void 0,
      status: "disconnected"
    }));
  }
  async destroy() {
    if (this.connector)
      await this.connector.disconnect?.();
    __privateSet(this, _isAutoConnecting, false);
    this.clearState();
    this.store.destroy();
  }
  async autoConnect() {
    if (__privateGet(this, _isAutoConnecting))
      return;
    __privateSet(this, _isAutoConnecting, true);
    this.setState((x8) => ({
      ...x8,
      status: x8.data?.account ? "reconnecting" : "connecting"
    }));
    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(
      (x8) => x8.id === __privateGet(this, _lastUsedConnector) ? -1 : 1
    ) : this.connectors;
    let connected = false;
    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized)
        continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized)
        continue;
      const data2 = await connector.connect();
      this.setState((x8) => ({
        ...x8,
        connector,
        chains: connector?.chains,
        data: data2,
        status: "connected"
      }));
      connected = true;
      break;
    }
    if (!connected)
      this.setState((x8) => ({
        ...x8,
        data: void 0,
        status: "disconnected"
      }));
    __privateSet(this, _isAutoConnecting, false);
    return this.data;
  }
  getProvider({ bust, chainId } = {}) {
    let provider_ = this.providers.get(chainId ?? -1);
    if (provider_ && !bust)
      return provider_;
    const { provider } = this.config;
    provider_ = typeof provider === "function" ? provider({ chainId }) : provider;
    this.providers.set(chainId ?? -1, provider_);
    return provider_;
  }
  getWebSocketProvider({
    bust,
    chainId
  } = {}) {
    let webSocketProvider_ = this.webSocketProviders.get(chainId ?? -1);
    if (webSocketProvider_ && !bust)
      return webSocketProvider_;
    const { webSocketProvider } = this.config;
    webSocketProvider_ = typeof webSocketProvider === "function" ? webSocketProvider({ chainId }) : webSocketProvider;
    if (webSocketProvider_)
      this.webSocketProviders.set(chainId ?? -1, webSocketProvider_);
    return webSocketProvider_;
  }
  setLastUsedConnector(lastUsedConnector = null) {
    this.storage?.setItem("wallet", lastUsedConnector);
  }
};
_isAutoConnecting = /* @__PURE__ */ new WeakMap();
_lastUsedConnector = /* @__PURE__ */ new WeakMap();
_addEffects = /* @__PURE__ */ new WeakSet();
addEffects_fn = function() {
  const onChange = (data2) => {
    this.setState((x8) => ({
      ...x8,
      data: { ...x8.data, ...data2 }
    }));
  };
  const onDisconnect = () => {
    this.clearState();
  };
  const onError = (error) => {
    this.setState((x8) => ({ ...x8, error }));
  };
  this.store.subscribe(
    ({ connector }) => connector,
    (connector, prevConnector) => {
      prevConnector?.off?.("change", onChange);
      prevConnector?.off?.("disconnect", onDisconnect);
      prevConnector?.off?.("error", onError);
      if (!connector)
        return;
      connector.on?.("change", onChange);
      connector.on?.("disconnect", onDisconnect);
      connector.on?.("error", onError);
    }
  );
  const { provider, webSocketProvider } = this.config;
  const subscribeProvider = typeof provider === "function";
  const subscribeWebSocketProvider = typeof webSocketProvider === "function";
  if (subscribeProvider || subscribeWebSocketProvider)
    this.store.subscribe(
      ({ data: data2 }) => data2?.chain?.id,
      (chainId) => {
        this.setState((x8) => ({
          ...x8,
          provider: this.getProvider({ bust: true, chainId }),
          webSocketProvider: this.getWebSocketProvider({
            bust: true,
            chainId
          })
        }));
      }
    );
};
var client;
function createClient(config) {
  const client_ = new Client(config);
  client = client_;
  return client_;
}
function getClient() {
  if (!client) {
    throw new Error(
      "No wagmi client found. Ensure you have set up a client: https://wagmi.sh/react/client"
    );
  }
  return client;
}
async function connect({
  chainId,
  connector
}) {
  const client2 = getClient();
  const activeConnector = client2.connector;
  if (activeConnector && connector.id === activeConnector.id)
    throw new ConnectorAlreadyConnectedError();
  try {
    client2.setState((x8) => ({ ...x8, status: "connecting" }));
    const data2 = await connector.connect({ chainId });
    client2.setLastUsedConnector(connector.id);
    client2.setState((x8) => ({
      ...x8,
      connector,
      chains: connector?.chains,
      data: data2,
      status: "connected"
    }));
    client2.storage.setItem("connected", true);
    return { ...data2, connector };
  } catch (err) {
    client2.setState((x8) => {
      return {
        ...x8,
        status: x8.connector ? "connected" : "disconnected"
      };
    });
    throw err;
  }
}
async function disconnect() {
  const client2 = getClient();
  if (client2.connector)
    await client2.connector.disconnect();
  client2.clearState();
  client2.storage.removeItem("connected");
}
var erc20ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var erc20ABI_bytes32 = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var multicallABI = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
async function fetchToken({
  address,
  chainId,
  formatUnits: units2 = "ether"
}) {
  async function fetchToken_({ abi }) {
    const erc20Config = { address, abi, chainId };
    const [decimals, name2, symbol, totalSupply] = await readContracts({
      allowFailure: false,
      contracts: [
        { ...erc20Config, functionName: "decimals" },
        { ...erc20Config, functionName: "name" },
        { ...erc20Config, functionName: "symbol" },
        { ...erc20Config, functionName: "totalSupply" }
      ]
    });
    return {
      address,
      decimals,
      name: name2,
      symbol,
      totalSupply: {
        formatted: (0, import_utils4.formatUnits)(totalSupply, units2),
        value: totalSupply
      }
    };
  }
  try {
    return await fetchToken_({ abi: erc20ABI });
  } catch (err) {
    if (err instanceof ContractResultDecodeError) {
      const { name: name2, symbol, ...rest } = await fetchToken_({
        abi: erc20ABI_bytes32
      });
      return {
        name: (0, import_utils4.parseBytes32String)(name2),
        symbol: (0, import_utils4.parseBytes32String)(symbol),
        ...rest
      };
    }
    throw err;
  }
}
function getContract({
  address,
  abi,
  signerOrProvider
}) {
  return new Contract(
    address,
    abi,
    signerOrProvider
  );
}
function getProvider({
  chainId
} = {}) {
  const client2 = getClient();
  if (chainId)
    return client2.getProvider({ chainId }) || client2.provider;
  return client2.provider;
}
function getWebSocketProvider({
  chainId
} = {}) {
  const client2 = getClient();
  if (chainId)
    return client2.getWebSocketProvider({ chainId }) || client2.webSocketProvider;
  return client2.webSocketProvider;
}
async function multicall({
  allowFailure = true,
  chainId,
  contracts,
  overrides
}) {
  const provider = getProvider({ chainId });
  if (!provider.chains)
    throw new ProviderChainsNotFound();
  const chain = provider.chains.find((chain2) => chain2.id === chainId) || provider.chains[0];
  if (!chain)
    throw new ProviderChainsNotFound();
  if (!chain?.contracts?.multicall3)
    throw new ChainDoesNotSupportMulticallError({ chain });
  if (typeof overrides?.blockTag === "number" && overrides?.blockTag < (chain.contracts.multicall3.blockCreated ?? 0))
    throw new ChainDoesNotSupportMulticallError({
      blockNumber: overrides?.blockTag,
      chain
    });
  const multicallContract = getContract({
    address: chain.contracts.multicall3.address,
    abi: multicallABI,
    signerOrProvider: provider
  });
  const calls = contracts.map(
    ({ address, abi, functionName, ...config }) => {
      const { args } = config || {};
      const contract = getContract({ address, abi });
      const params2 = args ?? [];
      const normalizedFunctionName = normalizeFunctionName({
        contract,
        functionName,
        args
      });
      try {
        const contractFunction = contract[normalizedFunctionName];
        if (!contractFunction)
          logWarn(
            `"${normalizedFunctionName}" is not in the interface for contract "${address}"`
          );
        const callData = contract.interface.encodeFunctionData(
          normalizedFunctionName,
          params2
        );
        return {
          target: address,
          allowFailure,
          callData
        };
      } catch (err) {
        if (!allowFailure)
          throw err;
        return {
          target: address,
          allowFailure,
          callData: "0x"
        };
      }
    }
  );
  const params = [...[calls], ...overrides ? [overrides] : []];
  const results2 = await multicallContract.aggregate3(
    ...params
  );
  return results2.map(({ returnData, success }, i10) => {
    const { address, abi, functionName, ...rest } = contracts[i10];
    const contract = getContract({
      address,
      abi
    });
    const args = rest.args;
    const normalizedFunctionName = normalizeFunctionName({
      contract,
      functionName,
      args
    });
    if (!success) {
      let error;
      try {
        contract.interface.decodeFunctionResult(
          normalizedFunctionName,
          returnData
        );
      } catch (err) {
        error = new ContractMethodRevertedError({
          address,
          args,
          chainId: chain.id,
          functionName: normalizedFunctionName,
          errorMessage: err.message
        });
        if (!allowFailure)
          throw error;
        logWarn(error.message);
      }
      return null;
    }
    if (returnData === "0x") {
      const error = new ContractMethodNoResultError({
        address,
        args,
        chainId: chain.id,
        functionName: normalizedFunctionName
      });
      if (!allowFailure)
        throw error;
      logWarn(error.message);
      return null;
    }
    try {
      const result = contract.interface.decodeFunctionResult(
        normalizedFunctionName,
        returnData
      );
      return Array.isArray(result) && result.length === 1 ? result[0] : result;
    } catch (err) {
      const error = new ContractResultDecodeError({
        address,
        args,
        chainId: chain.id,
        functionName: normalizedFunctionName,
        errorMessage: err.message
      });
      if (!allowFailure)
        throw error;
      logWarn(error.message);
      return null;
    }
  });
}
async function readContract({
  address,
  chainId,
  abi,
  functionName,
  overrides,
  ...config
}) {
  const provider = getProvider({ chainId });
  const contract = getContract({
    address,
    abi,
    signerOrProvider: provider
  });
  const args = config.args;
  const normalizedFunctionName = normalizeFunctionName({
    contract,
    functionName,
    args
  });
  const contractFunction = contract[normalizedFunctionName];
  if (!contractFunction)
    throw new ContractMethodDoesNotExistError({
      address,
      functionName: normalizedFunctionName
    });
  const params = [...args ?? [], ...overrides ? [overrides] : []];
  return contractFunction?.(...params);
}
async function readContracts({
  allowFailure = true,
  contracts,
  overrides
}) {
  try {
    const provider = getProvider();
    const contractsByChainId = contracts.reduce((contracts2, contract, index) => {
      const chainId = contract.chainId ?? provider.network.chainId;
      return {
        ...contracts2,
        [chainId]: [...contracts2[chainId] || [], { contract, index }]
      };
    }, {});
    const promises = () => Object.entries(contractsByChainId).map(
      ([chainId, contracts2]) => multicall({
        allowFailure,
        chainId: parseInt(chainId),
        contracts: contracts2.map(({ contract }) => contract),
        overrides
      })
    );
    let multicallResults;
    if (allowFailure) {
      multicallResults = (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return result.value;
        if (result.reason instanceof ChainDoesNotSupportMulticallError) {
          logWarn(result.reason.message);
          throw result.reason;
        }
        return null;
      }).flat();
    } else {
      multicallResults = (await Promise.all(promises())).flat();
    }
    const resultIndexes = Object.values(contractsByChainId).map((contracts2) => contracts2.map(({ index }) => index)).flat();
    return multicallResults.reduce((results2, result, index) => {
      if (results2)
        results2[resultIndexes[index]] = result;
      return results2;
    }, []);
  } catch (err) {
    if (err instanceof ContractResultDecodeError)
      throw err;
    if (err instanceof ContractMethodNoResultError)
      throw err;
    if (err instanceof ContractMethodRevertedError)
      throw err;
    const promises = () => contracts.map(
      (contract) => readContract({ ...contract, overrides })
    );
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result, i10) => {
        if (result.status === "fulfilled")
          return result.value;
        const { address, args, chainId, functionName } = contracts[i10];
        const error = new ContractMethodRevertedError({
          address,
          functionName,
          chainId: chainId ?? 1,
          args,
          errorMessage: result.reason
        });
        logWarn(error.message);
        return null;
      });
    return await Promise.all(promises());
  }
}
async function fetchBlockNumber({
  chainId
} = {}) {
  const provider = getProvider({ chainId });
  const blockNumber = await provider.getBlockNumber();
  return blockNumber;
}
function watchBlockNumber(args, callback) {
  const debouncedCallback = debounce(callback, 1);
  let previousProvider;
  const createListener = (provider) => {
    if (previousProvider) {
      previousProvider?.off("block", debouncedCallback);
    }
    provider.on("block", debouncedCallback);
    previousProvider = provider;
  };
  const provider_ = getWebSocketProvider({ chainId: args.chainId }) ?? getProvider({ chainId: args.chainId });
  if (args.listen)
    createListener(provider_);
  let active = true;
  const client2 = getClient();
  const unsubscribe = client2.subscribe(
    ({ provider, webSocketProvider }) => ({ provider, webSocketProvider }),
    async ({ provider, webSocketProvider }) => {
      const provider_2 = webSocketProvider ?? provider;
      if (args.listen && !args.chainId && provider_2) {
        createListener(provider_2);
      }
      const blockNumber = await fetchBlockNumber({ chainId: args.chainId });
      if (!active)
        return;
      callback(blockNumber);
    },
    {
      equalityFn: shallow
    }
  );
  return () => {
    active = false;
    unsubscribe();
    provider_?.off("block", debouncedCallback);
    previousProvider?.off("block", debouncedCallback);
  };
}
async function fetchTransaction({
  chainId,
  hash
}) {
  const provider = getProvider({ chainId });
  return provider.getTransaction(hash);
}
async function fetchEnsAddress({
  chainId,
  name: name2
}) {
  const provider = getProvider({ chainId });
  const address = await provider.resolveName(name2);
  try {
    return address ? (0, import_utils6.getAddress)(address) : null;
  } catch (_error) {
    return null;
  }
}
async function fetchEnsAvatar({
  address,
  chainId
}) {
  const provider = getProvider({ chainId });
  const avatar = await provider.getAvatar(address);
  return avatar;
}
async function fetchEnsName({
  address,
  chainId
}) {
  const provider = getProvider({ chainId });
  return provider.lookupAddress((0, import_utils7.getAddress)(address));
}
async function prepareSendTransaction({
  chainId,
  request,
  signer: signer_
}) {
  const signer = signer_ ?? await fetchSigner({ chainId });
  if (!signer)
    throw new ConnectorNotFoundError();
  if (chainId)
    assertActiveChain({ chainId, signer });
  const [to2, gasLimit] = await Promise.all([
    (0, import_utils5.isAddress)(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({ name: request.to }),
    request.gasLimit ? Promise.resolve(request.gasLimit) : signer.estimateGas(request)
  ]);
  if (!to2)
    throw new Error("Could not resolve ENS name");
  return {
    ...chainId ? { chainId } : {},
    request: { ...request, gasLimit, to: to2 },
    mode: "prepared"
  };
}
async function sendTransaction({
  chainId,
  mode,
  request
}) {
  const signer = await fetchSigner();
  if (!signer)
    throw new ConnectorNotFoundError();
  if (mode === "prepared") {
    if (!request.gasLimit)
      throw new Error("`gasLimit` is required");
    if (!request.to)
      throw new Error("`to` is required");
  }
  if (chainId)
    assertActiveChain({ chainId, signer });
  try {
    const uncheckedSigner = signer.connectUnchecked?.();
    const { hash, wait } = await (uncheckedSigner ?? signer).sendTransaction(
      request
    );
    return { hash, wait };
  } catch (error) {
    if (error.code === 4001 || error.code === "ACTION_REJECTED")
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function fetchFeeData({
  chainId,
  formatUnits: units2 = "wei"
} = {}) {
  const provider = getProvider({ chainId });
  const feeData = await provider.getFeeData();
  const formatted = {
    gasPrice: feeData.gasPrice ? (0, import_utils8.formatUnits)(feeData.gasPrice, units2) : null,
    maxFeePerGas: feeData.maxFeePerGas ? (0, import_utils8.formatUnits)(feeData.maxFeePerGas, units2) : null,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? (0, import_utils8.formatUnits)(feeData.maxPriorityFeePerGas, units2) : null
  };
  return { ...feeData, formatted };
}
async function fetchBalance({
  address,
  chainId,
  formatUnits: unit,
  token
}) {
  const client2 = getClient();
  const provider = getProvider({ chainId });
  if (token) {
    const fetchContractBalance = async ({ abi }) => {
      const erc20Config = { abi, address: token, chainId };
      const [value2, decimals, symbol] = await readContracts({
        allowFailure: false,
        contracts: [
          {
            ...erc20Config,
            functionName: "balanceOf",
            args: [address]
          },
          { ...erc20Config, functionName: "decimals" },
          { ...erc20Config, functionName: "symbol" }
        ]
      });
      return {
        decimals,
        formatted: (0, import_utils3.formatUnits)(value2 ?? "0", unit ?? decimals),
        symbol,
        value: value2
      };
    };
    try {
      return await fetchContractBalance({ abi: erc20ABI });
    } catch (err) {
      if (err instanceof ContractResultDecodeError) {
        const { symbol, ...rest } = await fetchContractBalance({
          abi: erc20ABI_bytes32
        });
        return {
          symbol: (0, import_utils3.parseBytes32String)(symbol),
          ...rest
        };
      }
      throw err;
    }
  }
  const chains = [...client2.provider.chains || [], ...client2.chains ?? []];
  const value = await provider.getBalance(address);
  const chain = chains.find((x8) => x8.id === provider.network.chainId);
  return {
    decimals: chain?.nativeCurrency.decimals ?? 18,
    formatted: (0, import_utils3.formatUnits)(value ?? "0", unit ?? "ether"),
    symbol: chain?.nativeCurrency.symbol ?? "ETH",
    value
  };
}
async function fetchSigner({
  chainId
} = {}) {
  const client2 = getClient();
  const signer = await client2.connector?.getSigner?.({ chainId }) || null;
  return signer;
}
function getAccount() {
  const { data: data2, connector, status } = getClient();
  switch (status) {
    case "connected":
      return {
        address: data2?.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data2?.account,
        connector,
        isConnected: !!data2?.account,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: data2?.account,
        connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork2() {
  const client2 = getClient();
  const chainId = client2.data?.chain?.id;
  const activeChains = client2.chains ?? [];
  const activeChain = [...client2.provider.chains || [], ...activeChains].find(
    (x8) => x8.id === chainId
  ) ?? {
    id: chainId,
    name: `Chain ${chainId}`,
    network: `${chainId}`,
    nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
    rpcUrls: {
      default: { http: [""] },
      public: { http: [""] }
    }
  };
  return {
    chain: chainId ? {
      ...activeChain,
      ...client2.data?.chain,
      id: chainId
    } : void 0,
    chains: activeChains
  };
}
async function signMessage(args) {
  try {
    const signer = await fetchSigner();
    if (!signer)
      throw new ConnectorNotFoundError();
    return await signer.signMessage(
      args.message
    );
  } catch (error) {
    if (error.code === 4001 || error.code === "ACTION_REJECTED")
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function signTypedData({
  domain: domain2,
  types,
  value
}) {
  const signer = await fetchSigner();
  if (!signer)
    throw new ConnectorNotFoundError();
  const { chainId: chainId_ } = domain2;
  const chainId = chainId_ ? normalizeChainId(chainId_) : void 0;
  if (chainId)
    assertActiveChain({ chainId, signer });
  const types_ = Object.entries(types).filter(([key]) => key !== "EIP712Domain").reduce((types2, [key, attributes]) => {
    types2[key] = attributes.filter((attr) => attr.type !== "EIP712Domain");
    return types2;
  }, {});
  try {
    return await signer._signTypedData(domain2, types_, value);
  } catch (error) {
    if (error.code === 4001 || error.code === "ACTION_REJECTED")
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function switchNetwork({
  chainId
}) {
  const { connector } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return connector.switchChain(chainId);
}
function watchAccount(callback, { selector = (x8) => x8 } = {}) {
  const client2 = getClient();
  const handleChange = () => callback(getAccount());
  const unsubscribe = client2.subscribe(
    ({ data: data2, connector, status }) => selector({
      address: data2?.account,
      connector,
      status
    }),
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
function watchNetwork(callback, { selector = (x8) => x8 } = {}) {
  const client2 = getClient();
  const handleChange = () => callback(getNetwork2());
  const unsubscribe = client2.subscribe(
    ({ data: data2, chains }) => selector({ chainId: data2?.chain?.id, chains }),
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
var RpcError = class extends Error {
  constructor(message, options) {
    const { cause, code: code2, data: data2 } = options;
    if (!Number.isInteger(code2))
      throw new Error('"code" must be an integer.');
    if (!message || typeof message !== "string")
      throw new Error('"message" must be a nonempty string.');
    super(message);
    this.cause = cause;
    this.code = code2;
    this.data = data2;
  }
};
var ProviderRpcError = class extends RpcError {
  constructor(message, options) {
    const { cause, code: code2, data: data2 } = options;
    if (!(Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999))
      throw new Error(
        '"code" must be an integer such that: 1000 <= code <= 4999'
      );
    super(message, { cause, code: code2, data: data2 });
  }
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "AddChainError";
    this.message = "Error adding chain";
  }
};
var ChainDoesNotSupportMulticallError = class extends Error {
  constructor({ blockNumber, chain }) {
    super(
      `Chain "${chain.name}" does not support multicall${blockNumber ? ` on block ${blockNumber}` : ""}.`
    );
    this.name = "ChainDoesNotSupportMulticall";
  }
};
var ChainMismatchError = class extends Error {
  constructor({
    activeChain,
    targetChain
  }) {
    super(
      `Chain mismatch: Expected "${targetChain}", received "${activeChain}".`
    );
    this.name = "ChainMismatchError";
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor({
    chainId,
    connectorId
  }) {
    super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
    this.name = "ChainNotConfigured";
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorAlreadyConnectedError";
    this.message = "Connector already connected";
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorNotFoundError";
    this.message = "Connector not found";
  }
};
var ContractMethodDoesNotExistError = class extends Error {
  constructor({
    address,
    chainId,
    functionName
  }) {
    const { chains, network } = getProvider();
    const chain = chains?.find(({ id: id2 }) => id2 === (chainId || network.chainId));
    const blockExplorer = chain?.blockExplorers?.default;
    super(
      [
        `Function "${functionName}" on contract "${address}" does not exist.`,
        ...blockExplorer ? [
          "",
          `${blockExplorer?.name}: ${blockExplorer?.url}/address/${address}#readContract`
        ] : []
      ].join("\n")
    );
    this.name = "ContractMethodDoesNotExistError";
  }
};
var ContractMethodNoResultError = class extends Error {
  constructor({
    address,
    args,
    chainId,
    functionName
  }) {
    super(
      [
        "Contract read returned an empty response. This could be due to any of the following:",
        `- The contract does not have the function "${functionName}",`,
        "- The parameters passed to the contract function may be invalid, or",
        "- The address is not a contract.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId,
            args
          },
          null,
          2
        )
      ].join("\n")
    );
    this.name = "ContractMethodNoResultError";
  }
};
var ContractMethodRevertedError = class extends Error {
  constructor({
    address,
    args,
    chainId,
    functionName,
    errorMessage
  }) {
    super(
      [
        "Contract method reverted with an error.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId,
            args
          },
          null,
          2
        ),
        "",
        `Details: ${errorMessage}`
      ].join("\n")
    );
    this.name = "ContractMethodRevertedError";
  }
};
var ContractResultDecodeError = class extends Error {
  constructor({
    address,
    args,
    chainId,
    functionName,
    errorMessage
  }) {
    super(
      [
        "Failed to decode contract function result.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId,
            args
          },
          null,
          2
        ),
        "",
        `Details: ${errorMessage}`
      ].join("\n")
    );
    this.name = "ContractResultDecodeError";
  }
};
var ProviderChainsNotFound = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ProviderChainsNotFound";
    this.message = [
      "No chains were found on the wagmi provider. Some functions that require a chain may not work.",
      "",
      "It is recommended to add a list of chains to the provider in `createClient`.",
      "",
      "Example:",
      "",
      "```",
      "import { getDefaultProvider } from 'ethers'",
      "import { chain, createClient } from 'wagmi'",
      "",
      "createClient({",
      "  provider: Object.assign(getDefaultProvider(), { chains: [chain.mainnet] })",
      "})",
      "```"
    ].join("\n");
  }
};
var ResourceUnavailableError = class extends RpcError {
  constructor(cause) {
    super("Resource unavailable", { cause, code: -32002 });
    this.name = "ResourceUnavailable";
  }
};
var SwitchChainError = class extends ProviderRpcError {
  constructor(cause) {
    super("Error switching chain", { cause, code: 4902 });
    this.name = "SwitchChainError";
  }
};
var SwitchChainNotSupportedError = class extends Error {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    this.name = "SwitchChainNotSupportedError";
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor(cause) {
    super("User rejected request", { cause, code: 4001 });
    this.name = "UserRejectedRequestError";
  }
};

// node_modules/@wagmi/connectors/dist/walletConnect.js
var import_utils29 = __toESM(require_utils5(), 1);
var NAMESPACE = "eip155";
var REQUESTED_CHAINS_KEY = "wagmi.requestedChains";
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var _provider2;
var _initProviderPromise;
var _createProvider;
var createProvider_fn;
var _initProvider;
var initProvider_fn;
var _isChainsStale;
var isChainsStale_fn;
var _setupListeners;
var setupListeners_fn;
var _removeListeners;
var removeListeners_fn;
var _setRequestedChainsIds;
var setRequestedChainsIds_fn;
var _getRequestedChainsIds;
var getRequestedChainsIds_fn;
var _getNamespaceChainsIds;
var getNamespaceChainsIds_fn;
var _getNamespaceMethods;
var getNamespaceMethods_fn;
var WalletConnectConnector = class extends Connector {
  constructor(config) {
    super({
      ...config,
      options: { isNewChainsStale: true, ...config.options }
    });
    __privateAdd2(this, _createProvider);
    __privateAdd2(this, _initProvider);
    __privateAdd2(this, _isChainsStale);
    __privateAdd2(this, _setupListeners);
    __privateAdd2(this, _removeListeners);
    __privateAdd2(this, _setRequestedChainsIds);
    __privateAdd2(this, _getRequestedChainsIds);
    __privateAdd2(this, _getNamespaceChainsIds);
    __privateAdd2(this, _getNamespaceMethods);
    __publicField(this, "id", "walletConnect");
    __publicField(this, "name", "WalletConnect");
    __publicField(this, "ready", true);
    __privateAdd2(this, _provider2, void 0);
    __privateAdd2(this, _initProviderPromise, void 0);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: (0, import_utils29.getAddress)(accounts[0]) });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = Number(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    });
    __publicField(this, "onDisconnect", () => {
      __privateMethod2(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
      this.emit("disconnect");
    });
    __publicField(this, "onDisplayUri", (uri) => {
      this.emit("message", { type: "display_uri", data: uri });
    });
    __publicField(this, "onConnect", () => {
      this.emit("connect", { provider: __privateGet2(this, _provider2) });
    });
    __privateMethod2(this, _createProvider, createProvider_fn).call(this);
  }
  async connect({ chainId, pairingTopic } = {}) {
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const lastUsedChainId = getClient().lastUsedChainId;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
        else
          targetChainId = this.chains[0]?.id;
      }
      if (!targetChainId)
        throw new Error("No chains found on connector.");
      const provider = await this.getProvider();
      __privateMethod2(this, _setupListeners, setupListeners_fn).call(this);
      const isChainsStale = __privateMethod2(this, _isChainsStale, isChainsStale_fn).call(this);
      if (provider.session && isChainsStale)
        await provider.disconnect();
      if (!provider.session || isChainsStale) {
        const optionalChains = this.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
        this.emit("message", { type: "connecting" });
        await provider.connect({
          pairingTopic,
          chains: [targetChainId],
          optionalChains
        });
        __privateMethod2(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({ id: id22 }) => id22));
      }
      const accounts = await provider.enable();
      const account = (0, import_utils29.getAddress)(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      return {
        account,
        chain: { id: id2, unsupported },
        provider: new lib_exports.Web3Provider(provider)
      };
    } catch (error) {
      if (/user rejected/i.test(error?.message)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    try {
      await provider.disconnect();
    } catch (error) {
      if (!/No matching key/i.test(error.message))
        throw error;
    } finally {
      __privateMethod2(this, _removeListeners, removeListeners_fn).call(this);
      __privateMethod2(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
    }
  }
  async getAccount() {
    const { accounts } = await this.getProvider();
    return (0, import_utils29.getAddress)(accounts[0]);
  }
  async getChainId() {
    const { chainId } = await this.getProvider();
    return chainId;
  }
  async getProvider({ chainId } = {}) {
    if (!__privateGet2(this, _provider2))
      await __privateMethod2(this, _createProvider, createProvider_fn).call(this);
    if (chainId)
      await this.switchChain(chainId);
    return __privateGet2(this, _provider2);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    return new lib_exports.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    try {
      const [account, provider] = await Promise.all([
        this.getAccount(),
        this.getProvider()
      ]);
      const isChainsStale = __privateMethod2(this, _isChainsStale, isChainsStale_fn).call(this);
      if (!account)
        return false;
      if (isChainsStale && provider.session) {
        try {
          await provider.disconnect();
        } catch {
        }
        return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const chain = this.chains.find((chain2) => chain2.id === chainId);
    if (!chain)
      throw new SwitchChainError(new Error("chain not found on connector."));
    try {
      const provider = await this.getProvider();
      const namespaceChains = __privateMethod2(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
      const namespaceMethods = __privateMethod2(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
      const isChainApproved = namespaceChains.includes(chainId);
      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
        await provider.request({
          method: ADD_ETH_CHAIN_METHOD,
          params: [
            {
              chainId: (0, import_utils29.hexValue)(chain.id),
              blockExplorerUrls: [chain.blockExplorers?.default],
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: [...chain.rpcUrls.default.http]
            }
          ]
        });
        const requestedChains = __privateMethod2(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
        requestedChains.push(chainId);
        __privateMethod2(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);
      }
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: (0, import_utils29.hexValue)(chainId) }]
      });
      return chain;
    } catch (error) {
      const message = typeof error === "string" ? error : error?.message;
      if (/user rejected request/i.test(message)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
};
_provider2 = /* @__PURE__ */ new WeakMap();
_initProviderPromise = /* @__PURE__ */ new WeakMap();
_createProvider = /* @__PURE__ */ new WeakSet();
createProvider_fn = async function() {
  if (!__privateGet2(this, _initProviderPromise) && typeof window !== "undefined") {
    __privateSet2(this, _initProviderPromise, __privateMethod2(this, _initProvider, initProvider_fn).call(this));
  }
  return __privateGet2(this, _initProviderPromise);
};
_initProvider = /* @__PURE__ */ new WeakSet();
initProvider_fn = async function() {
  const {
    default: EthereumProvider,
    OPTIONAL_EVENTS,
    OPTIONAL_METHODS
  } = await Promise.resolve().then(() => (init_index_es15(), index_es_exports));
  const [defaultChain, ...optionalChains] = this.chains.map(({ id: id2 }) => id2);
  if (defaultChain) {
    const { projectId, showQrModal = true, qrModalOptions } = this.options;
    __privateSet2(this, _provider2, await EthereumProvider.init({
      showQrModal,
      qrModalOptions,
      projectId,
      optionalMethods: OPTIONAL_METHODS,
      optionalEvents: OPTIONAL_EVENTS,
      chains: [defaultChain],
      optionalChains,
      rpcMap: Object.fromEntries(
        this.chains.map((chain) => [
          chain.id,
          chain.rpcUrls.default.http[0]
        ])
      )
    }));
  }
};
_isChainsStale = /* @__PURE__ */ new WeakSet();
isChainsStale_fn = function() {
  const namespaceMethods = __privateMethod2(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD))
    return false;
  if (!this.options.isNewChainsStale)
    return false;
  const requestedChains = __privateMethod2(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
  const connectorChains = this.chains.map(({ id: id2 }) => id2);
  const namespaceChains = __privateMethod2(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
  if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
    return false;
  return !connectorChains.every((id2) => requestedChains.includes(id2));
};
_setupListeners = /* @__PURE__ */ new WeakSet();
setupListeners_fn = function() {
  if (!__privateGet2(this, _provider2))
    return;
  __privateMethod2(this, _removeListeners, removeListeners_fn).call(this);
  __privateGet2(this, _provider2).on("accountsChanged", this.onAccountsChanged);
  __privateGet2(this, _provider2).on("chainChanged", this.onChainChanged);
  __privateGet2(this, _provider2).on("disconnect", this.onDisconnect);
  __privateGet2(this, _provider2).on("session_delete", this.onDisconnect);
  __privateGet2(this, _provider2).on("display_uri", this.onDisplayUri);
  __privateGet2(this, _provider2).on("connect", this.onConnect);
};
_removeListeners = /* @__PURE__ */ new WeakSet();
removeListeners_fn = function() {
  if (!__privateGet2(this, _provider2))
    return;
  __privateGet2(this, _provider2).removeListener("accountsChanged", this.onAccountsChanged);
  __privateGet2(this, _provider2).removeListener("chainChanged", this.onChainChanged);
  __privateGet2(this, _provider2).removeListener("disconnect", this.onDisconnect);
  __privateGet2(this, _provider2).removeListener("session_delete", this.onDisconnect);
  __privateGet2(this, _provider2).removeListener("display_uri", this.onDisplayUri);
  __privateGet2(this, _provider2).removeListener("connect", this.onConnect);
};
_setRequestedChainsIds = /* @__PURE__ */ new WeakSet();
setRequestedChainsIds_fn = function(chains) {
  localStorage.setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));
};
_getRequestedChainsIds = /* @__PURE__ */ new WeakSet();
getRequestedChainsIds_fn = function() {
  const data2 = localStorage.getItem(REQUESTED_CHAINS_KEY);
  return data2 ? JSON.parse(data2) : [];
};
_getNamespaceChainsIds = /* @__PURE__ */ new WeakSet();
getNamespaceChainsIds_fn = function() {
  if (!__privateGet2(this, _provider2))
    return [];
  const chainIds = __privateGet2(this, _provider2).session?.namespaces[NAMESPACE]?.chains?.map(
    (chain) => parseInt(chain.split(":")[1] || "")
  );
  return chainIds ?? [];
};
_getNamespaceMethods = /* @__PURE__ */ new WeakSet();
getNamespaceMethods_fn = function() {
  if (!__privateGet2(this, _provider2))
    return [];
  const methods = __privateGet2(this, _provider2).session?.namespaces[NAMESPACE]?.methods;
  return methods ?? [];
};

// node_modules/@wagmi/connectors/dist/walletConnectLegacy.js
var import_utils30 = __toESM(require_utils5(), 1);
var switchChainAllowedRegex = /(imtoken|metamask|rainbow|trust wallet|uniswap wallet|ledger)/i;
var _provider3;
var _switchChain;
var switchChain_fn;
var WalletConnectLegacyConnector = class extends Connector {
  constructor(config) {
    super(config);
    __privateAdd2(this, _switchChain);
    __publicField(this, "id", "walletConnectLegacy");
    __publicField(this, "name", "WalletConnectLegacy");
    __publicField(this, "ready", true);
    __privateAdd2(this, _provider3, void 0);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: (0, import_utils30.getAddress)(accounts[0]) });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    });
    __publicField(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect({ chainId } = {}) {
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const lastUsedChainId = getClient().lastUsedChainId;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
      }
      const provider = await this.getProvider({
        chainId: targetChainId,
        create: true
      });
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      setTimeout(() => this.emit("message", { type: "connecting" }), 0);
      const accounts = await provider.enable();
      const account = (0, import_utils30.getAddress)(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      const walletName = provider.connector?.peerMeta?.name ?? "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = __privateMethod2(this, _switchChain, switchChain_fn);
      return {
        account,
        chain: { id: id2, unsupported },
        provider: new lib_exports.Web3Provider(
          provider
        )
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.disconnect();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = provider.accounts;
    return (0, import_utils30.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  async getProvider({
    chainId,
    create: create2
  } = {}) {
    if (!__privateGet2(this, _provider3) || chainId || create2) {
      const rpc = !this.options?.infuraId ? this.chains.reduce(
        (rpc2, chain) => ({
          ...rpc2,
          [chain.id]: chain.rpcUrls.default.http[0]
        }),
        {}
      ) : {};
      const WalletConnectProvider2 = (await Promise.resolve().then(() => (init_esm14(), esm_exports7))).default;
      __privateSet2(this, _provider3, new WalletConnectProvider2({
        ...this.options,
        chainId,
        rpc: { ...rpc, ...this.options?.rpc }
      }));
    }
    return __privateGet2(this, _provider3);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    return new lib_exports.Web3Provider(
      provider,
      chainId
    ).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
};
_provider3 = /* @__PURE__ */ new WeakMap();
_switchChain = /* @__PURE__ */ new WeakSet();
switchChain_fn = async function(chainId) {
  const provider = await this.getProvider();
  const id2 = (0, import_utils30.hexValue)(chainId);
  try {
    await Promise.race([
      provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id2 }]
      }),
      new Promise(
        (res) => this.on("change", ({ chain }) => {
          if (chain?.id === chainId)
            res(chainId);
        })
      )
    ]);
    return this.chains.find((x8) => x8.id === chainId) ?? {
      id: chainId,
      name: `Chain ${id2}`,
      network: `${id2}`,
      nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
      rpcUrls: { default: { http: [""] }, public: { http: [""] } }
    };
  } catch (error) {
    const message = typeof error === "string" ? error : error?.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError(error);
    throw new SwitchChainError(error);
  }
};

// node_modules/@wagmi/core/dist/providers/jsonRpc.js
function jsonRpcProvider({
  priority,
  rpc,
  stallTimeout,
  static: static_ = true,
  weight
}) {
  return function(chain) {
    const rpcConfig = rpc(chain);
    if (!rpcConfig || rpcConfig.http === "")
      return null;
    return {
      chain: {
        ...chain,
        rpcUrls: {
          ...chain.rpcUrls,
          default: { http: [rpcConfig.http] }
        }
      },
      provider: () => {
        const RpcProvider = static_ ? lib_exports.StaticJsonRpcProvider : lib_exports.JsonRpcProvider;
        const provider = new RpcProvider(rpcConfig.http, {
          ensAddress: chain.contracts?.ensRegistry?.address,
          chainId: chain.id,
          name: chain.network
        });
        return Object.assign(provider, { priority, stallTimeout, weight });
      },
      ...rpcConfig.webSocket && {
        webSocketProvider: () => new lib_exports.WebSocketProvider(
          rpcConfig.webSocket,
          chain.id
        )
      }
    };
  };
}

// node_modules/@web3modal/ethereum/dist/index.js
var A9 = class {
  constructor(t8, n8) {
    this.wagmi = {}, this.walletConnectUri = "", this.walletConnectVersion = 1, this.chains = [], this.namespace = "eip155", this.disconnect = disconnect, this.getAccount = getAccount, this.watchAccount = watchAccount, this.fetchBalance = fetchBalance, this.getNetwork = getNetwork2, this.watchNetwork = watchNetwork, this.switchNetwork = switchNetwork, this.fetchEnsName = fetchEnsName, this.fetchEnsAvatar = fetchEnsAvatar, this.wagmi = t8, this.chains = n8;
    const { isV2: e11 } = this.getWalletConnectConnectors();
    this.walletConnectVersion = e11 ? 2 : 1;
  }
  getDefaultConnectorChainId(t8) {
    return t8.chains[0].id;
  }
  getWalletConnectConnectors() {
    const t8 = this.wagmi.connectors.find((c8) => c8.id === "walletConnect"), n8 = this.wagmi.connectors.find((c8) => c8.id === "walletConnectLegacy"), e11 = t8 ?? n8;
    if (!e11)
      throw new Error("WalletConnectConnector or WalletConnectLegacyConnector is required");
    return { isV2: !!t8, connector: e11 };
  }
  async connectWalletConnectV1(t8, n8) {
    return new Promise((e11, c8) => {
      t8.once("message", async ({ type: r7 }) => {
        if (r7 === "connecting") {
          const o11 = (await t8.getProvider()).connector;
          this.walletConnectUri = o11.uri, n8(o11.uri), o11.on("disconnect", () => {
            c8(Error());
          }), o11.on("connect", () => {
            e11();
          });
        }
      });
    });
  }
  async connectWalletConnectV2(t8, n8) {
    const e11 = await t8.getProvider();
    let c8 = "";
    return new Promise((r7) => {
      e11.once("display_uri", (o11) => {
        this.walletConnectUri = o11, c8 = o11, n8(o11);
      }), e11.once("connect", () => {
        c8 === this.walletConnectUri && r7();
      });
    });
  }
  getDefaultChain() {
    const t8 = this.chains.find((n8) => n8.id === 1);
    return t8 ?? this.chains[0];
  }
  getConnectorById(t8) {
    const n8 = this.wagmi.connectors.find((e11) => e11.id === t8);
    if (!n8)
      throw new Error(`Connector for id ${t8} was not found`);
    return n8;
  }
  getConnectors() {
    return this.wagmi.connectors.filter((t8) => !t8.id.includes("walletConnect"));
  }
  async connectWalletConnect(t8, n8) {
    const { connector: e11, isV2: c8 } = this.getWalletConnectConnectors(), r7 = n8 ?? this.getDefaultConnectorChainId(e11), o11 = c8 ? this.connectWalletConnectV2.bind(this) : this.connectWalletConnectV1.bind(this), [a9] = await Promise.all([connect({ connector: e11, chainId: r7 }), o11(e11, t8)]);
    return a9;
  }
  async connectConnector(t8, n8) {
    const e11 = this.getConnectorById(t8), c8 = n8 ?? this.getDefaultConnectorChainId(e11);
    return await connect({ connector: e11, chainId: c8 });
  }
};
var v6 = "eip155";
function P9({ projectId: i10 }) {
  return jsonRpcProvider({ rpc: (t8) => {
    var n8;
    return [1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 11297108109].includes(t8.id) ? { http: `https://rpc.walletconnect.com/v1/?chainId=${v6}:${t8.id}&projectId=${i10}` } : { http: t8.rpcUrls.default.http[0], webSocket: (n8 = t8.rpcUrls.default.webSocket) == null ? void 0 : n8[0] };
  } });
}
function j7({ chains: i10, version: t8, projectId: n8 }) {
  const e11 = t8 === 1, c8 = [new InjectedConnector({ chains: i10 })];
  return e11 ? c8.unshift(new WalletConnectLegacyConnector({ chains: i10, options: { qrcode: false } })) : c8.unshift(new WalletConnectConnector({ chains: i10, options: { projectId: n8, showQrModal: false } })), c8;
}

// node_modules/@web3modal/html/dist/index.js
init_dist();
var d8 = Object.defineProperty;
var p9 = Object.defineProperties;
var b9 = Object.getOwnPropertyDescriptors;
var s10 = Object.getOwnPropertySymbols;
var f6 = Object.prototype.hasOwnProperty;
var m10 = Object.prototype.propertyIsEnumerable;
var a8 = (r7, e11, t8) => e11 in r7 ? d8(r7, e11, { enumerable: true, configurable: true, writable: true, value: t8 }) : r7[e11] = t8;
var C9 = (r7, e11) => {
  for (var t8 in e11 || (e11 = {}))
    f6.call(e11, t8) && a8(r7, t8, e11[t8]);
  if (s10)
    for (var t8 of s10(e11))
      m10.call(e11, t8) && a8(r7, t8, e11[t8]);
  return r7;
};
var h10 = (r7, e11) => p9(r7, b9(e11));
var y9 = class {
  constructor(e11, t8) {
    this.openModal = x3.open, this.closeModal = x3.close, this.subscribeModal = x3.subscribe, this.setTheme = B3.setThemeConfig, this.setDefaultChain = i2.setSelectedChain, B3.setThemeConfig(e11), p3.setEthereumClient(t8), S2.setConfig(h10(C9({}, e11), { walletConnectVersion: t8.walletConnectVersion })), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await Promise.resolve().then(() => (init_dist2(), dist_exports));
      const e11 = document.createElement("w3m-modal");
      document.body.insertAdjacentElement("beforeend", e11), i2.setIsUiLoaded(true);
    }
  }
};

// src/js/index.js
var import_bignumber8 = __toESM(require_lib3());
var modal;
var ethereumClient;
var configured = false;
var unwatchBlockNumber;
function convertChains(selectedChains) {
  let arr = [];
  selectedChains.forEach((chain) => {
    switch (chain) {
      case 0:
        arr.push(arbitrum);
        break;
      case 1:
        arr.push(arbitrumGoerli);
        break;
      case 2:
        arr.push(aurora);
        break;
      case 3:
        arr.push(auroraTestnet);
        break;
      case 4:
        arr.push(avalanche);
        break;
      case 5:
        arr.push(avalancheFuji);
        break;
      case 6:
        arr.push(baseGoerli);
        break;
      case 7:
        arr.push(boba);
        break;
      case 8:
        arr.push(bronos);
        break;
      case 9:
        arr.push(bronosTestnet);
        break;
      case 10:
        arr.push(bsc);
        break;
      case 11:
        arr.push(bscTestnet);
        break;
      case 12:
        arr.push(canto);
        break;
      case 13:
        arr.push(celo);
        break;
      case 14:
        arr.push(celoAlfajores);
        break;
      case 15:
        arr.push(cronos);
        break;
      case 16:
        arr.push(crossbell);
        break;
      case 17:
        arr.push(dfk);
        break;
      case 18:
        arr.push(dogechain);
        break;
      case 19:
        arr.push(evmos);
        break;
      case 20:
        arr.push(evmosTestnet);
        break;
      case 21:
        arr.push(fantom);
        break;
      case 22:
        arr.push(fantomTestnet);
        break;
      case 23:
        arr.push(filecoin);
        break;
      case 24:
        arr.push(filecoinHyperspace);
        break;
      case 25:
        arr.push(foundry);
        break;
      case 26:
        arr.push(iotex);
        break;
      case 27:
        arr.push(iotexTestnet);
        break;
      case 28:
        arr.push(goerli);
        break;
      case 29:
        arr.push(gnosis);
        break;
      case 30:
        arr.push(gnosisChiado);
        break;
      case 31:
        arr.push(hardhat);
        break;
      case 32:
        arr.push(harmonyOne);
        break;
      case 33:
        arr.push(klaytn);
        break;
      case 34:
        arr.push(localhost);
        break;
      case 35:
        arr.push(mainnet);
        break;
      case 36:
        arr.push(metis);
        break;
      case 37:
        arr.push(metisGoerli);
        break;
      case 38:
        arr.push(moonbaseAlpha);
        break;
      case 39:
        arr.push(moonbeam);
        break;
      case 40:
        arr.push(moonriver);
        break;
      case 41:
        arr.push(okc);
        break;
      case 42:
        arr.push(optimism);
        break;
      case 43:
        arr.push(optimismGoerli);
        break;
      case 44:
        arr.push(polygon);
        break;
      case 45:
        arr.push(polygonMumbai);
        break;
      case 46:
        arr.push(polygonZkEvmTestnet);
        break;
      case 47:
        arr.push(scrollTestnet);
        break;
      case 48:
        arr.push(sepolia);
        break;
      case 49:
        arr.push(skaleBlockBrawlers);
        break;
      case 50:
        arr.push(skaleCalypso);
        break;
      case 51:
        arr.push(skaleCalypsoTestnet);
        break;
      case 52:
        arr.push(skaleChaosTestnet);
        break;
      case 53:
        arr.push(skaleCryptoBlades);
        break;
      case 54:
        arr.push(skaleCryptoColosseum);
        break;
      case 55:
        arr.push(skaleEuropa);
        break;
      case 56:
        arr.push(skaleEuropaTestnet);
        break;
      case 57:
        arr.push(skaleExorde);
        break;
      case 58:
        arr.push(skaleHumanProtocol);
        break;
      case 59:
        arr.push(skaleNebula);
        break;
      case 60:
        arr.push(skaleNebulaTestnet);
        break;
      case 61:
        arr.push(skaleRazor);
        break;
      case 62:
        arr.push(skaleTitan);
        break;
      case 63:
        arr.push(skaleTitanTestnet);
        break;
      case 64:
        arr.push(shardeumSphinx);
        break;
      case 65:
        arr.push(taraxa);
        break;
      case 66:
        arr.push(taraxaTestnet);
        break;
      case 67:
        arr.push(telos);
        break;
      case 68:
        arr.push(telosTestnet);
        break;
      case 69:
        arr.push(wanchain);
        break;
      case 70:
        arr.push(wanchainTestnet);
        break;
      case 71:
        arr.push(zhejiang);
        break;
      case 72:
        arr.push(zkSync);
        break;
      case 73:
        arr.push(zkSyncTestnet);
        break;
      default:
        throw `Unrecognised chain: ${chain}`;
    }
  });
  return arr;
}
function onAccountChangedReplacer(key, value) {
  if (key == "connector") {
    return void 0;
  }
  return value;
}
function getErrorResponse(e11) {
  let response = {
    result: null,
    error: e11.reason ?? e11.message ?? e11,
    success: false
  };
  return JSON.stringify(response);
}
function getSuccessResponse(result) {
  let response = {
    result,
    error: null,
    success: true
  };
  return JSON.stringify(response);
}
function getSuccessResponseWithReplacer(result, replacer) {
  let response = {
    result,
    error: null,
    success: true
  };
  return JSON.stringify(response, replacer);
}
async function configure(options, dotNetInterop) {
  if (configured) {
    return;
  }
  let {
    projectId,
    selectedChains,
    autoConnect,
    themeOptions,
    mobileWallets,
    desktopWallets,
    walletImages,
    chainImages,
    tokenImages,
    explorerAllowList,
    explorerDenyList,
    termsOfServiceUrl,
    privacyPolicyUrl,
    enableNetworkView,
    enableAccountView,
    enableExplorer
  } = JSON.parse(options);
  const convertedChains = convertChains(selectedChains);
  const { provider } = configureChains(convertedChains, [P9({ projectId })]);
  const wagmiClient = createClient({
    autoConnect,
    connectors: j7({ projectId, version: 2, convertedChains }),
    provider
  });
  ethereumClient = new A9(wagmiClient, convertedChains);
  modal = new y9({
    projectId,
    themeMode: themeOptions.themeMode == 0 ? "light" : "dark",
    themeVariables: themeOptions.themeVariables,
    mobileWallets,
    desktopWallets,
    walletImages,
    chainImages,
    tokenImages,
    explorerAllowList,
    explorerDenyList,
    termsOfServiceUrl,
    privacyPolicyUrl,
    enableNetworkView,
    enableAccountView,
    enableExplorer
  }, ethereumClient);
  ethereumClient.watchAccount((account) => {
    dotNetInterop.invokeMethodAsync("OnAccountChanged", JSON.stringify(account, onAccountChangedReplacer));
  });
  ethereumClient.watchNetwork((network) => {
    dotNetInterop.invokeMethodAsync("OnNetworkChanged", JSON.stringify(network.chain));
  });
  configured = true;
}
async function openModal() {
  if (!configured) {
    throw "Attempting to open modal before we have configured.";
  }
  await modal.openModal();
}
async function closeModal() {
  if (!configured) {
    throw "Attempting to close modal before we have configured.";
  }
  await modal.closeModal();
}
function setTheme(themeMode, themeVariables) {
  if (!configured) {
    throw "Attempting to set theme before we have configured.";
  }
  modal.setTheme({
    themeMode,
    themeVariables
  });
}
async function disconnect2() {
  if (!configured) {
    throw "Attempting to disconnect before we have configured.";
  }
  await ethereumClient.disconnect();
}
function getAccount2() {
  if (!configured) {
    throw "Attempting to get account before we have configured.";
  }
  try {
    let result = ethereumClient.getAccount();
    return getSuccessResponseWithReplacer(result, onAccountChangedReplacer);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
function getNetwork3() {
  if (!configured) {
    throw "Attempting to get network before we have configured.";
  }
  try {
    let network = ethereumClient.getNetwork();
    return getSuccessResponse(network.chain);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function switchNetwork2(chainId) {
  if (!configured) {
    throw "Attempting to switch network before we have configured.";
  }
  try {
    let result = await ethereumClient.switchNetwork({ chainId });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function trySendTransaction(input, dotNetInterop) {
  if (!configured) {
    throw "Attempting to send transaction before we have configured.";
  }
  let parsedTransaction = JSON.parse(input);
  delete parsedTransaction.gas;
  try {
    const config = await prepareSendTransaction({
      request: parsedTransaction
    });
    if (config.request.gasLimit.gt(import_bignumber8.BigNumber.from("21000"))) {
      config.request.gasLimit = config.request.gasLimit.div(4).mul(5);
    }
    const { hash, wait } = await sendTransaction(config);
    setTimeout(async () => {
      try {
        let result = await wait();
        dotNetInterop.invokeMethodAsync("OnTransactionComplete", JSON.stringify(result));
      } catch (e11) {
        console.log(e11);
      }
    }, 0);
    return getSuccessResponse(hash);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function trySignMessage(message) {
  if (!configured) {
    throw "Attempting to sign message before we have configured.";
  }
  try {
    const result = await signMessage({
      message
    });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function trySignTypedData(domain2, types, value) {
  if (!configured) {
    throw "Attempting to sign typed data before we have configured.";
  }
  try {
    let parsedDomain = JSON.parse(domain2);
    let parsedTypes = JSON.parse(types);
    let parsedValue = JSON.parse(value);
    const result = await signTypedData({
      domain: parsedDomain,
      types: parsedTypes.types,
      value: parsedValue
    });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getBalance(address, chainId, tokenAddress) {
  if (!configured) {
    throw "Attempting to get balance before we have configured.";
  }
  try {
    let result = await ethereumClient.fetchBalance({ address, chainId, token: tokenAddress });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getEnsAvatar(address, chainId) {
  if (!configured) {
    throw "Attempting to get ens avatar before we have configured.";
  }
  try {
    let result = await ethereumClient.fetchEnsAvatar({ address, chainId });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getEnsName(address, chainId) {
  if (!configured) {
    throw "Attempting to get ens name before we have configured.";
  }
  try {
    let result = await ethereumClient.fetchEnsName({ address, chainId });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getEnsAddress(name2, chainId) {
  if (!configured) {
    throw "Attempting to get ens address before we have configured.";
  }
  try {
    let result = await fetchEnsAddress({ chainId, name: name2 });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getFeeData(chainId) {
  if (!configured) {
    throw "Attempting to get fee data before we have configured.";
  }
  try {
    let result = await fetchFeeData({ formatUnits: "gwei", chainId });
    return getSuccessResponse(result.formatted);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getTransaction(hash, chainId) {
  if (!configured) {
    throw "Attempting to get transaction before we have configured.";
  }
  try {
    let result = await fetchTransaction({ chainId, hash });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getToken(address, chainId) {
  if (!configured) {
    throw "Attempting to get token before we have configured.";
  }
  try {
    let result = await fetchToken({ address, chainId });
    result.totalSupply = result.totalSupply.value;
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function getBlockNumber(chainId) {
  if (!configured) {
    throw "Attempting to get block number before we have configured.";
  }
  try {
    let result = await fetchBlockNumber({ chainId });
    return getSuccessResponse(result);
  } catch (e11) {
    return getErrorResponse(e11);
  }
}
async function startWatchingBlockNumber(chainId, dotNetInterop) {
  if (!configured) {
    throw "Attempting to start watching block number before we have configured.";
  }
  if (unwatchBlockNumber == void 0) {
    unwatchBlockNumber = watchBlockNumber(
      { chainId, listen: true },
      (blockNumber) => {
        dotNetInterop.invokeMethodAsync("OnBlockNumber", JSON.stringify(blockNumber));
      }
    );
  }
}
async function stopWatchingBlockNumber() {
  if (!configured) {
    throw "Attempting to stop watching block number before we have configured.";
  }
  if (unwatchBlockNumber != void 0) {
    unwatchBlockNumber();
    unwatchBlockNumber = void 0;
  }
}
export {
  closeModal,
  configure,
  disconnect2 as disconnect,
  getAccount2 as getAccount,
  getBalance,
  getBlockNumber,
  getEnsAddress,
  getEnsAvatar,
  getEnsName,
  getFeeData,
  getNetwork3 as getNetwork,
  getToken,
  getTransaction,
  openModal,
  setTheme,
  startWatchingBlockNumber,
  stopWatchingBlockNumber,
  switchNetwork2 as switchNetwork,
  trySendTransaction,
  trySignMessage,
  trySignTypedData
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=index.bundle.js.map
